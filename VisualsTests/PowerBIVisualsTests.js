/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbitests;
(function (powerbitests) {
    powerbitests.DefaultWaitForRender = 10;
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../typedefs/globalize/globalize.d.ts"/>
///<reference path="../../typedefs/d3/d3.d.ts"/>
///<reference path="../../typedefs/jasmine/jasmine-jquery.d.ts"/>
///<reference path="../../typedefs/jasmine/jasmine.d.ts"/>
///<reference path="../../typedefs/jQuery/jQuery.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../VisualsCommon/obj/VisualsCommon.d.ts"/>
///<reference path="../../VisualsData/obj/VisualsData.d.ts"/>
///<reference path="../../Visuals/obj/Visuals.d.ts"/> 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var mocks;
    (function (mocks) {
        var SQExprBuilder = powerbi.data.SQExprBuilder;
        var defaultVisualHostServices = powerbi.visuals.defaultVisualHostServices;
        var TelemetryCallbackMock = (function () {
            function TelemetryCallbackMock() {
            }
            TelemetryCallbackMock.prototype.target = function () {
                TelemetryCallbackMock.callbackCalls++;
            };
            TelemetryCallbackMock.callbackCalls = 0;
            return TelemetryCallbackMock;
        })();
        mocks.TelemetryCallbackMock = TelemetryCallbackMock;
        ;
        var AppInsightsV2Mock = (function () {
            function AppInsightsV2Mock() {
                this.trackPageViewTimes = 0;
                this.trackEventTimes = 0;
                this.trackEventLastActivityName = null;
                this.trackEventLastAdditionalData = {
                    id: null,
                    start: null,
                    end: null,
                    isInternalUser: null,
                    userId: null,
                    category: null,
                    sessionId: null,
                    client: null,
                    build: null,
                    cluster: null,
                };
            }
            AppInsightsV2Mock.prototype.trackPageView = function () {
                this.trackPageViewTimes++;
            };
            AppInsightsV2Mock.prototype.trackEvent = function (activityName, additionalData) {
                this.trackEventTimes++;
                this.trackEventLastActivityName = activityName;
                this.trackEventLastAdditionalData = additionalData;
            };
            return AppInsightsV2Mock;
        })();
        mocks.AppInsightsV2Mock = AppInsightsV2Mock;
        mocks.DefaultLoggerMockType = 1;
        var MockTimerPromiseFactory = (function () {
            function MockTimerPromiseFactory() {
            }
            MockTimerPromiseFactory.prototype.create = function (delayInMs) {
                if (!this.deferred) {
                    this.deferred = $.Deferred();
                }
                return this.deferred;
            };
            MockTimerPromiseFactory.prototype.resolveCurrent = function () {
                expect(this.deferred).toBeDefined();
                // Note: we need to read the current deferred field into a local var and null out the member before
                // we call resolve, just in case one of timer callbacks recursively creates another timer.
                var deferred = this.deferred;
                this.deferred = undefined;
                deferred.resolve();
            };
            MockTimerPromiseFactory.prototype.reject = function () {
                expect(this.deferred).toBeDefined();
                // Note: we need to read the current deferred field into a local var and null out the member before
                // we call reject, just in case one of timer callbacks recursively creates another timer.
                var deferred = this.deferred;
                this.deferred = undefined;
                deferred.reject();
            };
            MockTimerPromiseFactory.prototype.expectNoTimers = function () {
                expect(this.deferred).not.toBeDefined();
            };
            MockTimerPromiseFactory.prototype.hasPendingTimers = function () {
                return !!this.deferred;
            };
            return MockTimerPromiseFactory;
        })();
        mocks.MockTimerPromiseFactory = MockTimerPromiseFactory;
        function createVisualHostServices() {
            return defaultVisualHostServices;
        }
        mocks.createVisualHostServices = createVisualHostServices;
        var MockTraceListener = (function () {
            function MockTraceListener() {
            }
            MockTraceListener.prototype.logTrace = function (trace) {
                this.trace = trace;
            };
            return MockTraceListener;
        })();
        mocks.MockTraceListener = MockTraceListener;
        function dataViewScopeIdentity(fakeValue) {
            var expr = constExpr(fakeValue);
            return powerbi.data.createDataViewScopeIdentity(expr);
        }
        mocks.dataViewScopeIdentity = dataViewScopeIdentity;
        function dataViewScopeIdentityWithEquality(keyExpr, fakeValue) {
            return powerbi.data.createDataViewScopeIdentity(powerbi.data.SQExprBuilder.equal(keyExpr, constExpr(fakeValue)));
        }
        mocks.dataViewScopeIdentityWithEquality = dataViewScopeIdentityWithEquality;
        function constExpr(fakeValue) {
            if (fakeValue === null)
                return SQExprBuilder.nullConstant();
            if (fakeValue === true || fakeValue === false)
                return SQExprBuilder.boolean(fakeValue);
            return (typeof (fakeValue) === 'number')
                ? powerbi.data.SQExprBuilder.double(fakeValue)
                : powerbi.data.SQExprBuilder.text(fakeValue);
        }
        var MockVisualWarning = (function () {
            function MockVisualWarning() {
                // Allow 'code' to be modified for testing.
                this.code = 'MockVisualWarning';
            }
            MockVisualWarning.prototype.getMessages = function (resourceProvider) {
                var details = {
                    message: MockVisualWarning.Message,
                    title: 'key',
                    detail: 'val',
                };
                return details;
            };
            MockVisualWarning.Message = 'Warning';
            return MockVisualWarning;
        })();
        mocks.MockVisualWarning = MockVisualWarning;
        function setLocale() {
            powerbi.visuals.DefaultVisualHostServices.initialize();
        }
        mocks.setLocale = setLocale;
        function getLocalizedString(stringId) {
            return defaultVisualHostServices.getLocalizedString(stringId);
        }
        mocks.getLocalizedString = getLocalizedString;
    })(mocks = powerbitests.mocks || (powerbitests.mocks = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var tableDataViewHelper;
    (function (tableDataViewHelper) {
        var ValueType = powerbi.ValueType;
        (function (ColumnType) {
            ColumnType[ColumnType["Text"] = 0] = "Text";
            ColumnType[ColumnType["Numeric"] = 1] = "Numeric";
            ColumnType[ColumnType["NumericMeasure"] = 2] = "NumericMeasure";
        })(tableDataViewHelper.ColumnType || (tableDataViewHelper.ColumnType = {}));
        var ColumnType = tableDataViewHelper.ColumnType;
        /** Create a table which contains @columnCount number of columns */
        function getDataWithColumns(columnCount, numRows, objects) {
            if (numRows === void 0) { numRows = 1; }
            // Generate alternating column types
            var columnTypes = [];
            for (var i = 0; i < columnCount; ++i) {
                columnTypes.push(i % 2 === 0 ? ColumnType.Numeric : ColumnType.Text);
            }
            return tableDataViewHelper.getDataWithColumnsOfType(columnTypes, false, numRows, objects);
        }
        tableDataViewHelper.getDataWithColumns = getDataWithColumns;
        /** Create a table which contains columns with the specified types */
        function getDataWithColumnsOfType(columnTypes, hasSubtotals, numRows, objects) {
            if (numRows === void 0) { numRows = 1; }
            var columns = [], rows = [], totals = [];
            for (var i = 0, len = columnTypes.length; i < len; ++i) {
                var isMeasure = columnTypes[i] === ColumnType.NumericMeasure;
                if (columnTypes[i] === ColumnType.Numeric || isMeasure) {
                    columns.push({ displayName: 'numeric' + i, type: ValueType.fromDescriptor({ numeric: true }), isMeasure: isMeasure });
                    rows.push(i);
                    if (hasSubtotals)
                        totals.push(isMeasure ? i : null);
                }
                else {
                    columns.push({ displayName: 'text' + i, type: ValueType.fromDescriptor({ numeric: false }) });
                    rows.push('cell text ' + i);
                    if (hasSubtotals)
                        totals.push(null);
                }
            }
            var dataViewMetadata = {
                columns: columns,
                objects: objects,
            };
            var rowsArray = [];
            for (var i = 0; i < numRows; i++)
                rowsArray.push(rows);
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: rowsArray,
                    columns: dataViewMetadata.columns
                },
            };
            if (totals.length > 0)
                data.table.totals = totals;
            return data;
        }
        tableDataViewHelper.getDataWithColumnsOfType = getDataWithColumnsOfType;
        function dataViewObjectsTotals(totalsEnabled) {
            return {
                general: {
                    totals: totalsEnabled,
                }
            };
        }
        tableDataViewHelper.dataViewObjectsTotals = dataViewObjectsTotals;
    })(tableDataViewHelper = powerbitests.tableDataViewHelper || (powerbitests.tableDataViewHelper = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var tablixHelper;
    (function (tablixHelper) {
        var CssConstants = jsCommon.CssConstants;
        ;
        ;
        /** Gets the specified cell of a 'new table' visual using 0-based indices. */
        function getTableCell(tableBody, coordinate) {
            var clickTargetSelector = '> tr:nth-child(' + (coordinate.row + 1) + ') > td:nth-child(' + (coordinate.col + 1) + ') > div';
            var textDivSelector = '> div';
            var clickTarget = $(clickTargetSelector, tableBody);
            expect(clickTarget).toBeInDOM();
            var textDiv = $(textDivSelector, clickTarget);
            expect(textDiv).toBeInDOM();
            return { cellCoordinate: coordinate, clickTarget: clickTarget, text: textDiv.text() };
        }
        tablixHelper.getTableCell = getTableCell;
        /** Renders the table based on the options passed in. */
        function renderNewTablix(element, options) {
            var viewport = options.viewport ? options.viewport : { height: element.height() + 200, width: element.width() + 200 };
            var data = options.data;
            var redraw = options.redraw ? options.redraw : false;
            var style = powerbi.visuals.visualStyles.create();
            element.width(viewport.width);
            element.css(CssConstants.minWidthProperty, viewport.width);
            element.css(CssConstants.maxWidthProperty, viewport.width);
            element.css(CssConstants.positionProperty, CssConstants.absoluteValue);
            var featureSwitches = {
                scrollableVisuals: true,
            };
            var visualPluginService = powerbi.visuals.visualPluginFactory.createMinerva(featureSwitches);
            var sortCallback = options.onCustomSortCallback ? options.onCustomSortCallback : function (args) { };
            var hostService = {
                getLocalizedString: function (stringId) { return stringId; },
                onCustomSort: sortCallback,
                loadMoreData: function () { },
                getViewMode: function () { return 0 /* View */; }
            };
            if (options.formatCallback)
                spyOn(powerbi.visuals.valueFormatter, 'formatRaw').and.callFake(options.formatCallback);
            var v = visualPluginService.getPlugin(options.visualType).create();
            v.init({
                element: element,
                host: hostService,
                style: style,
                viewport: viewport,
                interactivity: {
                    selection: true,
                    overflow: options.isFixedSize ? 'hidden' : 'visible'
                }
            });
            v.onDataChanged({ dataViews: [data] });
            var promise = jsCommon.TimerPromiseFactory.instance.create(powerbitests.DefaultWaitForRender)
                .then(function () {
                if (redraw)
                    v.onResizing({ height: viewport.height, width: viewport.width });
                return v;
            });
            return promise;
        }
        tablixHelper.renderNewTablix = renderNewTablix;
        /** Runs a table sort test by first creating the table based on the specified data, then
            validating the generated headers before executing a set of clicks and validating
            the recorded sort events. */
        function runTablixSortTest(element, done, visualType, data, expectedColumnHeaders, clicks, expectedSorts) {
            var actualSorts = [];
            var sortCallback = function (args) {
                actualSorts.push(args.sortDescriptors);
            };
            var renderTablixPromise = renderNewTablix(element, {
                visualType: visualType,
                data: data,
                onCustomSortCallback: sortCallback,
            });
            renderTablixPromise.then(function () {
                var tableBody = $('.tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody');
                expect(tableBody).toBeInDOM();
                // Validate column headers
                if (expectedColumnHeaders) {
                    for (var i = 0, len = expectedColumnHeaders.length; i < len; i++) {
                        var coordinate = expectedColumnHeaders[i];
                        var headerCell = getTableCell(tableBody, coordinate);
                        if (coordinate.expectedText)
                            expect(headerCell.text).toBe(coordinate.expectedText);
                    }
                }
                // Execute the clicks
                if (clicks) {
                    for (var i = 0, len = clicks.length; i < len; i++) {
                        var clickCoordinate = clicks[i];
                        var clickCell = getTableCell(tableBody, clickCoordinate);
                        if (clickCoordinate.expectedText)
                            expect(clickCell.text).toBe(clickCoordinate.expectedText);
                        clickCell.clickTarget.click();
                    }
                }
                // Validate the expected sorts
                if (expectedSorts) {
                    expect(expectedSorts.length).toBe(actualSorts.length);
                    for (var i = 0, len = expectedSorts.length; i < len; i++) {
                        var expectedSort = expectedSorts[i];
                        var actualSort = actualSorts[i];
                        expect(expectedSort.length).toBe(actualSort.length);
                        for (var j = 0, jlen = expectedSort.length; j < jlen; j++) {
                            var expectedField = expectedSort[j];
                            var actualField = actualSort[j];
                            expect(expectedField.queryName).toBe(actualField.queryName);
                            expect(expectedField.sortDirection).toBe(actualField.sortDirection);
                        }
                    }
                }
                done();
            });
        }
        tablixHelper.runTablixSortTest = runTablixSortTest;
        function validateMatrix(expectedValues, selector) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                expect(cells.height()).not.toBe(0);
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).text();
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual value " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateMatrix = validateMatrix;
        function validateTable(expectedValues, selector) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).text();
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual value " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                    if (cells.eq(j).height() <= 1)
                        addError(errorString, "Actual height " + cells.eq(j).height() + " in row " + i + " and column " + j + " is expected to be > 1.");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateTable = validateTable;
        function validateClassNames(expectedValues, selector, noMarginClass) {
            var rows = $(selector);
            var result = [];
            var errorString = null;
            var ilen = rows.length;
            if (ilen !== expectedValues.length)
                addError(errorString, "Actual row count " + ilen + " does not match expected number of rows " + expectedValues.length + ".");
            for (var i = 0; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                var jlen = cells.length;
                if (jlen !== expectedValues[i].length)
                    addError(errorString, "Actual column count " + jlen + " in row " + i + " does not match expected number of columns " + expectedValues[i].length + ".");
                for (var j = 0; j < jlen; j++) {
                    result[i][j] = cells.eq(j).attr('class');
                    expectedValues[i][j] = addNoMarginClass(expectedValues[i][j], noMarginClass);
                    if (result[i][j] !== expectedValues[i][j])
                        addError(errorString, "Actual class name " + result[i][j] + " in row " + i + " and column " + j + " does not match expected value " + expectedValues[i][j] + ".");
                }
            }
            expect(errorString).toBeNull();
            expect(result).toEqual(expectedValues);
        }
        tablixHelper.validateClassNames = validateClassNames;
        function addError(errorString, message) {
            if (!errorString)
                return message;
            return errorString + "\r\n" + message;
        }
        function addNoMarginClass(classNames, noMarginClass) {
            if (!classNames || classNames.length === 0)
                return noMarginClass;
            return classNames + ' ' + noMarginClass;
        }
    })(tablixHelper = powerbitests.tablixHelper || (powerbitests.tablixHelper = {}));
})(powerbitests || (powerbitests = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var utils;
    (function (utils) {
        var ColorUtility;
        (function (ColorUtility) {
            var HexPattern = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
            var RGBRegex = /^rgb\(\s*(-?\d+)(%?)\s*,\s*(-?\d+)(%?)\s*,\s*(-?\d+)(%?)\s*\)$/;
            function convertFromRGBorHexToHex(value) {
                if (value.match(HexPattern)) {
                    return value;
                }
                return rgbStringToHex(value);
            }
            ColorUtility.convertFromRGBorHexToHex = convertFromRGBorHexToHex;
            ;
            function rgbStringToHex(rgb) {
                var result, r, g, b, hex = "";
                if ((result = RGBRegex.exec(rgb))) {
                    r = componentFromStr(result[1], result[2]);
                    g = componentFromStr(result[3], result[4]);
                    b = componentFromStr(result[5], result[6]);
                    hex = "#" + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
                }
                return hex;
            }
            ;
            function componentFromStr(numStr, percent) {
                var num = Math.max(0, parseInt(numStr, 10));
                return percent ?
                    Math.floor(255 * Math.min(100, num) / 100) : Math.min(255, num);
            }
            ;
        })(ColorUtility = utils.ColorUtility || (utils.ColorUtility = {}));
    })(utils = powerbitests.utils || (powerbitests.utils = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="typedefs/typedefs.ts"/>
/// <reference path="typedefs/typedefs.obj.ts"/>
/// <reference path="common.ts"/>
/// <reference path="helpers.ts"/>
/// <reference path="mocks.ts"/>
/// <reference path="tableDataViewHelper.ts"/>
/// <reference path="tablixHelper.ts"/>
/// <reference path="utils/colorUtility.ts"/> 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="_references.ts"/>
/* tslint:disable */
var powerBIAccessToken = "fooBarBaz";
var powerBIAccessTokenExpiry = "2115-01-01 00:00:00Z";
/* tslint:enable */
var powerbitests;
(function (powerbitests) {
    var helpers;
    (function (helpers) {
        debug.assertFailFunction = function (message) {
            expect(message).toBe('DEBUG asserts should never happen.  There is a product or test bug.');
        };
        helpers.dataSets = {
            singleMeasureDataViewSource: '{"descriptor": {"Select": [{"Kind": 2, "Value": "M0"}]}, "dsr": {"DataShapes":[{"Id":"DS0","PrimaryHierarchy":[{"Id":"DM0","Instances":[{"Calculations":[{"Id":"M0","Value":"21852688.46698004D"}]}]}],"IsComplete":true}]}}',
            dataViewSourceWithErrors: '{"descriptor":{"Select":[{"Kind":1,"Depth":0,"Value":"G0"},{"Kind":2,"Value":"M0","Subtotal":["A0"],"Min":["A2"],"Max":["A1"]}],"Expressions":{"Primary":{"Groupings":[{"Keys":[{"Source":{"Entity":"DimDate","Property":"Month Name"},"Select":0},{"Source":{"Entity":"DimDate","Property":"Month Number"},"Calc":"K0"}]}]}}},"dsr":{"DataShapes":[{"Id":"DS0","odata.error":{"code":"rsDataShapeQueryTranslationError","message":{"lang":"da-DK","value":"Data Shape Query translation failed with error code: \'InvalidExpression\'. Check the report server logs for more information."},"azure:values":[{"timestamp":"2015-01-15T07:44:45.8135124Z"},{"details":"Microsoft.ReportingServices.DataShapeQueryTranslation.DataShapeQueryTranslationException: Data Shape Query translation failed with error code: \'InvalidExpression\'. Check the report server logs for more information."},{"helpLink":"http://go.microsoft.com/fwlink/?LinkId=20476&EvtSrc=Microsoft.ReportingServ…Error&ProdName=Microsoft%20SQL%20Server%20Reporting%20Services&ProdVer=1.0"},{"productInfo":{"productName":"change this","productVersion":"1.0","productLocaleId":127,"operatingSystem":"OsIndependent","countryLocaleId":1033}},{"moreInformation":{"odata.error":{"code":"System.Exception","message":{"lang":"da-DK","value":"For more information about this error navigate to the report server on the local server machine, or enable remote errors"},"azure:values":[{"details":"System.Exception: For more information about this error navigate to the report server on the local server machine, or enable remote errors"}]}}}]}}]}}',
        };
        function testDom(height, width) {
            var testhtml = '<div id="item" style="height: ' + height + 'px; width: ' + width + 'px;"></div>';
            setFixtures(testhtml);
            var element = $('#item');
            return element;
        }
        helpers.testDom = testDom;
        function isTranslateCloseTo(actualTranslate, expectedX, expectedY) {
            var splitChar = actualTranslate.indexOf(",") > 0 ? ',' : ' ';
            var translateValues = actualTranslate.substr(10, actualTranslate.lastIndexOf(')') - 10).split(splitChar);
            var actualX = parseInt(translateValues[0], 10);
            var actualY = parseInt(translateValues[1], 10);
            var deltaX = Math.abs(expectedX - actualX);
            var deltaY = Math.abs(expectedY - actualY);
            // Tolerance of 1
            return deltaX <= 1 && deltaY <= 1;
        }
        helpers.isTranslateCloseTo = isTranslateCloseTo;
        /** Returns a function that can be called to trigger a dragstart. */
        function getDragStartTriggerFunctionForD3(element) {
            var elem = element;
            if (elem.__ondragstart)
                return function (arg) { return elem.__ondragstart(arg); };
        }
        helpers.getDragStartTriggerFunctionForD3 = getDragStartTriggerFunctionForD3;
        /** Returns a function that can be called to trigger a click. */
        function getClickTriggerFunctionForD3(element) {
            var elem = element;
            if (elem.__onclick)
                return function (arg) { return elem.__onclick(arg); };
        }
        helpers.getClickTriggerFunctionForD3 = getClickTriggerFunctionForD3;
        /** Execute a dummy expect to avoid Jasmine warnings, since some tests only perform validation directly on the httpService via expectPOST etc. */
        function suppressJasmineMissingExpectWarning() {
            expect(true).toBe(true);
        }
        helpers.suppressJasmineMissingExpectWarning = suppressJasmineMissingExpectWarning;
        (function (ClickEventType) {
            ClickEventType[ClickEventType["Default"] = 0] = "Default";
            ClickEventType[ClickEventType["CtrlKey"] = 1] = "CtrlKey";
            ClickEventType[ClickEventType["AltKey"] = 2] = "AltKey";
            ClickEventType[ClickEventType["ShiftKey"] = 4] = "ShiftKey";
            ClickEventType[ClickEventType["MetaKey"] = 8] = "MetaKey";
        })(helpers.ClickEventType || (helpers.ClickEventType = {}));
        var ClickEventType = helpers.ClickEventType;
        // Defining a simulated click event (see http://stackoverflow.com/questions/9063383/how-to-invoke-click-event-programmaticaly-in-d3)
        jQuery.fn.d3Click = function (x, y, eventType) {
            var type = eventType || ClickEventType.Default;
            this.each(function (i, e) {
                var evt = document.createEvent("MouseEvents");
                evt.initMouseEvent("click", true, true, window, 0, x, y, x, y, type & ClickEventType.CtrlKey, type & ClickEventType.AltKey, type & ClickEventType.ShiftKey, type & ClickEventType.MetaKey, 0, null); // relatedTarget
                e.dispatchEvent(evt);
            });
        };
        function runWithImmediateAnimationFrames(func) {
            var requestAnimationFrame = window.requestAnimationFrame;
            try {
                window.requestAnimationFrame = function (f) { return setTimeout(f, 0); };
                func();
            }
            finally {
                window.requestAnimationFrame = requestAnimationFrame;
            }
        }
        helpers.runWithImmediateAnimationFrames = runWithImmediateAnimationFrames;
        function deepCopy(object) {
            return JSON.parse(JSON.stringify(object));
        }
        helpers.deepCopy = deepCopy;
        function getLocalTimeFromUTCBase(utcYear, utcMonth, utcDay, utcHours, utcMinutes, utcSeconds) {
            // IMPORTANT: We need to dynamically calculate the UTC offset to use for our test date instead of hard-coding the offset so that:
            // i) It doesn't break when daylight savings changes the UTC offset
            // ii) The test works even if your machine is not in the US Pacific Time zone :)
            var baseDate = new Date(utcYear, utcMonth, utcDay, utcHours, utcMinutes, utcSeconds);
            var offsetMinutes = baseDate.getTimezoneOffset();
            var date = new Date();
            date.setTime(baseDate.getTime() - offsetMinutes * 60000);
            return date;
        }
        helpers.getLocalTimeFromUTCBase = getLocalTimeFromUTCBase;
        function isUndefined(value) { return typeof value === 'undefined'; }
        helpers.isUndefined = isUndefined;
        (function (ContextMenuEntityButtonPosition) {
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["NewMeasure"] = 0] = "NewMeasure";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["NewColumn"] = 1] = "NewColumn";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Rename"] = 3] = "Rename";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Delete"] = 4] = "Delete";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["Hide"] = 5] = "Hide";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["ViewHidden"] = 7] = "ViewHidden";
            ContextMenuEntityButtonPosition[ContextMenuEntityButtonPosition["UnhideAll"] = 8] = "UnhideAll";
        })(helpers.ContextMenuEntityButtonPosition || (helpers.ContextMenuEntityButtonPosition = {}));
        var ContextMenuEntityButtonPosition = helpers.ContextMenuEntityButtonPosition;
        (function (ContextMenuPropertyButtonPosition) {
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["AddFilter"] = 0] = "AddFilter";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["NewMeasure"] = 2] = "NewMeasure";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["NewColumn"] = 3] = "NewColumn";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Rename"] = 5] = "Rename";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Delete"] = 6] = "Delete";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["Hide"] = 7] = "Hide";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["ViewHidden"] = 9] = "ViewHidden";
            ContextMenuPropertyButtonPosition[ContextMenuPropertyButtonPosition["UnhideAll"] = 10] = "UnhideAll";
        })(helpers.ContextMenuPropertyButtonPosition || (helpers.ContextMenuPropertyButtonPosition = {}));
        var ContextMenuPropertyButtonPosition = helpers.ContextMenuPropertyButtonPosition;
        function parseDateString(dateString) {
            var date, timezoneOffset;
            date = new Date(dateString);
            if (date.toString() === 'Invalid Date') {
                return null;
            }
            timezoneOffset = date.getTimezoneOffset();
            date.setMinutes(date.getMinutes() + timezoneOffset);
            return date;
        }
        helpers.parseDateString = parseDateString;
    })(helpers = powerbitests.helpers || (powerbitests.helpers = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var AnimatedNumber = powerbi.visuals.AnimatedNumber;
    describe("AnimatedNumber", function () {
        it("AnimatedNumber registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("animatedNumber").capabilities).toBe(AnimatedNumber.capabilities);
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(AnimatedNumber.capabilities.objects)).toEqual(AnimatedNumber.formatStringProp);
        });
    });
    describe("AnimatedNumber DOM tests", function () {
        var dataViewBuilder;
        beforeEach(function () {
            dataViewBuilder = new DataViewBuilder();
        });
        it("AnimatedText onDataChanged sets text (no settings)", function () {
            dataViewBuilder.columns = [{ displayName: "col1", isMeasure: true }];
            dataViewBuilder.singleValue = 123.456;
            dataViewBuilder.onDataChanged();
            expect($(".animatedNumber")).toBeInDOM();
            expect($(".mainText")).toBeInDOM();
        });
    });
    var DataViewBuilder = (function () {
        function DataViewBuilder(width, height) {
            if (width === void 0) { width = "200"; }
            if (height === void 0) { height = "300"; }
            this.columns = [];
            this.host = powerbitests.mocks.createVisualHostServices();
            this.style = powerbi.visuals.visualStyles.create();
            this.setSize(width, height);
            this.visual = new AnimatedNumber();
            this.init();
        }
        Object.defineProperty(DataViewBuilder.prototype, "metadata", {
            get: function () {
                if (!this._metadata) {
                    this.buildMetadata();
                }
                return this._metadata;
            },
            enumerable: true,
            configurable: true
        });
        DataViewBuilder.prototype.init = function () {
            this.visual.init({
                element: this.element,
                host: this.host,
                style: this.style,
                viewport: {
                    height: this.element.height(),
                    width: this.element.width()
                },
                animation: {
                    transitionImmediate: true
                }
            });
        };
        DataViewBuilder.prototype.buildElement = function () {
            this.element = powerbitests.helpers.testDom(this.height, this.width);
        };
        DataViewBuilder.prototype.buildMetadata = function () {
            this._metadata = {
                columns: this.columns
            };
        };
        DataViewBuilder.prototype.buildDataView = function () {
            this._dataView = {
                metadata: this.metadata,
                single: { value: this.singleValue }
            };
        };
        Object.defineProperty(DataViewBuilder.prototype, "dataView", {
            get: function () {
                if (!this._dataView) {
                    this.buildDataView();
                }
                return this._dataView;
            },
            enumerable: true,
            configurable: true
        });
        DataViewBuilder.prototype.setSize = function (width, height) {
            this.width = width;
            this.height = height;
            this.buildElement();
        };
        DataViewBuilder.prototype.onDataChanged = function () {
            this.visual.onDataChanged({ dataViews: [this.dataView] });
        };
        return DataViewBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var AnimatedText = powerbi.visuals.AnimatedText;
    describe("AnimatedText", function () {
        it('AnimatedText_getSeedFontHeight does not exceed style maximum', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.style = powerbi.visuals.visualStyles.create();
            expect(animatedText.getSeedFontHeight(100, 90)).toBeLessThan(100);
        });
        it('AnimatedText_getSeedFontHeight returns a smaller number than the height', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.style = powerbi.visuals.visualStyles.create();
            expect(animatedText.getSeedFontHeight(100, 90)).toBeLessThan(100);
        });
        it('AnimatedText_getTextAnchor when the aligment is "left"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'left'
            };
            expect(animatedText.getTextAnchor()).toBe('start');
        });
        it('AnimatedText_getTextAnchor when the aligment is "right"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'right'
            };
            expect(animatedText.getTextAnchor()).toBe('end');
        });
        it('AnimatedText_getTextAnchor when the aligment is undefined', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = undefined;
            expect(animatedText.getTextAnchor()).toBe('middle');
            animatedText.visualConfiguration = {
                align: 'center'
            };
            expect(animatedText.getTextAnchor()).toBe('middle');
        });
        it('AnimatedText_getTranslateX alignment is "left"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'left'
            };
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(0);
        });
        it('AnimatedText_getTranslateX alignment is "right"', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = {
                align: 'right'
            };
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(100);
        });
        it('AnimatedText_getTranslateX when alignment is undefined, returns the center', function () {
            var animatedText = new AnimatedText('animatedText');
            animatedText.visualConfiguration = undefined;
            expect(animatedText.getTranslateX(0)).toBe(0);
            expect(animatedText.getTranslateX(100)).toBe(50);
        });
    });
    describe("AnimatedText DOM tests", function () {
        var v, element;
        var animationOptions = {
            transitionImmediate: true
        };
        beforeEach(function (done) {
            element = powerbitests.helpers.testDom('200', '300');
            v = new AnimatedText('animatedText');
            v.currentViewport = {
                height: element.height(),
                width: element.width()
            };
            v.hostServices = powerbitests.mocks.createVisualHostServices();
            v.svg = d3.select(element.get(0)).append('svg');
            v.style = powerbi.visuals.visualStyles.create();
            done();
        });
        it('AnimatedText_getAdjustedFontHeight when seed font width is bigger than the width', function () {
            // parameters are availableWidth, textToMeasure, seedFontHeight
            // When the measured text with the seed height is bigger than availableWidth, decrease the font height
            expect(v.getAdjustedFontHeight(4, "text", 10)).toBeLessThan(10);
        });
        it('AnimatedText_getAdjustedFontHeight when seed font width is smaller or equal to the width', function () {
            // parameters are availableWidth, textToMeasure, seedFontHeight
            // When the measured text with the seed height is equal/smaller than availableWidth, return the font height
            expect(v.getAdjustedFontHeight(30, "text", 3)).toBe(3);
        });
        it('AnimatedText doValueTransition sets text', function (done) {
            v.doValueTransition(3, 4, null, animationOptions, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('4');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('AnimatedText doValueTransition formats number > 10000', function (done) {
            v.doValueTransition(3, 4534353, null, animationOptions, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('4.53M');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('AnimatedText doValueTransition sets translateY correctly', function (done) {
            v.doValueTransition(3, 4, null, animationOptions, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                // IE and Chrome represent the transform differently
                expect($(".mainText").attr('transform')).toMatch(/translate\(\d+(,| )130\)/);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('AnimatedText doValueTransition to 0', function (done) {
            v.doValueTransition(null, 0, null, animationOptions, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('AnimatedText doValueTransition to null', function (done) {
            v.doValueTransition(null, null, null, animationOptions, 0, false);
            expect($('.animatedText')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('(Blank)');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var Card = powerbi.visuals.Card;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ValueType = powerbi.ValueType;
    var SVGUtil = powerbi.visuals.SVGUtil;
    describe("Card", function () {
        it('Card_registered_capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('card').capabilities).toBe(Card.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(Card.capabilities.dataViewMappings).toBeDefined();
            expect(Card.capabilities.dataViewMappings.length).toBe(1);
        });
        it('Capabilities should have condition', function () {
            expect(Card.capabilities.dataViewMappings[0].conditions[0][Card.capabilities.dataRoles[0].name].max).toBe(1);
        });
        it('Capabilities should include dataRoles', function () {
            expect(Card.capabilities.dataRoles).toBeDefined();
            expect(Card.capabilities.dataRoles.length).toBe(1);
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(Card.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Card.capabilities.objects)).toEqual(Card.formatStringProp);
        });
        it('cardChart preferred capabilities requires at most 1 row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true }]
            };
            var dataViewWithTwoRows = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b')]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200],
                            subtotal: 300
                        }])
                }
            };
            var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('card');
            expect(powerbi.DataViewAnalysis.supports(dataViewWithTwoRows, plugin.capabilities.dataViewMappings[0], true)).toBe(false);
        });
        it('cardChart preferred capabilities requires 1 row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'numeric', type: ValueType.fromDescriptor({ numeric: true }) }
                ],
            };
            var data = {
                metadata: dataViewMetadata,
                single: { value: 123.456 }
            };
            var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('card');
            expect(powerbi.DataViewAnalysis.supports(data, plugin.capabilities.dataViewMappings[0], true)).toBe(true);
        });
    });
    describe("Card DOM tests", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [{ displayName: 'col1', isMeasure: true, objects: { 'general': { formatString: '#0' } } }],
            groups: [],
            measures: [0],
        };
        var cardStyles = Card.DefaultStyle.card;
        beforeEach(function () {
            createCard();
        });
        function createCard(displayUnitSystemType) {
            element = powerbitests.helpers.testDom('200', '300');
            v = new Card({ displayUnitSystemType: displayUnitSystemType });
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
        }
        it('Card_getAdjustedFontHeight with seed font size fitting in available width but equal/larger than MaxFontSize', function () {
            v.currentViewport = {
                height: 500,
                width: 500
            };
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize)).toBe(cardStyles.maxFontSize);
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize + 5)).toBe(cardStyles.maxFontSize);
        });
        it('Card_getAdjustedFontHeight with seed font size not fitting in available width and smaller than MaxFontSize', function () {
            v.currentViewport = {
                height: 30,
                width: 30
            };
            expect(v.getAdjustedFontHeight(v.currentViewport.width, "t", cardStyles.maxFontSize)).toBeLessThan(cardStyles.maxFontSize);
        });
        it('Card_onDataChanged (single value)', function () {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: '7191394482447.7'
                        }
                    }]
            });
            v.onResizing({
                height: element.height(),
                width: element.width()
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            var titleText = $('.card').find('title').text();
            expect(titleText).toBe('7191394482447.7');
        });
        it('Card_onDataChanged (0)', function () {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 0
                        }
                    }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            var titleText = $('.card').find('title').text();
            expect(titleText).toBe('0');
        });
        it('Card with null dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 0
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.mainText').first().text()).toBe('0');
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            single: {
                                value: null
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.mainText').first().text()).toBe('(Blank)');
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card updated with undefined dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 0
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.mainText').first().text()).toBe('0');
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            single: {
                                value: undefined
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.mainText').first().text()).toBe('');
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card_onDataChanged formats number < 10000', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 85.23498239847123
                        }
                    }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            SVGUtil.flushAllD3Transitions();
            setTimeout(function () {
                expect($('.mainText').text()).toEqual('85');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card_onDataChanged verbose display units (explore mode)', function (done) {
            createCard(powerbi.DisplayUnitSystemType.Verbose);
            var spy = spyOn(powerbi.visuals.valueFormatter, 'create');
            spy.and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 900000
                        }
                    }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect(spy.calls.count()).toBe(1);
                var args = spy.calls.argsFor(0);
                expect(args).toBeDefined();
                expect(args[0].displayUnitSystemType).toBe(powerbi.DisplayUnitSystemType.Verbose);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card_onDataChanged whole display units (dashboard tile mode, default)', function (done) {
            var spy = spyOn(powerbi.visuals.valueFormatter, 'create');
            spy.and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 900000
                        }
                    }]
            });
            expect($('.card')).toBeInDOM();
            expect($('.mainText')).toBeInDOM();
            setTimeout(function () {
                expect(spy.calls.count()).toBe(1);
                var args = spy.calls.argsFor(0);
                expect(args).toBeDefined();
                expect(args[0].displayUnitSystemType).toBe(powerbi.DisplayUnitSystemType.WholeUnits);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card with DateTime value on dashboard', function (done) {
            var dateValue = new Date(2015, 5, 20);
            var dataViewMetadata = {
                columns: [
                    { displayName: 'date', type: powerbi.ValueType.fromDescriptor({ dateTime: true }), isMeasure: true }
                ],
            };
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: dateValue
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.mainText').first().text()).toBe('6/20/2015');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card text alignment', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 900000
                        }
                    }]
            });
            var smallTileViewport = {
                height: 170,
                width: 250
            };
            v.onResizing(smallTileViewport);
            setTimeout(function () {
                var transform = SVGUtil.parseTranslateTransform($('.mainText').first().attr('transform'));
                expect(transform.x).toBe('125');
                expect($('.mainText').first().attr('text-anchor')).toBe('middle');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Card tests on Minerva", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [{ displayName: 'col1', isMeasure: true, format: '#0' }],
            groups: [],
            measures: [0],
        };
        var labelStyles = Card.DefaultStyle.label;
        var valueStyles = Card.DefaultStyle.value;
        beforeEach(function () {
            createCardOnMinerva();
        });
        function createCardOnMinerva(displayUnitSystemType) {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('card').create();
            var settings;
            if (displayUnitSystemType) {
                settings = {
                    DisplayUnitSystemType: displayUnitSystemType
                };
            }
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: settings,
            });
        }
        it('Card on Canvas DOM validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 90
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.card')).toBeInDOM();
                expect($('.label')).toBeInDOM();
                expect($('.value')).toBeInDOM();
                expect($('.label').length).toBe(1);
                expect($('.value').length).toBe(1);
                expect($('.label').first().text()).toBe('col1');
                expect($('.value').first().text()).toBe('90');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card on Canvas Style validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 900000
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.label')).toBeInDOM();
                expect($('.value')).toBeInDOM();
                expect(parseInt($('.label')[0].style.fontSize, 10)).toBe(labelStyles.fontSize);
                expect(parseInt($('.value')[0].style.fontSize, 10)).toBe(valueStyles.fontSize);
                expect($('.label')[0].style.fill).toBe(labelStyles.color);
                expect($('.value')[0].style.fill).toBe(valueStyles.color);
                expect($('.value')[0].style.fontFamily).toBe(valueStyles.fontFamily);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card with DateTime value on canvas', function (done) {
            var dateValue = new Date(2015, 5, 20);
            var dataViewMetadata = {
                columns: [
                    { displayName: 'date', type: powerbi.ValueType.fromDescriptor({ dateTime: true }), isMeasure: true }
                ],
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: dateValue
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.label').first().text()).toBe('date');
                expect($('.value').first().text()).toBe('6/20/2015');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card with zero currency value', function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'price', type: powerbi.ValueType.fromDescriptor({ numeric: true }), isMeasure: true, objects: { 'general': { formatString: '$0' } } }
                ],
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 0
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.label').first().text()).toBe('price');
                expect($('.value').first().text()).toBe('$0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card with null dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 900
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.value').first().text()).toBe('900');
                expect($('.label').first().text()).toBe('col1');
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            single: {
                                value: null
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.value').first().text()).toBe('(Blank)');
                    expect($('.label').first().text()).toBe('col1');
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Card updated with undefined dataview', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: 0
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.value').first().text()).toBe('0');
                expect($('.label').first().text()).toBe('col1');
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            single: {
                                value: undefined
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.value').first().text()).toBe('');
                    expect($('.label').first().text()).toBe('');
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('card with longer label and value', function (done) {
            var dataViewMetadata = {
                columns: [{ displayName: 'this is the value that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends', isMeasure: true, format: '#0' }],
                groups: [],
                measures: [0],
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        single: {
                            value: '99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
                        }
                    }]
            });
            setTimeout(function () {
                // Note: the exact text will be different depending on the environment in which the test is run, so we can't do an exact match.
                // Just check that the text is truncated with ellipses.
                var labelText = $('.label').first().text();
                var valueText = $('.value').first().text();
                expect(labelText.length).toBeLessThan(60);
                expect(valueText.length).toBeLessThan(30);
                expect(valueText.substr(valueText.length - 3)).toBe('...');
                expect(labelText.substr(labelText.length - 3)).toBe('...');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewSelfCrossJoin = powerbi.data.DataViewSelfCrossJoin;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ColumnChart = powerbi.visuals.ColumnChart;
    var ClusteredUtil = powerbi.visuals.ClusteredUtil;
    var StackedUtil = powerbi.visuals.StackedUtil;
    var ColumnUtil = powerbi.visuals.ColumnUtil;
    var AxisHelper = powerbi.visuals.AxisHelper;
    var ValueType = powerbi.ValueType;
    var SelectionId = powerbi.visuals.SelectionId;
    var PrimitiveType = powerbi.PrimitiveType;
    var Prototype = powerbi.Prototype;
    var CartesianChart = powerbi.visuals.CartesianChart;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var AxisType = powerbi.axisType;
    var ColorUtilityConverter = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    var LegendIcon = powerbi.visuals.LegendIcon;
    var LegendPosition = powerbi.visuals.LegendPosition;
    var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
    var defaultInsideLabelColor = '#ffffff';
    powerbitests.mocks.setLocale();
    describe("ColumnChart", function () {
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } } };
        var measure2Column = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        var measure3Column = { displayName: 'profit', queryName: 'selectProfit', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        var nullMeasureColumn = { displayName: null, queryName: 'selectNull', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        var measureWithFormatString = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double), format: '$0' };
        var measureColumnDynamic1 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double), objects: { general: { formatString: '$0' } }, groupName: 'A' };
        var measureColumnDynamic2 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double), objects: { general: { formatString: '$0' } }, groupName: 'B' };
        var measureColumnDynamic1RefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
        it('ColumnChart registered capabilities', function () {
            expect(JSON.stringify(powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').capabilities)).toBe(JSON.stringify(powerbi.visuals.getColumnChartCapabilities()));
        });
        it('ColumnChart registered customizeQuery', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').customizeQuery).toBe(ColumnChart.customizeQuery);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.getColumnChartCapabilities().suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.getColumnChartCapabilities().objects)).toEqual(powerbi.visuals.columnChartProps.general.formatString);
        });
        it('CustomizeQuery scalar type, no scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: null
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery non-scalar type, scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery scalar type, scalar axis flag', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ sample: {} });
        });
        it('CustomizeQuery no category', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            ColumnChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('Sortable roles with scalar axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            expect(ColumnChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toBeNull();
        });
        it('Sortable roles with categorical axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Categorical',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            expect(ColumnChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toEqual(['Category', 'Y']);
        });
        function createCompiledDataViewMapping(categoryType, objects) {
            var categoryItems = [];
            if (categoryType)
                categoryItems.push({ type: categoryType });
            return {
                metadata: {
                    objects: objects
                },
                categorical: {
                    categories: {
                        for: {
                            in: { role: 'Category', items: categoryItems }
                        },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: { role: 'Series', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) }] },
                            select: [
                                { for: { in: { role: 'Y', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) }] } } }
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    }
                }
            };
        }
        it('has positive measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, 200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            expect(powerbi.visuals.valueFormatter.create).toHaveBeenCalledWith({ format: undefined, value: 2011, value2: 2012, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose });
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 200]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 200
            });
        });
        it('has positive measure (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, 200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 1,
                            position: 1,
                            valueAbsolute: 1,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 1,
                            originalPosition: 1,
                            originalValueAbsolute: 1,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 1,
                            position: 1,
                            valueAbsolute: 1,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 1,
                            originalPosition: 1,
                            originalValueAbsolute: 1,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('has positive measure - two series (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, 200],
                    },
                    {
                        source: measure2Column,
                        values: [60, 50],
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectTax", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectTax", categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 0.625,
                            position: 0.625,
                            valueAbsolute: 0.625,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 0.625,
                            originalPosition: 0.625,
                            originalValueAbsolute: 0.625,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: 0.8,
                            position: 0.8,
                            valueAbsolute: 0.8,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 0.8,
                            originalPosition: 0.8,
                            originalValueAbsolute: 0.8,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                },
                {
                    key: 'series1', index: 1, displayName: 'tax', identity: SelectionId.createWithMeasure("selectTax"), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 0.375,
                            position: 1,
                            valueAbsolute: 0.375,
                            valueOriginal: 60,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 0.375,
                            originalPosition: 1,
                            originalValueAbsolute: 0.375,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "60" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: 0.2,
                            position: 1,
                            valueAbsolute: 0.2,
                            valueOriginal: 50,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 0.2,
                            originalPosition: 1,
                            originalValueAbsolute: 0.2,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "50" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('has negative measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, -200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: -200,
                            position: 0,
                            valueAbsolute: 200,
                            valueOriginal: -200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: -200,
                            originalPosition: 0,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }]
                }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-200, 100]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -200,
                max: 100
            });
        });
        it('has positive and negative measure - two series', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [2, -2],
                    },
                    {
                        source: measure2Column,
                        values: [-3, 4],
                    },
                    {
                        source: measure3Column,
                        values: [4, -3],
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            expect(data.series[2].data[0].position).toEqual(6);
            expect(data.series[2].data[1].position).toEqual(-2);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-3, 4]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -5,
                max: 6
            });
        });
        it('has negative measure (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, -200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 1,
                            position: 1,
                            valueAbsolute: 1,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 1,
                            originalPosition: 1,
                            originalValueAbsolute: 1,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: -1,
                            position: 0,
                            valueAbsolute: 1,
                            valueOriginal: -200,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: -1,
                            originalPosition: 0,
                            originalValueAbsolute: 1,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('is missing a measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, null]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: null,
                            position: 0,
                            valueAbsolute: 0,
                            valueOriginal: null,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: null,
                            originalPosition: 0,
                            originalValueAbsolute: 0,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 100]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
        });
        it('is missing a category', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity(null),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, null],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, 175]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: null,
                            value: 175,
                            position: 175,
                            valueAbsolute: 175,
                            valueOriginal: 175,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 175,
                            originalPosition: 175,
                            originalValueAbsolute: 175,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "(Blank)" }, { displayName: "sales", value: "$175" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 175]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 175
            });
        });
        it('multiple measures', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [100, 200]
                    }, {
                        source: measure2Column,
                        values: [62, 55]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorByIndex(0).value;
            var series2Color = colors.getColorByIndex(1).value;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectTax", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectTax", categoryColumn.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                },
                {
                    key: 'series1', index: 1, displayName: 'tax', identity: SelectionId.createWithMeasure("selectTax"), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 62,
                            position: 162,
                            valueAbsolute: 62,
                            valueOriginal: 62,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 62,
                            originalPosition: 162,
                            originalValueAbsolute: 62,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "62" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 55,
                            position: 255,
                            valueAbsolute: 55,
                            valueOriginal: 55,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 55,
                            originalPosition: 255,
                            originalValueAbsolute: 55,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "55" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(AxisHelper.createValueDomain(data.series, true)).toEqual([0, 200]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 255
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: series1Color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
                { icon: LegendIcon.Box, color: series2Color, label: measure2Column.displayName, identity: SelectionId.createWithMeasure("selectTax"), selected: false }
            ]);
        });
        it('converter: dynamic series', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    }, {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }], [measureColumnDynamic1RefExpr], measureColumn)
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesColumnId = SQExprShortSerializer.serializeArray([measureColumnDynamic1RefExpr]);
            var series1Color = colors.getColorScaleByKey(seriesColumnId).getColor('A').value;
            var series2Color = colors.getColorScaleByKey(seriesColumnId).getColor('B').value;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[0] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[0] }, measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[1] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[1] }, measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'A', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'B', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 62,
                            position: 162,
                            valueAbsolute: 62,
                            valueOriginal: 62,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 62,
                            originalPosition: 162,
                            originalValueAbsolute: 62,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 55,
                            position: 255,
                            valueAbsolute: 55,
                            valueOriginal: 55,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 55,
                            originalPosition: 255,
                            originalValueAbsolute: 55,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: series1Color, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: LegendIcon.Box, color: series2Color, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series falsy group instances', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, null),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, false),
            ];
            var measureColumnSources = [
                Prototype.inherit(measureColumnDynamic1, function (c) { return c.groupName = null; }),
                Prototype.inherit(measureColumnDynamic2, function (c) { return c.groupName = false; }),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnSources[0],
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    }, {
                        source: measureColumnSources[1],
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }], [measureColumnDynamic1RefExpr], measureColumn)
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var legendItems = data.legendData.dataPoints;
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: '(Blank)', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnSources[0].queryName), selected: false },
                { icon: LegendIcon.Box, color: legendItems[1].color, label: 'False', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnSources[1].queryName), selected: false }
            ]);
        });
        it('converter: dynamic series + fill color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    }, {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }], [measureColumnDynamic1RefExpr], measureColumn)
            };
            var groupedValues = dataView.values.grouped();
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[0] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[0] }, measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[1] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[1] }, measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'A', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'B', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 62,
                            position: 162,
                            valueAbsolute: 62,
                            valueOriginal: 62,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 62,
                            originalPosition: 162,
                            originalValueAbsolute: 62,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 55,
                            position: 255,
                            valueAbsolute: 55,
                            valueOriginal: 55,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 55,
                            originalPosition: 255,
                            originalValueAbsolute: 55,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(data.legendData.title).toEqual("sales");
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: '#01B8AA', label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: LegendIcon.Box, color: 'red', label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series, default color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var hexDefaultColorRed = "#FF0000";
            var metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    }, {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }], [measureColumnDynamic1RefExpr], measureColumn)
            };
            var groupedValues = dataView.values.grouped();
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, null, null, null, metadata);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[0] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[0] }, measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[1] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[1] }, measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'A', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'B', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 62,
                            position: 162,
                            valueAbsolute: 62,
                            valueOriginal: 62,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 62,
                            originalPosition: 162,
                            originalValueAbsolute: 62,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 55,
                            position: 255,
                            valueAbsolute: 55,
                            valueOriginal: 55,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 55,
                            originalPosition: 255,
                            originalValueAbsolute: 55,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: hexDefaultColorRed, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: LegendIcon.Box, color: hexDefaultColorRed, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('converter: dynamic series, formatted color + default color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(measureColumnDynamic1RefExpr, "B"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumnDynamic1,
                        values: [100, 200],
                        identity: seriesIdentities[0],
                    }, {
                        source: measureColumnDynamic2,
                        values: [62, 55],
                        identity: seriesIdentities[1],
                    }], [measureColumnDynamic1RefExpr], measureColumn)
            };
            var groupedValues = dataView.values.grouped();
            var hexGreen = "#00FF00";
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: hexGreen } } } };
            dataView.values.grouped = function () { return groupedValues; };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            var metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var data = ColumnChart.converter(dataView, colors, undefined, undefined, undefined, metadata);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[0] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[0] }, measureColumnDynamic2.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[0] }, { queryName: measureColumnDynamic1.queryName, data: seriesIdentities[1] }, measureColumnDynamic1.queryName),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: categoryColumn.queryName, data: categoryIdentities[1] }, { queryName: measureColumnDynamic2.queryName, data: seriesIdentities[1] }, measureColumnDynamic2.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'A', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: hexDefaultColorRed,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "A" }, { displayName: "sales", value: "$200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'B', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2011,
                            value: 62,
                            position: 162,
                            valueAbsolute: 62,
                            valueOriginal: 62,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: hexGreen,
                            selected: false,
                            originalValue: 62,
                            originalPosition: 162,
                            originalValueAbsolute: 62,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$62" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: 55,
                            position: 255,
                            valueAbsolute: 55,
                            valueOriginal: 55,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: hexGreen,
                            selected: false,
                            originalValue: 55,
                            originalPosition: 255,
                            originalValueAbsolute: 55,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "B" }, { displayName: "sales", value: "$55" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: hexDefaultColorRed, label: measureColumnDynamic1.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], measureColumnDynamic1.queryName), selected: false },
                { icon: LegendIcon.Box, color: hexGreen, label: measureColumnDynamic2.groupName, identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], measureColumnDynamic2.queryName), selected: false }
            ]);
        });
        it('validate highlighted tooltip', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
                powerbitests.mocks.dataViewScopeIdentity("2013"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012, 2013],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, 200, 300],
                        highlights: [null, 50, 0],
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            //first tooltip is regular because highlighted value is null
            expect(data.series[0].data[0].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }]);
            expect(data.series[0].data[1].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }]);
            //tooltips with highlighted value
            expect(data.series[0].data[2].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$50" }]);
            expect(data.series[0].data[3].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$50" }]);
            //tooltips with highlighted value 0
            expect(data.series[0].data[4].tooltipInfo).toEqual([{ displayName: "year", value: "2013" }, { displayName: "sales", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$0" }]);
            expect(data.series[0].data[5].tooltipInfo).toEqual([{ displayName: "year", value: "2013" }, { displayName: "sales", value: "$300" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "$0" }]);
        });
        it('null measures legend', function () {
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012]
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: nullMeasureColumn,
                        values: [100, 200]
                    }, {
                        source: measure2Column,
                        values: [62, 55]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var legendItems = data.legendData.dataPoints;
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: powerbi.visuals.valueFormatter.format(null), identity: SelectionId.createWithMeasure(nullMeasureColumn.queryName), selected: false },
                { icon: LegendIcon.Box, color: legendItems[1].color, label: dataView.values[1].source.displayName, identity: SelectionId.createWithMeasure(measure2Column.queryName), selected: false },
            ]);
        });
        it('multiple measures (100%)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2010"),
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
                powerbitests.mocks.dataViewScopeIdentity("2013"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2010, 2011, 2012, 2013],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [30, -20, 100, -300]
                    }, {
                        source: measure2Column,
                        values: [90, 50, -100, -100]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors, true);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[2], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[3], "selectSales", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectTax", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectTax", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[2], "selectTax", categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[3], "selectTax", categoryColumn.queryName),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2010,
                            value: 0.25,
                            position: 0.25,
                            valueAbsolute: 0.25,
                            valueOriginal: 30,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 0.25,
                            originalPosition: 0.25,
                            originalValueAbsolute: 0.25,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2010" }, { displayName: "sales", value: "$30" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2011,
                            value: -0.2857142857142857,
                            position: 0,
                            valueAbsolute: 0.2857142857142857,
                            valueOriginal: -20,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: -0.2857142857142857,
                            originalPosition: 0,
                            originalValueAbsolute: 0.2857142857142857,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "-$20" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: 0.5,
                            position: 0.5,
                            valueAbsolute: 0.5,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 2,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 0.5,
                            originalPosition: 0.5,
                            originalValueAbsolute: 0.5,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2013,
                            value: -0.75,
                            position: 0,
                            valueAbsolute: 0.75,
                            valueOriginal: -300,
                            seriesIndex: 0,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 3,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: -0.75,
                            originalPosition: 0,
                            originalValueAbsolute: 0.75,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2013" }, { displayName: "sales", value: "-$300" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'tax', identity: SelectionId.createWithMeasure("selectTax"), color: legendItems[1].color, data: [
                        {
                            categoryValue: 2010,
                            value: 0.75,
                            position: 1,
                            valueAbsolute: 0.75,
                            valueOriginal: 90,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 0.75,
                            originalPosition: 1,
                            originalValueAbsolute: 0.75,
                            identity: selectionIds[4],
                            key: selectionIds[4].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2010" }, { displayName: "tax", value: "90" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2011,
                            value: 0.7142857142857143,
                            position: 0.7142857142857143,
                            valueAbsolute: 0.7142857142857143,
                            valueOriginal: 50,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 0.7142857142857143,
                            originalPosition: 0.7142857142857143,
                            originalValueAbsolute: 0.7142857142857143,
                            identity: selectionIds[5],
                            key: selectionIds[5].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "tax", value: "50" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2012,
                            value: -0.5,
                            position: 0,
                            valueAbsolute: 0.5,
                            valueOriginal: -100,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 2,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: -0.5,
                            originalPosition: 0,
                            originalValueAbsolute: 0.5,
                            identity: selectionIds[6],
                            key: selectionIds[6].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "tax", value: "-100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 2013,
                            value: -0.25,
                            position: -0.75,
                            valueAbsolute: 0.25,
                            valueOriginal: -100,
                            seriesIndex: 1,
                            labelFill: data.labelSettings.labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 3,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: -0.25,
                            originalPosition: -0.75,
                            originalValueAbsolute: 0.25,
                            identity: selectionIds[7],
                            key: selectionIds[7].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2013" }, { displayName: "tax", value: "-100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('no category single measure', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionId = SelectionId.createWithMeasure(measureColumn.queryName);
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: null,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionId,
                            key: selectionId.getKey(),
                            tooltipInfo: [{ displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('no category multiple measure', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColumn,
                        values: [100]
                    }, {
                        source: measure2Column,
                        values: [200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("selectSales"),
                SelectionId.createWithMeasure("selectTax"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: null,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'tax', identity: SelectionId.createWithMeasure("selectTax"), color: legendItems[1].color, data: [
                        {
                            categoryValue: null,
                            value: 200,
                            position: 300,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 300,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "tax", value: "200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 300
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
                { icon: LegendIcon.Box, color: legendItems[1].color, label: measure2Column.displayName, identity: SelectionId.createWithMeasure("selectTax"), selected: false }
            ]);
        });
        it('no category multiple measure with format string', function () {
            var measureColum1WithFormat = powerbi.Prototype.inherit(measureColumn);
            var measureColum2WithFormat = powerbi.Prototype.inherit(measure2Column);
            measureColum1WithFormat.format = '$0';
            measureColum2WithFormat.format = '#,0';
            var dataView = {
                values: DataViewTransform.createValueColumns([
                    {
                        source: measureColum1WithFormat,
                        values: [100]
                    }, {
                        source: measureColum2WithFormat,
                        values: [200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("selectSales"),
                SelectionId.createWithMeasure("selectTax"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: null,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: '$0',
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'tax', identity: SelectionId.createWithMeasure("selectTax"), color: legendItems[1].color, data: [
                        {
                            categoryValue: null,
                            value: 200,
                            position: 300,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: '#,0',
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 300,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "tax", value: "200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 300
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
                { icon: LegendIcon.Box, color: legendItems[1].color, label: measure2Column.displayName, identity: SelectionId.createWithMeasure("selectTax"), selected: false }
            ]);
        });
        it('no category multiple measure + fill color', function () {
            var dataView = {
                values: DataViewTransform.createValueColumns([
                    {
                        source: {
                            displayName: 'sales',
                            queryName: 'selectSales',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer),
                            objects: {
                                general: { formatString: '$0' },
                                dataPoint: { fill: { solid: { color: 'red' } } }
                            },
                        },
                        values: [100],
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("selectSales"),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: 'red', data: [
                        {
                            categoryValue: null,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: 'red',
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: 'red', label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false },
            ]);
        });
        it('category and measure + fill color', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var dataView = {
                categories: [{
                        source: {
                            displayName: 'prod',
                            queryName: 'selectProd',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer),
                        },
                        values: ['a', 'b'],
                        objects: [undefined, { dataPoint: { fill: { solid: { color: 'red' } } } }],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: {
                            displayName: 'sales',
                            queryName: 'selectSales',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer),
                        },
                        values: [100, 150],
                    }])
            };
            var data = ColumnChart.converter(dataView, powerbi.visuals.visualStyles.create().colorPalette.dataColors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], "selectSales", 'selectProd'),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], "selectSales", 'selectProd'),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'sales', identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 'a',
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: '#01B8AA',
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "prod", value: "a" }, { displayName: "sales", value: "100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 'b',
                            value: 150,
                            position: 150,
                            valueAbsolute: 150,
                            valueOriginal: 150,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: 'red',
                            selected: false,
                            originalValue: 150,
                            originalPosition: 150,
                            originalValueAbsolute: 150,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "prod", value: "b" }, { displayName: "sales", value: "150" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(legendItems).toEqual([
                { icon: 0, color: '#01B8AA', label: 'sales', identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('Gradient measure: should not become a series', function () {
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity("2011"),
                            powerbitests.mocks.dataViewScopeIdentity("2012"),
                        ],
                    }],
                values: DataViewTransform.createValueColumns([
                    {
                        source: Prototype.inherit(measureColumn, function (c) { return c.roles = { 'Y': true }; }),
                        values: [100, 200],
                    }, {
                        source: Prototype.inherit(measure2Column, function (c) { return c.roles = { 'Gradient': true }; }),
                        values: [75, 50],
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            expect(data.legendData.dataPoints.length).toBe(1);
            expect(data.series.length).toBe(1);
            expect(data.series[0].data.length).toBe(2);
            expect(data.series[0].data.map(pruneColunnChartDataPoint)).toEqual([
                {
                    categoryValue: 2011,
                    value: 100,
                }, {
                    categoryValue: 2012,
                    value: 200,
                }
            ]);
        });
        it('single measure with infinite value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, Number.POSITIVE_INFINITY]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: Number.MAX_VALUE,
                            position: Number.MAX_VALUE,
                            valueAbsolute: Number.MAX_VALUE,
                            valueOriginal: Number.MAX_VALUE,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: Number.MAX_VALUE,
                            originalPosition: Number.MAX_VALUE,
                            originalValueAbsolute: Number.MAX_VALUE,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "$179769313486231600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: Number.MAX_VALUE
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('single measure with negative infinite value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, Number.NEGATIVE_INFINITY]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: -Number.MAX_VALUE,
                            position: 0,
                            valueAbsolute: Number.MAX_VALUE,
                            valueOriginal: -Number.MAX_VALUE,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: -Number.MAX_VALUE,
                            originalPosition: 0,
                            originalValueAbsolute: Number.MAX_VALUE,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }, { displayName: "sales", value: "-$179769313486231600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: -Number.MAX_VALUE,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('single measure with NaN value', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureColumn,
                        values: [100, Number.NaN]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(1);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color, data: [
                        {
                            categoryValue: 2011,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2011" }, { displayName: "sales", value: "$100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        },
                        {
                            categoryValue: 2012,
                            value: null,
                            position: 0,
                            valueAbsolute: 0,
                            valueOriginal: null,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: null,
                            originalPosition: 0,
                            originalValueAbsolute: 0,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "year", value: "2012" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
                min: 0,
                max: 100
            });
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: measureColumn.displayName, identity: SelectionId.createWithMeasure("selectSales"), selected: false }
            ]);
        });
        it('Tooltip info formatString with measure that has no object', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var dataView = {
                categories: [{
                        source: categoryColumn,
                        values: [2011, 2012],
                        identity: categoryIdentities,
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: measureWithFormatString,
                        values: [100, 200]
                    }])
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            // We should not summarize the X-axis values with DisplayUnits per-PowerView behavior, so ensure that we are using the 'Verbose' mode for the formatter.
            spyOn(powerbi.visuals.valueFormatter, 'create').and.callThrough();
            var data = ColumnChart.converter(dataView, colors);
            expect(data.series[0].data[0].tooltipInfo).toEqual([{ displayName: "year", value: "2011" }, { displayName: "tax", value: "$100" }]);
            expect(data.series[0].data[1].tooltipInfo).toEqual([{ displayName: "year", value: "2012" }, { displayName: "tax", value: "$200" }]);
        });
        it('dataView that should pivot categories', function () {
            var metadata = {
                columns: [
                    { displayName: '', index: 0 },
                    { displayName: '', isMeasure: true, index: 1 },
                ]
            };
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var categoryColRefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'category' });
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b'],
                            identity: seriesIdentities,
                            identityFields: [categoryColRefExpr],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200]
                        }])
                }
            };
            dataView = DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: powerbi.visuals.plugins.columnChart.capabilities.objects,
                dataViewMappings: powerbi.visuals.plugins.columnChart.capabilities.dataViewMappings,
                transforms: {
                    selects: [
                        { displayName: 'col1', queryName: 'select1', roles: { 'Series': true } },
                        { displayName: 'col2', queryName: 'select2', roles: { 'Y': true } },
                    ]
                },
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
            })[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var data = ColumnChart.converter(dataView.categorical, colors);
            var selectionIds = [
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: 'select1', data: seriesIdentities[0] }, null, 'select2'),
                SelectionId.createWithIdsAndMeasureAndCategory({ queryName: 'select1', data: seriesIdentities[1] }, null, 'select2'),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(data.series).toEqual([{
                    key: 'series0', index: 0, displayName: 'a', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], 'select2'), color: legendItems[0].color, data: [
                        {
                            categoryValue: null,
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[0].color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'b', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], 'select2'), color: legendItems[1].color, data: [
                        {
                            categoryValue: null,
                            value: 200,
                            position: 300,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: legendItems[1].color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 300,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "200" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }]);
            expect(legendItems).toEqual([
                { icon: LegendIcon.Box, color: legendItems[0].color, label: 'a', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[0], 'select2'), selected: false },
                { icon: LegendIcon.Box, color: legendItems[1].color, label: 'b', identity: SelectionId.createWithIdAndMeasure(seriesIdentities[1], 'select2'), selected: false }
            ]);
        });
        it('dataView with Series & Category role that should pivot categories', function () {
            var metadata = {
                columns: [
                    { displayName: 'col1', queryName: 'selectCol1', roles: { "Series": true, "Category": true } },
                    { displayName: 'col2', queryName: 'selectCol2', properties: { "Y": true } },
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var categoryColRefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var dataView = DataViewSelfCrossJoin.apply({
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b'],
                            identity: categoryIdentities,
                            identityFields: [categoryColRefExpr],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200],
                        }])
                }
            });
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(categoryColRefExpr)).getColor('a').value;
            var series2Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(categoryColRefExpr)).getColor('b').value;
            var data = ColumnChart.converter(dataView.categorical, colors, undefined, undefined, undefined, metadata);
            var selectionIds = [
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], 'selectCol2', 'selectCol1'),
                SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], 'selectCol2', 'selectCol1'),
            ];
            var legendItems = data.legendData.dataPoints;
            expect(legendItems.length).toBe(2);
            expect(legendItems.map(function (l) { return l.label; })).toEqual(['a', 'b']);
            // Should get a result shaped like a diagonal matrix
            var item = [{
                    key: 'series0', index: 0, displayName: 'a', identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'selectCol2'), color: legendItems[0].color, data: [
                        {
                            categoryValue: 'a',
                            value: 100,
                            position: 100,
                            valueAbsolute: 100,
                            valueOriginal: 100,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 0,
                            color: series1Color,
                            selected: false,
                            originalValue: 100,
                            originalPosition: 100,
                            originalValueAbsolute: 100,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }, {
                            categoryValue: 'b',
                            value: null,
                            position: 0,
                            valueAbsolute: 0,
                            valueOriginal: null,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: '#01B8AA',
                            selected: false,
                            originalValue: null,
                            originalPosition: 0,
                            originalValueAbsolute: 0,
                            identity: jasmine.any(Object),
                            key: jasmine.any(String),
                            tooltipInfo: [{ displayName: "col1", value: "b" }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }, {
                    key: 'series1', index: 1, displayName: 'b', identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'selectCol2'), color: legendItems[1].color, data: [
                        {
                            categoryValue: 'b',
                            value: 200,
                            position: 200,
                            valueAbsolute: 200,
                            valueOriginal: 200,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            categoryIndex: 1,
                            color: series2Color,
                            selected: false,
                            originalValue: 200,
                            originalPosition: 200,
                            originalValueAbsolute: 200,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: 'col2', value: '200' }],
                            lastSeries: undefined,
                            chartType: undefined
                        }
                    ]
                }];
            expect(data.series).toEqual(item);
        });
        it('100% stacked -- rounding (-1)', function () {
            var selectionIds = [
                SelectionId.createWithMeasure("measure0"),
                SelectionId.createWithMeasure("measure1"),
            ];
            var data = [{
                    key: '1', index: 0, displayName: 'measure0', identity: SelectionId.createNull(), color: 'red', data: [
                        {
                            categoryValue: 0,
                            value: -0.75,
                            position: 0,
                            valueAbsolute: 0.75,
                            valueOriginal: -0.75,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'red',
                            selected: false,
                            originalValue: -0.75,
                            originalPosition: 0,
                            originalValueAbsolute: 0.75,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedColumn
                        }
                    ]
                },
                {
                    key: '2', index: 1, displayName: 'measure1', identity: SelectionId.createNull(), color: 'blue', data: [
                        {
                            categoryValue: 0,
                            value: -0.25000001,
                            position: -0.75,
                            valueAbsolute: 0.25000001,
                            valueOriginal: -0.25000001,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'blue',
                            selected: false,
                            originalValue: -0.25000001,
                            originalPosition: -0.75,
                            originalValueAbsolute: 0.25000001,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedColumn
                        }
                    ]
                }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: -1,
                max: 0
            });
        });
        it('100% stacked -- rounding (+1)', function () {
            var selectionIds = [
                SelectionId.createWithMeasure("measure0"),
                SelectionId.createWithMeasure("measure1"),
            ];
            var data = [{
                    key: '1', index: 0, displayName: 'measure0', identity: SelectionId.createNull(), color: 'red', data: [
                        {
                            categoryValue: 0,
                            value: 0.25,
                            position: 0.25,
                            valueAbsolute: 0.25,
                            valueOriginal: 0.25,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'red',
                            selected: false,
                            originalValue: 0.25,
                            originalPosition: 0.25,
                            originalValueAbsolute: 0.25,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        }
                    ]
                },
                {
                    key: '2', index: 1, displayName: 'measure1', identity: SelectionId.createNull(), color: 'blue', data: [
                        {
                            categoryValue: 0,
                            value: 0.7500001,
                            position: 1.000001,
                            valueAbsolute: 0.75000001,
                            valueOriginal: 0.7500001,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'blue',
                            selected: false,
                            originalValue: 0.7500001,
                            originalPosition: 1.000001,
                            originalValueAbsolute: 0.75000001,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        }
                    ]
                }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: 0,
                max: 1
            });
        });
        it('100% stacked -- rounding (+1 and -1)', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "measure0"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], "measure1"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "measure0"),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], "measure1"),
            ];
            var data = [{
                    key: '1', index: 0, displayName: 'measure0', identity: SelectionId.createNull(), color: 'red', data: [
                        {
                            categoryValue: 0,
                            value: -0.75,
                            position: 0,
                            valueAbsolute: 0.75,
                            valueOriginal: -0.75,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            color: 'red',
                            selected: false,
                            originalValue: -0.75,
                            originalPosition: 0,
                            originalValueAbsolute: 0.75,
                            identity: selectionIds[0],
                            key: selectionIds[0].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        },
                        {
                            categoryValue: 1,
                            value: 0.25,
                            position: 0.25,
                            valueAbsolute: 0.25,
                            valueOriginal: 0.25,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            color: 'red',
                            selected: false,
                            originalValue: 0.25,
                            originalPosition: 0.25,
                            originalValueAbsolute: 0.25,
                            identity: selectionIds[1],
                            key: selectionIds[1].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        }
                    ]
                },
                {
                    key: '2', index: 1, displayName: 'measure1', identity: SelectionId.createNull(), color: 'blue', data: [
                        {
                            categoryValue: 0,
                            value: -0.25000001,
                            position: -0.75,
                            valueAbsolute: 0.25000001,
                            valueOriginal: -0.25000001,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'blue',
                            selected: false,
                            originalValue: -0.25000001,
                            originalPosition: -0.75,
                            originalValueAbsolute: 0.25000001,
                            identity: selectionIds[2],
                            key: selectionIds[2].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        },
                        {
                            categoryValue: 1,
                            value: 0.7500001,
                            position: 1.000001,
                            valueAbsolute: 0.75000001,
                            valueOriginal: 0.7500001,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            labelFill: labelColor,
                            labelFormatString: undefined,
                            color: 'blue',
                            selected: false,
                            originalValue: 0.7500001,
                            originalPosition: 1.000001,
                            originalValueAbsolute: 0.75000001,
                            identity: selectionIds[3],
                            key: selectionIds[3].getKey(),
                            chartType: powerbi.visuals.ColumnChartType.hundredPercentStackedBar
                        }
                    ]
                }];
            expect(StackedUtil.calcValueDomain(data, true)).toEqual({
                min: -1,
                max: 1
            });
        });
        it('createValueFormatter: value (hundreds)', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 200, value = 100;
            expect(ClusteredUtil.createValueFormatter(columns, max - min).format(value)).toBe('$100');
            expect(StackedUtil.createValueFormatter(columns, false, max - min).format(value)).toBe('$100');
        });
        it('createValueFormatter: value (millions)', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 2e6, value = 1e6;
            expect(ClusteredUtil.createValueFormatter(columns, max - min).format(value)).toBe('$1M');
            expect(StackedUtil.createValueFormatter(columns, false, max - min).format(value)).toBe('$1M');
        });
        it('createValueFormatter: 100% stacked', function () {
            var columns = [measureColumn, measure2Column];
            var min = 0, max = 1, value = .5;
            expect(StackedUtil.createValueFormatter(columns, true, max - min).format(value)).toBe('50%');
        });
        var categoricalData = {
            categories: [],
            categoryFormatter: null,
            series: [],
            valuesMetadata: [],
            legendData: { dataPoints: [] },
            hasSelection: false,
            hasHighlights: false,
            selectedIds: [],
            categoryMetadata: null,
            scalarCategoryAxis: false,
            labelSettings: null,
            axesLabels: { x: null, y: null },
            hasDynamicSeries: false,
        };
        var metadataColumnText = {
            displayName: 'NumberCol',
            type: ValueType.fromDescriptor({ text: true })
        };
        var scalarData = {
            categories: [1, 2, 3],
            categoryFormatter: null,
            series: [{ key: '1', index: 0, displayName: '1', identity: SelectionId.createNull(), data: [], color: '#01B8AA' }],
            valuesMetadata: [],
            legendData: { dataPoints: [] },
            hasSelection: false,
            hasHighlights: false,
            selectedIds: [],
            categoryMetadata: null,
            scalarCategoryAxis: true,
            labelSettings: null,
            axesLabels: { x: null, y: null },
            hasDynamicSeries: false,
        };
        var metadataColumnNumber = {
            displayName: 'NumberCol',
            type: ValueType.fromDescriptor({ numeric: true })
        };
        var metadataColumnTime = {
            displayName: 'DateCol',
            type: ValueType.fromDescriptor({ dateTime: true })
        };
        it('getLayout: no category metadata', function () {
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 114,
                categoryCount: 1,
                domain: []
            })).toEqual({
                categoryCount: 1,
                categoryThickness: 30,
                outerPaddingRatio: 1.4,
                isScalar: false
            });
        });
        it('getLayout: text (one)', function () {
            categoricalData.categories = ['A'];
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 114,
                categoryCount: 1,
                domain: []
            })).toEqual({
                categoryCount: 1,
                categoryThickness: 30,
                outerPaddingRatio: 1.4,
                isScalar: false
            });
        });
        it('getLayout: text (few)', function () {
            categoricalData.categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 204,
                categoryCount: 6,
                domain: []
            })).toEqual({
                categoryCount: 6,
                categoryThickness: 30,
                outerPaddingRatio: 0.4,
                isScalar: false
            });
        });
        it('getLayout: text (too many)', function () {
            var cats = [];
            for (var i = 0, len = 200; i < len; i++) {
                cats.push(Math.round(Math.random()).toString());
            }
            categoricalData.categories = cats;
            categoricalData.categoryMetadata = metadataColumnText;
            expect(CartesianChart.getLayout(categoricalData, {
                availableWidth: 220,
                categoryCount: 200,
                domain: []
            })).toEqual({
                categoryCount: 10,
                categoryThickness: 20,
                outerPaddingRatio: 0.5,
                isScalar: false
            });
        });
        it('getLayout: number (few)', function () {
            var series = [];
            for (var i = 0, len = 10; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    // use pow to create x values that get farther apart (testing minInterval)
                    categoryValue: i * 10 + Math.pow(i * 10, 1.8),
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: labelColor,
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnNumber;
            expect(CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 10,
                domain: [0, 6400],
                isScalar: true
            })).toEqual({
                categoryCount: 10,
                categoryThickness: 2,
                outerPaddingRatio: 0.4,
                isScalar: true
            });
        });
        it('getLayout: number (many)', function () {
            var series = [];
            for (var i = 0, len = 100; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    categoryValue: i + Math.pow(i, 1.8),
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: labelColor,
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnNumber;
            expect(CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 100,
                domain: [0, 4000],
                isScalar: true
            })).toEqual({
                categoryCount: 49,
                categoryThickness: 2,
                outerPaddingRatio: 0.4,
                isScalar: true
            });
        });
        it('getLayout: datetime', function () {
            var series = [];
            for (var i = 0, len = 25; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                var dataPoint = {
                    // use fractional pow to create x values that get closer together (testing minInterval)
                    categoryValue: new Date(2000, 1, 1).getTime() + Math.pow(i, 0.66) * 86000000,
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: labelColor,
                    categoryIndex: i,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnTime;
            var layout = CartesianChart.getLayout(scalarData, {
                availableWidth: 100,
                categoryCount: 25,
                domain: [series[0].categoryValue, series[series.length - 1].categoryValue],
                isScalar: true
            });
            expect(layout.categoryCount).toEqual(25);
            expect(layout.categoryThickness).toBeCloseTo(2.7, 1);
            expect(layout.isScalar).toBeTruthy();
        });
        it('getLayout: datetime with highlights', function () {
            var series = [];
            var idx = 0;
            for (var i = 0, len = 10; i < len; i++) {
                var identity = SelectionId.createWithId(powerbitests.mocks.dataViewScopeIdentity("" + i));
                idx = Math.floor(i / 2);
                var dataPoint = {
                    // use fractional pow to create x values that get closer together (testing minInterval)
                    categoryValue: new Date(2000, 1, 1).getTime() + Math.pow(idx, 0.66) * 86000000,
                    value: i % 5,
                    position: 0,
                    valueAbsolute: i % 5,
                    valueOriginal: i % 5,
                    seriesIndex: 0,
                    labelFill: labelColor,
                    categoryIndex: idx,
                    color: '#01B8AA',
                    selected: false,
                    originalValue: i % 5,
                    originalPosition: 0,
                    originalValueAbsolute: i % 5,
                    identity: identity,
                    key: identity.getKey(),
                    chartType: powerbi.visuals.ColumnChartType.stackedColumn
                };
                if (i % 2 !== 0) {
                    dataPoint.highlight = true;
                }
                series.push(dataPoint);
            }
            scalarData.series[0].data = series;
            scalarData.categoryMetadata = metadataColumnTime;
            var layout = CartesianChart.getLayout(scalarData, {
                availableWidth: 400,
                categoryCount: idx + 1,
                domain: [series[0].categoryValue, series[series.length - 1].categoryValue],
                isScalar: true
            });
            expect(layout.categoryCount).toEqual(idx + 1);
            expect(layout.categoryThickness).toBeCloseTo(61, 0);
            expect(layout.isScalar).toBeTruthy();
        });
        it('getForcedTickValues: 0 forced tick count', function () {
            var expected = [];
            var actual = ColumnChart.getForcedTickValues(0, 100, 0);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 min', function () {
            var expected = [0, 50, 100];
            var actual = ColumnChart.getForcedTickValues(0, 100, 3);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 max', function () {
            var expected = [-200, -150, -100, -50, 0];
            var actual = ColumnChart.getForcedTickValues(-200, 0, 5);
            expect(actual).toEqual(expected);
        });
        it('getForcedTickValues: 0 between min and max', function () {
            var expected = [-20, 40, 100, 0];
            var actual = ColumnChart.getForcedTickValues(-20, 100, 3);
            expect(actual).toEqual(expected);
        });
        it('getTickCount: 6 max tick count without forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measure2Column);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 6, false);
            expect(actual).toEqual(6);
        });
        it('getTickCount: 6 max tick count with 2 forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measureColumn);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 6, false, 2);
            expect(actual).toEqual(2);
        });
        it('getTickCount: 0 max tick count with 2 forced tick count', function () {
            var valuesMetadata = [];
            valuesMetadata.push(measureColumn);
            var actual = ColumnUtil.getTickCount(0, 3, valuesMetadata, 0, false, 2);
            expect(actual).toEqual(0);
        });
        it('getTickInterval: empty tick value', function () {
            var tickValues = [];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(0);
        });
        it('getTickInterval: single tick value', function () {
            var tickValues = [2.35];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(2.35);
        });
        it('getTickInterval: sorted tick values', function () {
            var tickValues = [48000, 48500, 49000, 49500, 50000];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(500);
        });
        it('getTickInterval: unsorted tick values', function () {
            var tickValues = [48500, 49000, 48000, 49500, 50000];
            var tickInterval = ColumnChart.getTickInterval(tickValues);
            expect(tickInterval).toBe(500);
        });
    });
    function clusterColumnChartDomValidation(interactiveChart, scalarSetting) {
        var v, element;
        var dataViewMetadataTwoColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            }, {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        var dataViewMetadataScalarDateTime = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        function metadata(columns) {
            var categoryAxisObject = scalarSetting
                ? { axisType: 'Scalar' }
                : { axisType: 'Categorical' };
            var metadata = {
                columns: columns,
                objects: { categoryAxis: categoryAxisObject }
            };
            return metadata;
        }
        function metadataWithDataLabels(columns) {
            var categoryAxisObject = scalarSetting
                ? { axisType: 'Scalar' }
                : { axisType: 'Categorical' };
            var metadata = {
                columns: columns,
                objects: {
                    categoryAxis: categoryAxisObject,
                    labels: { show: true }
                }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('clusteredColumnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('clustered column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [0, 234]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, null]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.data-labels').length).toBe(0);
                if (interactiveChart) {
                    expect(ColumnChart.getInteractiveLegendDomElement(element)).toBeDefined();
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart dom validation - datetime', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("1999/3/1"),
                powerbitests.mocks.dataViewScopeIdentity("1999/6/20"),
                powerbitests.mocks.dataViewScopeIdentity("2003/6/1"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataScalarDateTime),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataScalarDateTime[0],
                                    values: [new Date(1999, 3, 1), new Date(1999, 6, 20), new Date(2003, 6, 1)],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataScalarDateTime[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234, 32]
                                }, {
                                    source: dataViewMetadataScalarDateTime[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88, 44]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(6);
                if (scalarSetting) {
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(31, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(12, 0);
                }
                else {
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(179, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart dom validation - null datetime', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("1999/3/1"),
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity("2003/6/1"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataScalarDateTime),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataScalarDateTime[0],
                                    values: [new Date(1999, 3, 1), null, new Date(2003, 6, 1)],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataScalarDateTime[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234, 32]
                                }, {
                                    source: dataViewMetadataScalarDateTime[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88, 44]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                if (scalarSetting) {
                    expect($('.column').length).toBe(4);
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(363, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                else {
                    expect($('.column').length).toBe(6);
                    expect(+$('.column')[1].attributes.getNamedItem('x').value).toBeCloseTo(179, 0);
                    expect(+$('.column')[1].attributes.getNamedItem('width').value).toBeCloseTo(48, 0);
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadataWithDataLabels(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var bars = $('.column.highlight');
                var labels = $('.data-labels');
                var attrY1 = +$(bars[0]).attr('y');
                var attrY2 = +$(bars[1]).attr('y');
                var attrY3 = +$(bars[2]).attr('y');
                var attrY4 = +$(bars[3]).attr('y');
                //outside position
                expect(attrY1).toBeGreaterThan($(labels[0]).attr('y'));
                expect(attrY2).toBeGreaterThan($(labels[1]).attr('y'));
                expect(attrY3).toBeGreaterThan($(labels[2]).attr('y'));
                expect(attrY4).toBeGreaterThan($(labels[3]).attr('y'));
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [-123, -234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [-12, -88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toEqual(+$('.column')[0].attributes.getNamedItem('y').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart partial highlights with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [157, 260]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [18, 102]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('width').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart partial highlights with positive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('width').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart missing measure in first series to not be dropped in dom', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [null, 123]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 23]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, null]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    values: [0.0001, 234]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    values: [12, -0.0001]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var smallPositiveRectYValue = $('.column')[0].attributes.getNamedItem('y').value;
                var smallNegativeRectYValue = $('.column')[3].attributes.getNamedItem('y').value;
                expect(smallPositiveRectYValue).not.toEqual(smallNegativeRectYValue);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty clustered column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata(dataViewMetadataTwoColumn),
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered column chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        if (!interactiveChart) {
            it('legend formatting', function (done) {
                var categoryIdentities = [
                    powerbitests.mocks.dataViewScopeIdentity("abc"),
                    powerbitests.mocks.dataViewScopeIdentity("def"),
                ];
                var dataView = {
                    metadata: metadata(dataViewMetadataThreeColumn),
                    categorical: {
                        categories: [{
                                source: dataViewMetadataThreeColumn[0],
                                values: ['abc', 'def'],
                                identity: categoryIdentities,
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataThreeColumn[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            }, {
                                source: dataViewMetadataThreeColumn[2],
                                min: 12,
                                max: 88,
                                subtotal: 100,
                                values: [12, 88]
                            }])
                    }
                };
                dataView.metadata.objects = { legend: { show: true, position: 'Top' } };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.legend').attr('orientation')).toBe(LegendPosition.Top.toString());
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.legend').attr('orientation')).toBe(LegendPosition.Right.toString());
                        //set title
                        var testTitle = 'Test Title';
                        dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.legend').attr('orientation')).toBe(LegendPosition.Right.toString());
                            expect($('.legendTitle').text()).toBe(testTitle);
                            //hide legend
                            dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.legend').attr('orientation')).toBe(LegendPosition.None.toString());
                                done();
                            }, powerbitests.DefaultWaitForRender);
                        }, powerbitests.DefaultWaitForRender);
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
        }
    }
    describe("Clustered ColumnChart DOM validation", function () { return clusterColumnChartDomValidation(false, false); });
    describe("Clustered ColumnChart DOM validation - Scalar", function () { return clusterColumnChartDomValidation(false, true); });
    describe("Interactive Clustered ColumnChart DOM validation", function () { return clusterColumnChartDomValidation(true, false); });
    describe("Interactive Clustered ColumnChart DOM validation - Scalar", function () { return clusterColumnChartDomValidation(true, true); });
    function stackedColumnChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer)
                }, {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.data-labels').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('200K');
                if (interactiveChart)
                    expect($('.interactive-legend').length).toBe(1);
                else
                    expect($('.legend').attr('orientation')).toBe(LegendPosition.None.toString());
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('single measure column chart with too many values for view dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
                powerbitests.mocks.dataViewScopeIdentity("f"),
                powerbitests.mocks.dataViewScopeIdentity("g"),
                powerbitests.mocks.dataViewScopeIdentity("h"),
                powerbitests.mocks.dataViewScopeIdentity("i"),
                powerbitests.mocks.dataViewScopeIdentity("j"),
                powerbitests.mocks.dataViewScopeIdentity("k"),
                powerbitests.mocks.dataViewScopeIdentity("l"),
                powerbitests.mocks.dataViewScopeIdentity("m"),
                powerbitests.mocks.dataViewScopeIdentity("n"),
                powerbitests.mocks.dataViewScopeIdentity("o"),
                powerbitests.mocks.dataViewScopeIdentity("p"),
                powerbitests.mocks.dataViewScopeIdentity("q"),
                powerbitests.mocks.dataViewScopeIdentity("r"),
                powerbitests.mocks.dataViewScopeIdentity("s"),
                powerbitests.mocks.dataViewScopeIdentity("y"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 10,
                                    max: 30,
                                    subtotal: 420,
                                    values: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                // Data should be spliced down to a smaller set that will fit inside the view
                expect($('.column').length).toBe(13);
                // The max value in the view is ...
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('25');
                if (interactiveChart)
                    expect($('.interactive-legend').length).toBe(1);
                else
                    expect($('.legend').attr('orientation')).toBe(LegendPosition.None.toString());
                // now update with empty series values to test corner case where we slice the category data but have no series data
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                                        identity: categoryIdentities,
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('with partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsObject.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataWithLabelsObject.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataWithLabelsObject.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                expect($('.data-labels').length).toBe(4);
                expect($(labels[0]).css('fill-opacity')).toEqual('1');
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                expect($(labels[2]).css('fill-opacity')).toEqual('1');
                expect($(labels[3]).css('fill-opacity')).toEqual('1');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: -234,
                                    max: -123,
                                    subtotal: -357,
                                    values: [-123, -234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: -88,
                                    max: -12,
                                    subtotal: -100,
                                    values: [-12, -88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBe(+$('.column')[0].attributes.getNamedItem('y').value);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [154, 274]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [26, 166]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with partial highlight with postitive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                expect($(legendSelector).length).toBe(1);
                expect($(legendSelector + (interactiveChart ? ' .item' : 'Item')).length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, null]
                                }])
                        }
                    }]
            });
            v.onResizing({ height: 500, width: 500 });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.0001, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [12, -0.0001]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                var smallPositiveRectYValue = $('.column')[0].attributes.getNamedItem('y').value;
                var smallNegativeRectYValue = $('.column')[3].attributes.getNamedItem('y').value;
                expect(smallPositiveRectYValue).not.toEqual(smallNegativeRectYValue);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart optimal ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [1, 3]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('3');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty stacked column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked column chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Stacked ColumnChart DOM validation", function () { return stackedColumnChartDomValidation(false); });
    describe("Interactive Stacked ColumnChart DOM validation", function () { return stackedColumnChartDomValidation(true); });
    function hundredPercentStackedColumnChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('hundredPercentStackedColumnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000],
                                    highlights: [50000, 10000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.highlight').length).toBe(2);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.column')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeGreaterThan(+$('.column')[0].attributes.getNamedItem('y').value);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                expect($('.data-labels').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent column chart - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsObject.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsObject.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000],
                                    highlights: [50000, 10000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                expect(labels.length).toBe(1);
                //opacity of highlighted columns
                expect($(labels[0]).css('fill-opacity')).toEqual('1');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('multi measure hundred percent column chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty hundred percent column chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent column chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.column').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.column').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent column chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.column').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent column chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Hundred Percent Stacked ColumnChart DOM validation", function () { return hundredPercentStackedColumnChartDomValidation(false); });
    describe("Interactive Hundred Percent Stacked ColumnChart DOM validation", function () { return hundredPercentStackedColumnChartDomValidation(true); });
    function stackedBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }]
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }]
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure bar chart long labels dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends..."),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.data-labels').length).toBe(0);
                // Y-axis margin should be limited to a % of the chart area, and excess text should be replaced with an ellipsis.
                expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(135,8)');
                // Note: the exact text will be different depending on the environment in which the test is run, so we can't do an exact match.
                // Just check that the text is truncated with ellipses.
                var labelText = $('.columnChart .axisGraphicsContext .y.axis .tick').find('text').first().text();
                expect(labelText.length).toBeLessThan(30);
                expect(labelText.substr(labelText.length - 3)).toBe('...');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('single measure bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('200K');
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsObject.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataWithLabelsObject.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataWithLabelsObject.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var bars = $('.bar');
                var labels = $('.data-labels');
                var attrX1 = +$(bars[1]).attr('x');
                var attrX2 = +$(bars[3]).attr('x');
                var attrX3 = +$(bars[5]).attr('x');
                var attrX4 = +$(bars[7]).attr('x');
                var width1 = +$(bars[1]).attr('width');
                var width2 = +$(bars[3]).attr('width');
                var width3 = +$(bars[5]).attr('width');
                var width4 = +$(bars[7]).attr('width');
                //second series - data labels are ouside
                expect($(labels[2]).attr('x')).toBeGreaterThan(attrX3 + width3);
                expect($(labels[3]).attr('x')).toBeGreaterThan(attrX4 + width4);
                //first sereis -  data labels are inside
                expect($(labels[0]).attr('x')).toBeLessThan(attrX1 + width1);
                expect($(labels[0]).attr('x')).toBeGreaterThan(attrX1);
                expect($(labels[1]).attr('x')).toBeLessThan(attrX2 + width2);
                expect($(labels[1]).attr('x')).toBeGreaterThan(attrX2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: -234,
                                    max: -123,
                                    subtotal: -357,
                                    values: [-123, -234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: -88,
                                    max: -12,
                                    subtotal: -100,
                                    values: [-12, -88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [154, 264]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [16, 166]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart partial highlight with positive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('incremental render bar chart one to multiple series bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('200K');
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                // Legend should be empty, axis should be further up to take the extra space.
                if (!interactiveChart)
                    expect($('.legendItem')).not.toBeInDOM();
                // Note: depending on where the tests is run there can be a 1 pixel difference in the location of the axis
                //expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(25,8)');
                //expect(helpers.isTranslateCloseTo($('.columnChart .axisGraphicsContext').attr('transform'), 25, 8)).toBe(true);
                // Update the data set so that the chart is redrawn with multiple series and a legend
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataFourColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataFourColumn.columns[0],
                                        values: ['abc', 'def'],
                                        identity: categoryIdentities,
                                    }],
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadataFourColumn.columns[1],
                                        min: 123,
                                        max: 234,
                                        subtotal: 357,
                                        values: [123, 234]
                                    }, {
                                        source: dataViewMetadataFourColumn.columns[2],
                                        min: 12,
                                        max: 88,
                                        subtotal: 100,
                                        values: [12, 88]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.columnChart')).toBeInDOM();
                    expect($('.bar').length).toBe(4);
                    // Legend should be visible, axis shouldn't need to move, since we use relative layout
                    var legendSelector = interactiveChart ? '.interactive-legend' : '.legend';
                    expect($(legendSelector)).toBeInDOM();
                    expect($(legendSelector).children.length).toBe(2);
                    //expect(helpers.isTranslateCloseTo($('.columnChart .axisGraphicsContext').attr('transform'), 28, 8)).toBe(true);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, null]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.0001, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [12, -0.0001]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                var smallPositiveRectXValue = $('.bar')[0].attributes.getNamedItem('x').value;
                var smallNegativeRectXValue = $('.bar')[3].attributes.getNamedItem('x').value;
                expect(smallPositiveRectXValue).not.toEqual(smallNegativeRectXValue);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart optimal ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [1, 3]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('3');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty stacked bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('stacked bar chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Stacked BarChart DOM validation", function () { return stackedBarChartDomValidation(false); });
    describe("Interactive Stacked BarChart DOM validation", function () { return stackedBarChartDomValidation(true); });
    function hundredPercentStackedBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }]
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('hundredPercentStackedBarChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('single measure hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(2);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('single measure partial highlight hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000],
                                    highlights: [50000, 10000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.highlight').length).toBe(2);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('multi measure hundred percent bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('100%');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty hundred percent bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent bar chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('hundred percent bar chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Hundred Percent Stacked BarChart DOM validation", function () { return hundredPercentStackedBarChartDomValidation(false); });
    describe("Interactive Hundred Percent Stacked BarChart DOM validation", function () { return hundredPercentStackedBarChartDomValidation(true); });
    function clusterdBarChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var dataViewMetadataFourColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('300', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('clusteredBarChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart },
                animation: { transitionImmediate: true },
            });
        });
        it('clustered bar chart dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    min: 27,
                                    max: 113,
                                    subtotal: 140,
                                    values: [27, 113]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(6);
                var rects = $('.bar');
                expect(rects.length).toBe(6);
                expect($('.data-labels').length).toBe(0);
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(1).attr('y'));
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(2).attr('y'));
                expect(+rects.eq(0).attr('y')).toBeLessThan(+rects.eq(4).attr('y'));
                expect(+rects.eq(2).attr('y')).toBeLessThan(+rects.eq(4).attr('y'));
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect($('.data-labels').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight - data labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadataFourColumn);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: true, labelPrecision: 0 } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsObject.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataWithLabelsObject.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204]
                                }, {
                                    source: dataViewMetadataWithLabelsObject.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                var labels = $('.data-labels');
                expect(labels.length).toBe(4);
                //opacity of highlighted labels 
                expect($(labels[0]).css('fill-opacity')).toEqual('1');
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                expect($(labels[2]).css('fill-opacity')).toEqual('1');
                expect($(labels[3]).css('fill-opacity')).toEqual('1');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart negative partial highlight dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: -234,
                                    max: -54,
                                    subtotal: -357,
                                    values: [-123, -234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: -88,
                                    max: -12,
                                    subtotal: -100,
                                    values: [-12, -88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight with overflow dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [150, 264]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [18, 104]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeGreaterThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBe(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('height').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart partial highlight with postiive/negative mix dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [-54, -204]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [-6, -66]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(8);
                expect($('.highlight').length).toBe(4);
                expect(+$('.highlight')[0].attributes.getNamedItem('width').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('width').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('x').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('x').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.bar')[0].attributes.getNamedItem('height').value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart missing measure dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, null]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(3);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('def');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart with near zero measures dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.0001, 234]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [12, -0.0001]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(4);
                var smallPositiveRectXValue = $('.bar')[0].attributes.getNamedItem('x').value;
                var smallNegativeRectXValue = $('.bar')[3].attributes.getNamedItem('x').value;
                expect(smallPositiveRectXValue).not.toEqual(smallNegativeRectXValue);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty clustered bar chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBe(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('10');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.columnChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart should be cleared when empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
                powerbitests.mocks.dataViewScopeIdentity("d"),
                powerbitests.mocks.dataViewScopeIdentity("e"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.bar').length).toBeGreaterThan(0);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.bar').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart with no animator should filter 0/null columns', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, 30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, 20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('.bar').length).toBe(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('clustered bar chart zero line axis is darkened', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (d) { return powerbitests.mocks.dataViewScopeIdentity(d); });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [10, 0, -30, null, 0]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0, -20, null, 88, 10]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Clustered BarChart DOM validation", function () { return clusterdBarChartDomValidation(false); });
    describe("Interactive Clustered BarChart DOM validation", function () { return clusterdBarChartDomValidation(true); });
    describe("Enumerate Objects", function () {
        var v, element;
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } } };
        var measure2Column = { displayName: 'tax', queryName: 'selectTax', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('800', '800');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('enumerateObjectInstances: category+measure', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [categoryColumn, measureColumn] },
                        categorical: {
                            categories: [{
                                    source: categoryColumn,
                                    values: ['red', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: measureColumn,
                                    min: 100000,
                                    max: 200000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[0]['properties']['defaultColor']).toBeDefined();
                expect(points[1]['properties']['showAllDataPoints']).toBeDefined();
                var defaultColor = (points[0]['properties']['defaultColor']).solid.color;
                var color1 = (points[2]['properties']['fill']).solid.color;
                expect(points[2].displayName).toBe('red');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('def');
                expect(color1).toEqual(defaultColor);
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                var points = v.enumerateObjectInstances({ objectName: 'legend' });
                expect(points).toBeUndefined();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify instances on ordinal category axis', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [categoryColumn, measureColumn] },
                        categorical: {
                            categories: [{
                                    source: categoryColumn,
                                    values: ['red', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: measureColumn,
                                    min: 100000,
                                    max: 200000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[2].displayName).toBe('red');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('def');
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                expect(points[0].properties['start']).toBeUndefined();
                expect(points[0].properties['end']).toBeUndefined();
                expect(points[0].properties['axisType']).toBeUndefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify instances on numerical category axis', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [measureColumn, measureColumn] },
                        categorical: {
                            categories: [{
                                    source: measureColumn,
                                    values: [5000, 10000],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: measureColumn,
                                    min: 100000,
                                    max: 200000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(4);
                expect(points[2].displayName).toBe('$5000');
                expect(points[2].selector.data).toEqual([categoryIdentities[0]]);
                expect(points[2].selector.metadata).toBeUndefined();
                expect(points[3].displayName).toBe('$10000');
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBeUndefined();
                expect('start' in points[0].properties).toBeTruthy(); //better to check if the index key is found
                expect('end' in points[0].properties).toBeTruthy();
                expect('axisType' in points[0].properties).toBeTruthy();
                expect('show' in points[0].properties).toBeTruthy();
                expect('showAxisTitle' in points[0].properties).toBeTruthy();
                expect('axisStyle' in points[1].properties).toBeTruthy();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('enumerateObjectInstances: category+multi-measure', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("red"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [categoryColumn, measureColumn] },
                        categorical: {
                            categories: [{
                                    source: categoryColumn,
                                    values: ['red', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: measureColumn,
                                    min: 100000,
                                    max: 200000,
                                    values: [100000, 200000]
                                }, {
                                    source: measure2Column,
                                    min: 150,
                                    max: 250,
                                    values: [150, 250]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toBe(measureColumn.displayName);
                expect(points[0].selector).toEqual({ metadata: measureColumn.queryName });
                expect(points[1].displayName).toBe(measure2Column.displayName);
                expect(points[1].selector).toEqual({ metadata: measure2Column.queryName });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('enumerateObjectInstances: single-measure (no category)', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [categoryColumn, measureColumn] },
                        categorical: {
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: measureColumn,
                                    values: [100000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(1);
                expect(points[0].displayName).toBe(measureColumn.displayName);
                expect(points[0].selector).toEqual({ metadata: measureColumn.queryName });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Column chart labels", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('800', '800');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check margins for long labels, when you have a few columns that do not take up the whole width, and get centered', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends..."),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['this is the label that never ends, it just goes on and on my friends. Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...',
                                        'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 100000,
                                    max: 200000,
                                    subtotal: 300000,
                                    values: [100000, 200000]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                //expect($('.columnChart .axisGraphicsContext').attr('transform')).toBe('translate(36,8)');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Column chart with many labels", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'very very very long label that will be cut off eventually',
                    queryName: 'very very very long label that will be cut off eventually',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'very very very long label that will be cut off eventually',
                    queryName: 'very very very long label that will be cut off eventually',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
            objects: {
                valueAxis: {
                    show: true,
                    position: 'Right',
                    start: 0,
                    end: 200000,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('600', '1800');
            v = powerbi.visuals.visualPluginFactory.createMinerva({ scrollableVisuals: true }).getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: 1200,
                    width: 600
                },
                animation: { transitionImmediate: true },
                isScrollable: true
            });
        });
        it('Check the first data label if he cuts off properly', function (done) {
            var longTitle = 'very very very long label that will be cut off eventually';
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(longTitle),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '2'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '3'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '4'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '5'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '6'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '7'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '8'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '9'),
                powerbitests.mocks.dataViewScopeIdentity(longTitle + '10')
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [longTitle, longTitle + '2', longTitle + '3', longTitle + '4', longTitle + '5', longTitle + '6', longTitle + '7', longTitle + '8', longTitle + '9', longTitle + '10'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100000, 200000, 100000, 200000, 100000, 200000, 100000, 200000, 100000, 200000]
                                }
                            ])
                        }
                    }]
            });
            setTimeout(function () {
                var texts = $('.columnChart .axisGraphicsContext .x.axis .tick').find('text');
                expect(texts.first().text().length).toBeLessThan(texts.last().text().length);
                v.onResizing({ height: 500, width: 200 });
                var texts = $('.columnChart .axisGraphicsContext .x.axis .tick').find('text');
                expect(texts.first().text()).toEqual(texts.last().text());
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("BarChart Interactivity", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var DefaultOpacity = "" + ColumnUtil.DefaultOpacity;
        var DimmedOpacity = "" + ColumnUtil.DimmedOpacity;
        function metadataShowLabels(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, }
            };
            return metadata;
        }
        beforeEach(function () {
            element = powerbitests.helpers.testDom('200', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
        });
        it('Bar chart with dragDataPoint enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var dataViewScopeIdentity2 = powerbitests.mocks.dataViewScopeIdentity('b');
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        dataViewScopeIdentity2,
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            spyOn(hostServices, 'onDragStart').and.callThrough();
            var trigger = powerbitests.helpers.getDragStartTriggerFunctionForD3(bars[1]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            trigger(mockEvent);
            expect(hostServices.onDragStart).toHaveBeenCalledWith({
                event: mockEvent,
                data: {
                    data: {
                        metadata: 'col2',
                        data: [dataViewScopeIdentity2]
                    }
                }
            });
        });
        it('Bar chart without dragDataPoint enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            var trigger = powerbitests.helpers.getDragStartTriggerFunctionForD3(bars[1]);
            expect(trigger).not.toBeDefined();
        });
        it('Bar chart with selection enabled - data labels off', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var dataViewScopeIdentity2 = powerbitests.mocks.dataViewScopeIdentity('b');
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        dataViewScopeIdentity2,
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            spyOn(hostServices, 'onSelect').and.callThrough();
            var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            trigger(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [dataViewScopeIdentity2]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: dataViewScopeIdentity2 }],
                        metadata: 'col2',
                    }
                ]
            });
            //data labels are off
            expect($('.data-labels').length).toBe(0);
        });
        it('Bar chart with selection enabled - data labels on', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var dataViewScopeIdentity2 = powerbitests.mocks.dataViewScopeIdentity('b');
            v.onDataChanged({
                dataViews: [{
                        metadata: metadataShowLabels(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        dataViewScopeIdentity2,
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0]
                                }])
                        }
                    }]
            });
            //data labels are on
            expect($('.data-labels').length).toBe(2);
        });
        it('Bar chart without selection enabled', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(2);
            var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            expect(trigger).not.toBeDefined();
        });
        it('Bar chart multi-selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var mockEvent = {
                abc: 'def',
                ctrlKey: true,
                stopPropagation: function () { },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[0]],
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[0] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger3(mockEvent);
            //expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[0]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[0] }],
                        metadata: 'col2',
                    }
                ]
            });
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[3]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[3] }],
                        metadata: 'col2',
                    }
                ]
            });
        });
        it('Bar chart repeated single selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var mockEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[0]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[0] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[3]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[3] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger3(mockEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: []
            });
        });
        it('Bar chart single and multi selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[1]);
            var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[3]);
            var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[4]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            var mockMultiEvent = {
                abc: 'def',
                ctrlKey: true,
                stopPropagation: function () { },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[0]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[0] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger3(mockMultiEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[0]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[0] }],
                        metadata: 'col2',
                    }
                ]
            });
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[3]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[3] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger3(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[3]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[3] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger1(mockMultiEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[3]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[3] }],
                        metadata: 'col2',
                    }
                ]
            });
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[1]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[1] }],
                        metadata: 'col2',
                    }
                ]
            });
            trigger4(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: [
                    {
                        metadata: 'col2',
                        data: [identities[4]]
                    }
                ],
                data2: [
                    {
                        dataMap: [{ queryName: 'col1', data: identities[4] }],
                        metadata: 'col2',
                    }
                ]
            });
        });
        it('Bar chart external clear selection', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                        powerbitests.mocks.dataViewScopeIdentity('d'),
                                        powerbitests.mocks.dataViewScopeIdentity('e'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            v.onClearSelection();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
        });
        it('Bar clear selection on clearCatcher click', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                        powerbitests.mocks.dataViewScopeIdentity('d'),
                                        powerbitests.mocks.dataViewScopeIdentity('e'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                }])
                        }
                    }]
            });
            var bars = element.find('.bar');
            expect(bars.length).toBe(5);
            var trigger0 = powerbitests.helpers.getClickTriggerFunctionForD3(bars[0]);
            var mockSingleEvent = {
                abc: 'def',
                stopPropagation: function () { },
            };
            var triggerClear = powerbitests.helpers.getClickTriggerFunctionForD3($('.clearCatcher')[0]);
            spyOn(hostServices, 'onSelect').and.callThrough();
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            trigger0(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[2].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[3].style.fillOpacity).toBe(DimmedOpacity);
            expect(bars[4].style.fillOpacity).toBe(DimmedOpacity);
            triggerClear(mockSingleEvent);
            expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[2].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[3].style.fillOpacity).toBe(DefaultOpacity);
            expect(bars[4].style.fillOpacity).toBe(DefaultOpacity);
            expect(hostServices.onSelect).toHaveBeenCalledWith({
                data: []
            });
        });
    });
    function columnChartInteractivity(chartType, columnSelector, thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var hexDefaultColorRed = "#ff0000";
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer)
                }],
            objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: true },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
        });
        it('Drag and click interaction validation', function () {
            // drag and click on chart (not on bar) are implemented the same
            var barChart = v.layers[0];
            spyOn(barChart, 'selectColumn').and.callThrough();
            // click on the graph, expect selectColumn to have been called
            $('.columnChartMainGraphicsContext').d3Click(thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick);
            expect(barChart.selectColumn).toHaveBeenCalled();
            // now, instead of clicking on the graph, which can be unstable due to different user's configurations
            // we will validate that the code knows how to deal with such a click
            var selectedIndex = barChart.columnChart.getClosestColumnIndex(thirdColumnXCoordinateToClick, thirdColumnYCoordinateToClick);
            var expectedSelectedIndex = 2;
            expect(selectedIndex).toBe(expectedSelectedIndex);
        });
        it('Columns Opacity validation', function (done) {
            var barChart = v.layers[0];
            var selectedIndex = 2;
            barChart.selectColumn(selectedIndex);
            SVGUtil.flushAllD3TransitionsIfNeeded({ transitionImmediate: true });
            setTimeout(function () {
                var allRects = d3.selectAll('.bar' + columnSelector);
                expect(allRects).not.toBeEmpty();
                allRects.each(function (data, index) {
                    if (data.categoryIndex === selectedIndex) {
                        expect(parseFloat(($(allRects[0]).eq(index)).css('fill-opacity'))).toBeCloseTo(ColumnUtil.DefaultOpacity, 0);
                    }
                    else {
                        expect(parseFloat(($(allRects[0]).eq(index)).css('fill-opacity'))).toBeCloseTo(ColumnUtil.DimmedOpacity, 1);
                    }
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Update legend is not called twice on same column', function () {
            var barChart = v.layers[0];
            var cartesianVisualHost = barChart.cartesianVisualHost;
            spyOn(cartesianVisualHost, 'updateLegend').and.callThrough();
            // first column is selected. try to select it again
            barChart.selectColumn(0);
            // update legend should not be called again
            expect(cartesianVisualHost.updateLegend).not.toHaveBeenCalled();
        });
        it('Legend validation validation', function () {
            var barChart = v.layers[0];
            // trigger select column
            barChart.selectColumn(2);
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            var item = legend.find('.item');
            var hoverLine = $('.interactive-hover-line');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('c');
            expect(item.find('.itemName').text()).toBe('col2');
            expect(item.find('.itemMeasure').text().trim()).toBe('490000');
            expect(ColorUtilityConverter(item.find('.icon').css('color'))).toEqual(ColorUtilityConverter(hexDefaultColorRed));
            expect(hoverLine.length).toBe(1);
        });
    }
    var x = 250, y = 200;
    describe("Stacked Bar Chart Interactivity", function () { return columnChartInteractivity('barChart', '.bar', x, y); });
    describe("Clustered Bar Chart Interactivity", function () { return columnChartInteractivity('clusteredBarChart', '.bar', x, y); });
    describe("Hundred Percent Stacked Bar Chart Interactivity", function () { return columnChartInteractivity('hundredPercentStackedBarChart', '.bar', x, y); });
    describe("Stacked Column Chart Interactivity", function () { return columnChartInteractivity('columnChart', '.column', x, y); });
    describe("Clustered Column Chart Interactivity", function () { return columnChartInteractivity('clusteredColumnChart', '.column', x, y); });
    describe("Hundred Percent Stacked Column Chart Interactivity", function () { return columnChartInteractivity('hundredPercentStackedColumnChart', '.column', x, y); });
    function columnChartWebAnimations(chartType) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns
            };
            return metadata;
        }
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                scrollableVisuals: false,
            }).getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('highlight Animation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewNoHighlights = {
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                }])
                        }
                    }]
            };
            var dataViewHighlightsA = {
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66],
                                }])
                        }
                    }]
            };
            var dataViewHighlightsB = {
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [120, 10],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [8, 20],
                                }])
                        }
                    }]
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged(dataViewNoHighlights);
            v.onDataChanged(dataViewHighlightsA);
            v.onDataChanged(dataViewHighlightsB);
            v.onDataChanged(dataViewNoHighlights);
            expect(animator).toBeTruthy();
            expect(animator.animate).toHaveBeenCalled();
            done();
        });
        it('highlight Animation - suppressAnimations', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
            ];
            var dataViewNoHighlights = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                }])
                        }
                    }]
            };
            var dataViewHighlightsA = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [54, 204],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [6, 66],
                                }])
                        }
                    }]
            };
            var dataViewHighlightsB = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: metadata(dataViewMetadataThreeColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataThreeColumn[0],
                                    values: ['abc', 'def'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataThreeColumn[1],
                                    min: 123,
                                    max: 234,
                                    subtotal: 357,
                                    values: [123, 234],
                                    highlights: [120, 10],
                                }, {
                                    source: dataViewMetadataThreeColumn[2],
                                    min: 12,
                                    max: 88,
                                    subtotal: 100,
                                    values: [12, 88],
                                    highlights: [8, 20],
                                }])
                        }
                    }]
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged(dataViewNoHighlights);
            v.onDataChanged(dataViewHighlightsA);
            v.onDataChanged(dataViewHighlightsB);
            v.onDataChanged(dataViewNoHighlights);
            expect(animator).toBeTruthy();
            expect(animator.animate).not.toHaveBeenCalled();
            done();
        });
    }
    describe("Stacked Bar Chart Web Animations", function () { return columnChartWebAnimations('barChart'); });
    describe("Clustered Bar Chart Web Animations", function () { return columnChartWebAnimations('clusteredBarChart'); });
    describe("Hundred Percent Stacked Bar Chart Web Animations", function () { return columnChartWebAnimations('hundredPercentStackedBarChart'); });
    describe("Stacked Column Chart Web Animations", function () { return columnChartWebAnimations('columnChart'); });
    describe("Clustered Column Chart Web Animations", function () { return columnChartWebAnimations('clusteredColumnChart'); });
    describe("Hundred Percent Stacked Column Chart Web Animations", function () { return columnChartWebAnimations('hundredPercentStackedColumnChart'); });
    it('tooltip has category formatted date values', function () {
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date), objects: { general: { formatString: "d" } } };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) };
        var categoryIdentities = [
            powerbitests.mocks.dataViewScopeIdentity("2011"),
            powerbitests.mocks.dataViewScopeIdentity("2012"),
        ];
        var dataView = {
            categories: [{
                    source: categoryColumn,
                    values: [new Date(2011, 4, 31), new Date(2012, 6, 30)],
                    identity: categoryIdentities,
                }],
            values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: [100, -200]
                }])
        };
        var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        var data = ColumnChart.converter(dataView, colors);
        var selectionIds = [
            SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[0], measureColumn.queryName, categoryColumn.queryName),
            SelectionId.createWithIdAndMeasureAndCategory(categoryIdentities[1], measureColumn.queryName, categoryColumn.queryName)];
        var legendItems = data.legendData.dataPoints;
        var item = [{
                displayName: 'sales', key: 'series0', index: 0, data: [
                    {
                        categoryValue: new Date(2011, 4, 31).getTime(),
                        value: 100,
                        position: 100,
                        valueAbsolute: 100,
                        valueOriginal: 100,
                        seriesIndex: 0,
                        categoryIndex: 0,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: 100,
                        originalPosition: 100,
                        originalValueAbsolute: 100,
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "5/31/2011" }, { displayName: "sales", value: "100" }],
                        labelFill: labelColor,
                        labelFormatString: undefined,
                        lastSeries: undefined, chartType: undefined
                    },
                    {
                        categoryValue: new Date(2012, 6, 30).getTime(),
                        value: -200,
                        position: 0,
                        valueAbsolute: 200,
                        valueOriginal: -200,
                        seriesIndex: 0,
                        categoryIndex: 1,
                        color: legendItems[0].color,
                        selected: false,
                        originalValue: -200,
                        originalPosition: 0,
                        originalValueAbsolute: 200,
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "year", value: "7/30/2012" }, { displayName: "sales", value: "-200" }],
                        labelFill: labelColor,
                        labelFormatString: undefined,
                        lastSeries: undefined,
                        chartType: undefined
                    }], identity: SelectionId.createWithMeasure("selectSales"), color: legendItems[0].color
            }];
        expect(data.series).toEqual(item);
        expect(AxisHelper.createValueDomain(data.series, true)).toEqual([-200, 100]);
        expect(StackedUtil.calcValueDomain(data.series, false)).toEqual({
            min: -200,
            max: 100
        });
    });
    function getChartWithTooManyValues(chartType, element) {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        v = powerbi.visuals.visualPluginFactory.createMinerva({
            scrollableVisuals: true,
        }).getPlugin(chartType).create();
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true },
        });
        var categoryIdentities = [
            powerbitests.mocks.dataViewScopeIdentity("a"),
            powerbitests.mocks.dataViewScopeIdentity("b"),
            powerbitests.mocks.dataViewScopeIdentity("c"),
            powerbitests.mocks.dataViewScopeIdentity("d"),
            powerbitests.mocks.dataViewScopeIdentity("e"),
            powerbitests.mocks.dataViewScopeIdentity("f"),
            powerbitests.mocks.dataViewScopeIdentity("g"),
            powerbitests.mocks.dataViewScopeIdentity("h"),
            powerbitests.mocks.dataViewScopeIdentity("i"),
            powerbitests.mocks.dataViewScopeIdentity("j"),
            powerbitests.mocks.dataViewScopeIdentity("k"),
            powerbitests.mocks.dataViewScopeIdentity("l"),
            powerbitests.mocks.dataViewScopeIdentity("m"),
            powerbitests.mocks.dataViewScopeIdentity("n"),
            powerbitests.mocks.dataViewScopeIdentity("o"),
            powerbitests.mocks.dataViewScopeIdentity("p"),
            powerbitests.mocks.dataViewScopeIdentity("q"),
            powerbitests.mocks.dataViewScopeIdentity("r"),
            powerbitests.mocks.dataViewScopeIdentity("s"),
            powerbitests.mocks.dataViewScopeIdentity("t"),
        ];
        v.onDataChanged({
            dataViews: [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'],
                                identity: categoryIdentities,
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataTwoColumn.columns[1],
                                min: 10,
                                max: 29,
                                subtotal: 390,
                                values: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
                            }])
                    }
                }]
        });
        return v;
    }
    function barChartScrollbarValidation(chartType, columnSelector) {
        var element;
        var v;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('100', '100');
            v = getChartWithTooManyValues(chartType, element);
        });
        it('DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('rect' + columnSelector).length).toBe(4);
                expect($('rect.extent').length).toBe(1);
                expect($('rect' + columnSelector)[3].attributes.getNamedItem('y').value).toBeLessThan(element.height());
                var transform = SVGUtil.parseTranslateTransform($('.columnChart .axisGraphicsContext .y.axis .tick').last().attr('transform'));
                expect(transform.y).toBeLessThan(element.height());
                expect(transform.x).toBe('0');
                expect($('.brush').attr('transform')).toBe('translate(90,8)');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('height').value, 0)).toBeGreaterThan(8);
                expect($('.brush .extent')[0].attributes.getNamedItem('y').value).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Scrollbar OnMousedown Validation', function (done) {
            var transform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
            var cartesianChart = v;
            var brush = v['brush'];
            var brushExtent = [40, 55];
            brush.extent(brushExtent);
            cartesianChart.setMinBrush(100, 10);
            setTimeout(function () {
                var scrolledTransform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
                expect(transform.y).toEqual(scrolledTransform.y);
                expect(scrolledTransform.y).toBe('8');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('should have correct tick labels after scrolling', function (done) {
            setTimeout(function () {
                var ticks = $('.columnChart .axisGraphicsContext .y.axis .tick');
                var tickCount = ticks.length;
                var startIndex = 10;
                var expectedValues = _.range(0, tickCount).map(function (i) { return String.fromCharCode('a'.charCodeAt(0) + startIndex + i); });
                powerbitests.helpers.runWithImmediateAnimationFrames(function () {
                    v.scrollTo(startIndex);
                    setTimeout(function () {
                        ticks = $('.columnChart .axisGraphicsContext .y.axis .tick');
                        var tickValues = _.map(ticks.get(), function (v) { return $(v).text(); });
                        expect(tickValues).toEqual(expectedValues);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                });
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Bar chart scrollbar", function () { return barChartScrollbarValidation('barChart', '.bar'); });
    describe("ClusteredBarChart scrollbar", function () { return barChartScrollbarValidation('clusteredBarChart', '.bar'); });
    function columnChartScrollbarValidation(chartType, columnSelector) {
        var element;
        var v;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('100', '100');
            v = getChartWithTooManyValues(chartType, element);
        });
        it('DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.columnChart')).toBeInDOM();
                expect($('rect' + columnSelector).length).toBe(4);
                expect($('rect.extent').length).toBe(1);
                expect($('rect' + columnSelector)[3].attributes.getNamedItem('x').value).toBeLessThan(element.width());
                var transform = SVGUtil.parseTranslateTransform($('.columnChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.y).toBe('0');
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').attr('transform')).toBe('translate(22,90)');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBe(13);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Scrollbar On Mousedown Validation', function (done) {
            var transform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
            var cartesianChart = v;
            var brush = v['brush'];
            var brushExtent = [25, 35];
            brush.extent(brushExtent);
            cartesianChart.setMinBrush(100, 10);
            setTimeout(function () {
                var scrolledTransform = SVGUtil.parseTranslateTransform($('.svgScrollable .axisGraphicsContext').first().attr('transform'));
                expect(transform.x).toEqual(scrolledTransform.x);
                expect(scrolledTransform.x).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('should have correct tick labels after scrolling', function (done) {
            setTimeout(function () {
                var ticks = $('.columnChart .axisGraphicsContext .x.axis .tick');
                var tickCount = ticks.length;
                var startIndex = 10;
                var expectedValues = _.range(0, tickCount).map(function (i) { return String.fromCharCode('a'.charCodeAt(0) + startIndex + i); });
                powerbitests.helpers.runWithImmediateAnimationFrames(function () {
                    v.scrollTo(startIndex);
                    setTimeout(function () {
                        ticks = $('.columnChart .axisGraphicsContext .x.axis .tick');
                        var tickValues = _.map(ticks.get(), function (v) { return $(v).text(); });
                        expect(tickValues).toEqual(expectedValues);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                });
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("ColumnChart scrollbar", function () { return columnChartScrollbarValidation('columnChart', '.column'); });
    describe("ClusteredcolumnChart Scrollbar", function () { return columnChartScrollbarValidation('clusteredColumnChart', '.column'); });
    describe("Column chart X axis label rotation/cutoff", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('400', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
        });
        it('long label cutoff at the left edge', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var longLabelValue = 'Very very very very long label';
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [longLabelValue, 'b', 'c', 'd'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity(longLabelValue),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                        powerbitests.mocks.dataViewScopeIdentity('d'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.0, 1.5]
                                }])
                        }
                    }]
            });
            var actualLongLabelTextContent = element.find('.x.axis text')[0].textContent;
            expect(actualLongLabelTextContent).toContain("...");
        });
    });
    describe("X Axis Customization: Column Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var unitLength;
        var bars;
        var labels;
        var columnWidth;
        var dataChangedOptions;
        var lastIndex;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        function setAxisType(xType) {
            dataViewMetadataTwoColumn.objects['categoryAxis'].axisType = xType;
            dataChangedOptions.dataViews.metadata = dataViewMetadataTwoColumn;
        }
        ;
        it('X Axis Customization: Verify Scalar and Categorical axis type', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("20000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
                powerbitests.mocks.dataViewScopeIdentity("50000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 200000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [50, 20000, 10000, 50000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            bars = $('.column');
            var firstItemGap = (+bars[1].getAttribute('x') - (+bars[0].getAttribute('x') + +bars[0].getAttribute('width')));
            lastIndex = bars.length - 1;
            var lastItemGap = +bars[lastIndex].getAttribute('x') - (+bars[lastIndex - 1].getAttribute('x') + +bars[lastIndex - 1].getAttribute('width'));
            expect(firstItemGap).toBeGreaterThan(0);
            expect(lastItemGap).toBeGreaterThan(firstItemGap);
            setAxisType(AxisType.categorical);
            v.onDataChanged(dataChangedOptions);
            firstItemGap = (+bars[1].getAttribute('x') - (+bars[0].getAttribute('x') + +bars[0].getAttribute('width')));
            lastItemGap = +bars[lastIndex].getAttribute('x') - (+bars[lastIndex - 1].getAttribute('x') + +bars[lastIndex - 1].getAttribute('width'));
            expect(firstItemGap).toBeGreaterThan(0);
            expect(lastItemGap).toBeCloseTo(firstItemGap, 2);
        });
        it('Basic scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 100000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [500, 2000, 5000, 10000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (bars[1].getAttribute('x') - bars[0].getAttribute('x')) / 1500;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 500, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 2000, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 5000, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(unitLength * 10000, 2);
            //Verify no column overlapping
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            expect(+bars[2].getAttribute('x') + +columnWidth).toBeLessThan(+bars[3].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('100K');
        });
        it('Big Range scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("50"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("100000"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 50000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [50, 20000, 10000, 50000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (bars[1].getAttribute('x') - bars[0].getAttribute('x')) / 19950;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 50, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 10000, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 20000, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(unitLength * 50000, 2);
            //Verify no column overlapping
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            expect(+bars[2].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[3].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('50K');
        });
        it('Negative And Positive scale values check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("-50"),
                powerbitests.mocks.dataViewScopeIdentity("-70"),
                powerbitests.mocks.dataViewScopeIdentity("-40"),
                powerbitests.mocks.dataViewScopeIdentity("-100"),
            ];
            dataViewMetadataTwoColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: -100,
                    end: 100,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [-50, 0, 40, -100],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            unitLength = (+bars[1].getAttribute('x') - +bars[0].getAttribute('x')) / 50;
            columnWidth = bars[0].getAttribute('width');
            expect(bars[0].getAttribute('x')).toBeCloseTo(unitLength * 50, 2);
            expect(bars[1].getAttribute('x')).toBeCloseTo(unitLength * 100, 2);
            expect(bars[2].getAttribute('x')).toBeCloseTo(unitLength * 140, 2);
            expect(bars[3].getAttribute('x')).toBeCloseTo(0, 2);
            //Verify no column overlapping
            expect(+bars[3].getAttribute('x') + +columnWidth).toBeLessThan(+bars[0].getAttribute('x'));
            expect(+bars[0].getAttribute('x') + +columnWidth).toBeLessThan(+bars[1].getAttribute('x'));
            expect(+bars[1].getAttribute('x') + +columnWidth).toBeLessThan(+bars[2].getAttribute('x'));
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('-100');
            expect(labels[labels.length - 1].textContent).toBe('100');
        });
    });
    describe("Y Axis Customization: Column Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var bars;
        var labels;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
            objects: {
                valueAxis: {
                    show: true,
                    position: 'Right',
                    start: 0,
                    end: 200000,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('verify begin & end', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [500, 2000, 5000, 10000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify begin & end - Big Scale', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [500, 2000, 50, 1000000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 1000000, 150000, 50]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify Y position change: the axis text should be further right than the axis line', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            var dataView = {
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: [500, 2000, 50, 1000000],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            min: 50000,
                            max: 200000,
                            subtotal: 500000,
                            values: [100000, 1000000, 150000, 50]
                        }])
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            var yaxis = $('.y.axis');
            var yaxisLine = yaxis.find('line')[0];
            var yaxisText = yaxis.find('text')[0];
            expect(yaxisText['x']['baseVal'].getItem(0).value).toBeGreaterThan(yaxisLine['x2'].baseVal.value);
            setTimeout(function () {
                dataView.metadata.objects['valueAxis']['position'] = 'Left';
                v.onDataChanged({
                    dataViews: [dataView]
                });
                expect(yaxisText['x']['baseVal'].getItem(0).value).toBeLessThan(yaxisLine['x2'].baseVal.value);
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("X Axis Customization: Bar Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var bars;
        var labels;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
            objects: {
                valueAxis: {
                    show: true,
                    position: true,
                    start: 0,
                    end: 200000,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '900');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('verify begin & end', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [500, 2000, 5000, 10000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
        it('verify begin & end - Big Range', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [5, 2000, 5000, 1000000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 2000000, 150000, 50]
                                }])
                        }
                    }]
            });
            bars = $('.column');
            labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('200K');
        });
    });
    describe("Y Axis Customization: Bar Chart", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var unitLength;
        var bars;
        var labels;
        var barHeight;
        var barHeightArray = [];
        var barArrayLength;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
            objects: {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 100000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            }
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('750', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
        });
        it('Basic scale check', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("500"),
                powerbitests.mocks.dataViewScopeIdentity("2000"),
                powerbitests.mocks.dataViewScopeIdentity("5000"),
                powerbitests.mocks.dataViewScopeIdentity("10000"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: [500, 2000, 5000, 10000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    min: 50000,
                                    max: 200000,
                                    subtotal: 500000,
                                    values: [100000, 200000, 150000, 50000]
                                }])
                        }
                    }]
            });
            bars = $('.bar');
            labels = $('.y.axis').children('.tick');
            barHeight = bars[0].getAttribute('height');
            barHeightArray = [];
            barArrayLength = bars.length;
            for (var i = 0; i < barArrayLength; i++) {
                barHeightArray.push(bars[i].getAttribute('y'));
            }
            barHeightArray.sort();
            unitLength = (+barHeightArray[1] - +barHeightArray[0]) / 5000;
            //Verify begin&end labels
            expect(labels[0].textContent).toBe('0K');
            expect(labels[labels.length - 1].textContent).toBe('100K');
        });
    });
    describe("Bar chart legend", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var dataViewMetadataTwoColumnWithGroup = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    groupName: 'group',
                },
            ],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('400', '300');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
        });
        it('hide legend when there is only one legend and no group', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                        powerbitests.mocks.dataViewScopeIdentity('d'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [0.5, 2.0, 1.0, 1.5]
                                }])
                        }
                    }]
            });
            var legend = element.find('.legend');
            var title = legend.find('.title');
            expect(title.length).toBe(0);
        });
        it('show legend when there is one legend and the legend is in a group', function () {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { dragDataPoint: true },
            });
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('identity'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumnWithGroup,
                        categorical: {
                            categories: [
                                {
                                    source: dataViewMetadataTwoColumnWithGroup.columns[0],
                                    values: ['a', 'b', 'c', 'd'],
                                    identity: identities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataTwoColumnWithGroup.columns[1],
                                    values: [0.5, 2, 1, 1.5],
                                    identity: identities[0],
                                },
                            ])
                        }
                    }]
            });
            ;
            var title = $('.legendText');
            expect(title.length).toBe(1);
            expect(title.text()).toBe('group');
        });
    });
    function pruneColunnChartDataPoint(dataPoint) {
        return {
            categoryValue: dataPoint.categoryValue,
            value: dataPoint.value,
        };
    }
    function columnChartDataLabelsValidation(chartType) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        function metadataShowLabels(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Position Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [1000, 2000, 20],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.data-labels');
                switch (chartType) {
                    case 'barChart':
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        var bars = $('.bar');
                        var attrX1 = +$(bars[0]).attr('x');
                        var attrX2 = +$(bars[1]).attr('x');
                        var attrX3 = +$(bars[2]).attr('x');
                        var width1 = +$(bars[0]).attr('width');
                        var width2 = +$(bars[1]).attr('width');
                        var width3 = +$(bars[2]).attr('width');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('x')).toBeGreaterThan(attrX1 + width1);
                        expect($(labels[2]).attr('x')).toBeGreaterThan(attrX3 + width3);
                        //second data label is inside
                        expect($(labels[1]).attr('x')).toBeLessThan(attrX2 + width2);
                        expect($(labels[1]).attr('x')).toBeGreaterThan(attrX2);
                        break;
                    case 'columnChart':
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        var columns = $('.column');
                        var attrY1 = +$(columns[0]).attr('y');
                        var attrY2 = +$(columns[1]).attr('y');
                        var attrY3 = +$(columns[2]).attr('y');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('y')).toBeLessThan(attrY1);
                        expect($(labels[2]).attr('y')).toBeLessThan(attrY3);
                        //second data label is inside
                        expect($(labels[1]).attr('y')).toBeGreaterThan(attrY2);
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        expect($(labels[0]).attr('y')).toEqual($(labels[1]).attr('y'));
                        expect($(labels[1]).attr('y')).toEqual($(labels[2]).attr('y'));
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                        expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        //after visual resizing, labels should be inside the shape,
        //labels that bigger then shapes, aren't in the DOM
        it('Data Labels validation - after resize visual', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [1000, 2000, 20],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            if (chartType === 'barChart' || chartType === 'hundredPercentStackedBarChart' || chartType === 'clusteredBarChart') {
                v.onResizing({ height: 500, width: 75 });
            }
            else {
                v.onResizing({ height: 500, width: 200 });
            }
            setTimeout(function () {
                var labels = $('.data-labels');
                switch (chartType) {
                    case 'hundredPercentStackedBarChart':
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(3);
                        break;
                    case 'barChart':
                    case 'clusteredBarChart':
                    case 'columnChart':
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(2);
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Data Label Position Validation negative value', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [-1000, 2000, -20],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.data-labels');
                var bars = $('.bar');
                switch (chartType) {
                    case 'barChart':
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).toBeCloseTo($(labels[2]).attr('x'), 6);
                        var attrX1 = +$(bars[0]).attr('x');
                        var attrX2 = +$(bars[1]).attr('x');
                        var attrX3 = +$(bars[2]).attr('x');
                        var width1 = +$(bars[0]).attr('width');
                        var width2 = +$(bars[1]).attr('width');
                        var width3 = +$(bars[2]).attr('width');
                        //first and last data labels are ouside
                        expect($(labels[0]).attr('x')).toBeGreaterThan(attrX1 + width1);
                        expect($(labels[2]).attr('x')).toBeGreaterThan(attrX3 + width3);
                        //second data label is inside
                        expect($(labels[1]).attr('x')).toBeLessThan(attrX2 + width2);
                        expect($(labels[1]).attr('x')).toBeGreaterThan(attrX2);
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[0]).attr('x')).toEqual($(labels[2]).attr('x'));
                        break;
                    case 'columnChart':
                    case 'clusteredColumnChart':
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(3);
                        expect($(labels[0]).attr('x')).not.toEqual($(labels[1]).attr('x'));
                        expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                        expect($(labels[0]).attr('y')).not.toEqual($(labels[1]).attr('y'));
                        expect($(labels[1]).attr('y')).not.toEqual($(labels[2]).attr('y'));
                        expect($(labels[0]).attr('y')).toEqual($(labels[2]).attr('y'));
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Value 0 - Data Label Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [1000, 2000, 0],
                            subtotal: 3000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.data-labels');
                switch (chartType) {
                    case 'barChart':
                    case 'clusteredBarChart':
                    case 'columnChart':
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(3);
                        break;
                    case 'hundredPercentStackedColumnChart':
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(2);
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Data Label Position Validation - multi series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataChangedOptions = {
                dataViews: [{
                        metadata: metadataShowLabels(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata1Category2Measure.columns[0],
                                    values: ['John Domo', 'Delta Force', 'Mr Bing'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata1Category2Measure.columns[1],
                                    values: [-200, 100, 150],
                                    subtotal: 450
                                }, {
                                    source: dataViewMetadata1Category2Measure.columns[2],
                                    values: [-300, 300, 30],
                                    subtotal: 630
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var labels = $('.data-labels');
                var bars;
                var startBar1, startBar2, startBar3, startBar4, startBar5, startBar6;
                var lengthBar1, lengthBar2, lengthBar3, lengthBar4, lengthBar5, lengthBar6;
                if (chartType === 'barChart' || chartType === 'hundredPercentStackedBarChart' || chartType === 'clusteredBarChart') {
                    bars = $('.bar');
                    startBar1 = +$(bars[0]).attr('x');
                    startBar2 = +$(bars[1]).attr('x');
                    startBar3 = +$(bars[2]).attr('x');
                    startBar4 = +$(bars[3]).attr('x');
                    startBar5 = +$(bars[5]).attr('x');
                    lengthBar1 = +$(bars[0]).attr('width');
                    lengthBar2 = +$(bars[1]).attr('width');
                    lengthBar3 = +$(bars[2]).attr('width');
                    lengthBar4 = +$(bars[3]).attr('width');
                    lengthBar5 = +$(bars[5]).attr('width');
                }
                else {
                    bars = $('.column');
                    startBar1 = +$(bars[0]).attr('y');
                    startBar2 = +$(bars[1]).attr('y');
                    startBar3 = +$(bars[2]).attr('y');
                    startBar4 = +$(bars[3]).attr('y');
                    startBar5 = +$(bars[4]).attr('y');
                    startBar6 = +$(bars[5]).attr('y');
                    lengthBar1 = +$(bars[0]).attr('height');
                    lengthBar2 = +$(bars[1]).attr('height');
                    lengthBar3 = +$(bars[2]).attr('height');
                    lengthBar4 = +$(bars[3]).attr('height');
                    lengthBar5 = +$(bars[4]).attr('height');
                    lengthBar6 = +$(bars[5]).attr('height');
                }
                switch (chartType) {
                    case 'barChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('x'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('x'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('x'));
                        //outside end position
                        expect(startBar1 + lengthBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeLessThan($(labels[4]).attr('x'));
                        break;
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(6);
                        //outside end position
                        expect(startBar1 + lengthBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeLessThan($(labels[4]).attr('x'));
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(5);
                        startBar5 = +$(bars[4]).attr('x');
                        lengthBar5 = +$(bars[4]).attr('width');
                        //inside center position
                        expect(startBar1).toBeLessThan($(labels[0]).attr('x'));
                        expect(startBar1 + lengthBar1).toBeGreaterThan($(labels[0]).attr('x'));
                        expect(startBar2).toBeLessThan($(labels[1]).attr('x'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('x'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('x'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('x'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('x'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('x'));
                        expect(startBar5).toBeLessThan($(labels[4]).attr('x'));
                        expect(startBar5 + lengthBar5).toBeGreaterThan($(labels[4]).attr('x'));
                        break;
                    case 'columnChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar2).toBeLessThan($(labels[1]).attr('y'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('y'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('y'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        //outside end position
                        expect(startBar1).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(6);
                        //outside end position
                        expect(startBar1).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        expect(startBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(6);
                        //inside center position
                        expect(startBar1).toBeLessThan($(labels[0]).attr('y'));
                        expect(startBar1 + lengthBar2).toBeGreaterThan($(labels[0]).attr('y'));
                        expect(startBar2).toBeLessThan($(labels[1]).attr('y'));
                        expect(startBar2 + lengthBar2).toBeGreaterThan($(labels[1]).attr('y'));
                        expect(startBar3).toBeLessThan($(labels[2]).attr('y'));
                        expect(startBar3 + lengthBar3).toBeGreaterThan($(labels[2]).attr('y'));
                        expect(startBar4).toBeLessThan($(labels[3]).attr('y'));
                        expect(startBar4 + lengthBar4).toBeGreaterThan($(labels[3]).attr('y'));
                        expect(startBar5).toBeLessThan($(labels[4]).attr('y'));
                        expect(startBar5 + lengthBar5).toBeGreaterThan($(labels[4]).attr('y'));
                        expect(startBar6).toBeLessThan($(labels[5]).attr('y'));
                        expect(startBar6 + lengthBar6).toBeGreaterThan($(labels[5]).attr('y'));
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('barChart'); });
    describe("Clustered Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('clusteredBarChart'); });
    describe("Hundred Percent Stacked Bar Chart Labels outsideRight", function () { return columnChartDataLabelsValidation('hundredPercentStackedBarChart'); });
    describe("Stacked Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('columnChart'); });
    describe("Clustered Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('clusteredColumnChart'); });
    describe("Hundred Percent Stacked Column Chart Labels outsideTop", function () { return columnChartDataLabelsValidation('hundredPercentStackedColumnChart'); });
    function columnChartDataLabelsVisibilityValidation(chartType, show) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: show, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Visibility Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force',],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [20, 100],
                            subtotal: 120
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                if (show)
                    expect($(labels[0]).css('fill-opacity')).toEqual('1');
                else
                    expect($(labels[0]).length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels Visibility", function () { return columnChartDataLabelsVisibilityValidation('barChart', true); });
    describe("Clustered Bar Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('clusteredBarChart', true); });
    describe("Hundred Percent Stacked Bar Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedBarChart', true); });
    describe("Stacked Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('columnChart', true); });
    describe("Clustered Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('clusteredColumnChart', true); });
    describe("Hundred Percent Stacked Column Chart Labels Visible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedColumnChart', true); });
    describe("Stacked Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('barChart', false); });
    describe("Clustered Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('clusteredBarChart', false); });
    describe("Hundred Percent Stacked Bar Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedBarChart', false); });
    describe("Stacked Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('columnChart', false); });
    describe("Clustered Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('clusteredColumnChart', false); });
    describe("Hundred Percent Stacked Column Chart Labels Unvisible", function () { return columnChartDataLabelsVisibilityValidation('hundredPercentStackedColumnChart', false); });
    function columnChartDataLabelsColorValidation(chartType, color) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        var dataViewMetadataTwoColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            }, {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, color: { solid: { color: color } } }
            };
            return metadata;
        }
        function metadataWithoutColor(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Color Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force',],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [20, 1000],
                            subtotal: 1020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                //labels should be visible now for all charts
                expect(ColorUtilityConverter($(labels[0]).css('fill'))).toEqual(ColorUtilityConverter('#ff0000'));
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Label color should be different from rect color when position inside', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
            ];
            var dataView = {
                metadata: metadataWithoutColor(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force',],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [20, 1000],
                            subtotal: 1020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                switch (chartType) {
                    case "barChart":
                    case "clusteredBarChart":
                    case "columnChart":
                    case "clusteredColumnChart":
                        //first labels is outside - get default color
                        expect(labelColor).toEqual(ColorUtilityConverter($(labels[0]).css('fill')));
                        //second label is inside - get white color
                        expect(ColorUtilityConverter($(labels[1]).css('fill'))).toEqual(defaultInsideLabelColor);
                        break;
                    case "hundredPercentStackedBarChart":
                    case "hundredPercentStackedColumnChart":
                        for (var i = 0, len = labels.length; i < len; i++) {
                            expect(ColorUtilityConverter(defaultInsideLabelColor)).toEqual(ColorUtilityConverter($(labels[i]).css('fill')));
                        }
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Data Label Color Validation - multi series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
            var dataChangedOptions = {
                dataViews: [{
                        metadata: metadataWithoutColor(dataViewMetadataTwoColumn),
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata1Category2Measure.columns[0],
                                    values: ['John Domo', 'Delta Force', 'Mr Bing'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata1Category2Measure.columns[1],
                                    values: [-200, 150, 150],
                                    subtotal: 500
                                }, {
                                    source: dataViewMetadata1Category2Measure.columns[2],
                                    values: [-300, 300, 30],
                                    subtotal: 630
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var labels = $('.data-labels');
                var bars;
                if (chartType === 'barChart' || chartType === 'hundredPercentStackedBarChart' || chartType === 'clusteredBarChart') {
                    bars = $('.bar');
                }
                else {
                    bars = $('.column');
                }
                switch (chartType) {
                    case 'barChart':
                        expect(labels.length).toBe(6);
                        //inside center position - white color 
                        expect(ColorUtilityConverter($(labels[1]).css('fill'))).toBe(defaultInsideLabelColor);
                        expect(ColorUtilityConverter($(labels[2]).css('fill'))).toBe(defaultInsideLabelColor);
                        expect(ColorUtilityConverter($(labels[3]).css('fill'))).toBe(defaultInsideLabelColor);
                        expect(ColorUtilityConverter($(labels[4]).css('fill'))).toBe(defaultInsideLabelColor);
                        //outside end position - default color
                        expect(ColorUtilityConverter($(labels[0]).css('fill'))).toBe(labelColor);
                        expect(ColorUtilityConverter($(labels[5]).css('fill'))).toBe(labelColor);
                        break;
                    case 'columnChart':
                        expect(labels.length).toBe(6);
                        //inside center position - white color 
                        expect(ColorUtilityConverter($(labels[1]).css('fill'))).toBe(defaultInsideLabelColor);
                        expect(ColorUtilityConverter($(labels[2]).css('fill'))).toBe(defaultInsideLabelColor);
                        expect(ColorUtilityConverter($(labels[3]).css('fill'))).toBe(defaultInsideLabelColor);
                        //outside end position - default color
                        expect(ColorUtilityConverter($(labels[0]).css('fill'))).toBe(labelColor);
                        expect(ColorUtilityConverter($(labels[4]).css('fill'))).toBe(labelColor);
                        expect(ColorUtilityConverter($(labels[5]).css('fill'))).toBe(labelColor);
                        break;
                    case 'clusteredBarChart':
                        expect(labels.length).toBe(6);
                        //outside end position- default color
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[0]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[1]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[2]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[3]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[5]).css('fill')));
                        //inside center position- white color
                        expect(ColorUtilityConverter($(labels[4]).css('fill'))).toBe(defaultInsideLabelColor);
                        break;
                    case 'clusteredColumnChart':
                        expect(labels.length).toBe(6);
                        //outside end position - shape color
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[0]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[1]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[2]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[3]).css('fill')));
                        expect(labelColor).toBe(ColorUtilityConverter($(labels[5]).css('fill')));
                        //inside center position- white color
                        expect(ColorUtilityConverter($(labels[4]).css('fill'))).toBe(defaultInsideLabelColor);
                        break;
                    case 'hundredPercentStackedColumnChart':
                        expect(labels.length).toBe(6);
                        for (var i = 0; i < labels.length; i++) {
                            expect(ColorUtilityConverter(defaultInsideLabelColor)).toEqual(ColorUtilityConverter($(labels[i]).css('fill')));
                        }
                        break;
                    case 'hundredPercentStackedBarChart':
                        expect(labels.length).toBe(5);
                        for (var i = 0; i < labels.length; i++) {
                            expect(ColorUtilityConverter(defaultInsideLabelColor)).toEqual(ColorUtilityConverter($(labels[i]).css('fill')));
                        }
                        break;
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('barChart', 'rgb(255, 0, 0)'); });
    describe("Clustered Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('clusteredBarChart', 'rgb(255, 0, 0)'); });
    describe("Hundred Percent Stacked Bar Chart Labels Color", function () { return columnChartDataLabelsColorValidation('hundredPercentStackedBarChart', 'rgb(255, 0, 0)'); });
    describe("Stacked Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('columnChart', 'rgb(255, 0, 0)'); });
    describe("Clustered Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('clusteredColumnChart', 'rgb(255, 0, 0)'); });
    describe("Hundred Percent Stacked Column Chart Labels Color", function () { return columnChartDataLabelsColorValidation('hundredPercentStackedColumnChart', 'rgb(255, 0, 0)'); });
    it('Column Chart X and Y-axis show/hide Title ', function () {
        var element = powerbitests.helpers.testDom('500', '500');
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
        var v = powerbi.visuals.visualPluginFactory.create().getPlugin('columnChart').create();
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            interactivity: { isInteractiveLegend: false },
            animation: { transitionImmediate: true },
        });
        var dataViewMetadataOneColumn = {
            columns: [
                {
                    displayName: 'AxesTitleTest',
                    queryName: 'AxesTitleTest',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
            objects: {
                categoryAxis: {
                    showAxisTitle: true
                },
                valueAxis: {
                    showAxisTitle: true
                }
            }
        };
        v.onDataChanged({
            dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [500, 2000, 5000, 10000],
                                identity: categoryIdentities
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [20, 1000],
                                subtotal: 1020
                            }])
                    }
                }]
        });
        expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
        expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
        dataViewMetadataOneColumn.objects = {
            categoryAxis: {
                showAxisTitle: false
            },
            valueAxis: {
                showAxisTitle: false
            }
        };
        v.onDataChanged({
            dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                }]
        });
        expect($('.xAxisLabel').length).toBe(0);
        expect($('.yAxisLabel').length).toBe(0);
    });
    it('Bar Chart: Hide X and Y axis title', function () {
        var element = powerbitests.helpers.testDom('500', '500');
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
        var v = powerbi.visuals.visualPluginFactory.create().getPlugin('barChart').create();
        v.init({
            element: element,
            host: hostServices,
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            interactivity: { isInteractiveLegend: false },
            animation: { transitionImmediate: true },
        });
        var dataViewMetadataOneColumn = {
            columns: [
                {
                    displayName: 'AxesTitleTest',
                    queryName: 'AxesTitleTest',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
            objects: {
                categoryAxis: {
                    showAxisTitle: true
                },
                valueAxis: {
                    showAxisTitle: false
                }
            }
        };
        v.onDataChanged({
            dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [500, 2000, 5000, 10000],
                                identity: categoryIdentities
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [20, 1000],
                                subtotal: 1020
                            }])
                    }
                }]
        });
        expect($('.xAxisLabel').length).toBe(0);
        expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
        dataViewMetadataOneColumn.objects = {
            categoryAxis: {
                showAxisTitle: false
            },
            valueAxis: {
                showAxisTitle: true
            }
        };
        v.onDataChanged({
            dataViews: [{
                    metadata: dataViewMetadataOneColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [500, 2000, 5000, 10000],
                                identity: categoryIdentities
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataOneColumn.columns[0],
                                values: [20, 1000],
                                subtotal: 1020
                            }])
                    }
                }]
        });
        expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
        expect($('.yAxisLabel').length).toBe(0);
    });
    function columnChartDataLabelsFormatValidation(chartType) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                queryName: 'col1',
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                queryName: 'col2',
            },
            {
                displayName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                queryName: 'col3',
            }
        ];
        function metadata(columns, displayUnits, precision) {
            if (displayUnits === void 0) { displayUnits = 0; }
            if (precision === void 0) { precision = 0; }
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, labelDisplayUnits: displayUnits, labelPrecision: precision }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('1000', '1000');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('labels should support display units with no precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 1000, 0),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [500123],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('500K');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('labels should support display units with precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 1000, 1),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [500123],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('500.1K');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('labels should use default display unit automatically', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [1500123],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('1.50M');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('with NaN value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [NaN],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('with Negative Infinity value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [Number.NEGATIVE_INFINITY],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('with Infinity value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [Number.POSITIVE_INFINITY],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('with out of range value shows warning', function (done) {
            var warningSpy = jasmine.createSpy('setWarnings');
            hostServices.setWarnings = warningSpy;
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn, 0, 2),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [1e301],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('labels should support multiple formats', function (done) {
            var columnsWithMultipleFormats = [
                {
                    displayName: 'col1',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    queryName: 'col1',
                    format: "#,0"
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    queryName: 'col2',
                    format: "$#,0"
                },
                {
                    displayName: 'col3',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                    queryName: 'col3',
                },
            ];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(5400123),
            ];
            var dataView = {
                //setting display units to 1, in order to avoid auto scaling
                metadata: metadata(columnsWithMultipleFormats, 1, 0),
                categorical: {
                    categories: [{
                            source: columnsWithMultipleFormats[2],
                            values: ['John'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: columnsWithMultipleFormats[0],
                            values: [1555],
                            subtotal: 3020
                        }, {
                            source: columnsWithMultipleFormats[1],
                            values: [1666],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.data-labels').first().text()).toEqual('1,555');
                expect($($('.data-labels')[1]).text()).toEqual('$1,666');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("Column chart format validation", function () { return columnChartDataLabelsFormatValidation('columnChart'); });
    describe("Stacked Bar format validation", function () { return columnChartDataLabelsFormatValidation('barChart'); });
    describe("Clustered Bar Chart Labels Color", function () { return columnChartDataLabelsFormatValidation('clusteredBarChart'); });
    describe("Clustered Column Chart Labels Color", function () { return columnChartDataLabelsFormatValidation('clusteredColumnChart'); });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var ComboChart = powerbi.visuals.ComboChart;
    var ColorConverter = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var AxisType = powerbi.axisType;
    powerbitests.mocks.setLocale();
    describe("ComboChart", function () {
        it("registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("comboChart").capabilities)
                .toBe(ComboChart.capabilities);
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("lineClusteredColumnComboChart").capabilities)
                .toBe(ComboChart.capabilities);
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("lineStackedColumnComboChart").capabilities)
                .toBe(ComboChart.capabilities);
        });
        it("capabilities should include dataViewMappings", function () {
            expect(ComboChart.capabilities.dataViewMappings).toBeDefined();
        });
        it("capabilities should include dataRoles", function () {
            expect(ComboChart.capabilities.dataRoles).toBeDefined();
        });
        it("Capabilities should not suppressDefaultTitle", function () {
            expect(ComboChart.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.ComboChart.capabilities.objects))
                .toEqual(powerbi.visuals.comboChartProps.general.formatString);
        });
        it("Capabilities should include implicitSort", function () {
            expect(ComboChart.capabilities.sorting.default).toBeDefined();
        });
    });
    describe("ComboChart DOM validation", function () {
        var visualBuilder;
        beforeEach(function (done) {
            visualBuilder = new VisualBuilder("comboChart");
            done();
        });
        it("Ensure both charts and axis created with two data views - default", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(),
                    dataViewFactory.buildDataViewInAnotherDomainOneValue()
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect($(".legend").children.length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure empty 1st dataview and populated 2nd has correct axes and lines", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewEmpty(),
                    dataViewFactory.buildDataViewDefault()
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxisCount = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxisCount).toBe(2); //one is empty
                expect(legend).toBe(1);
                var yAxisPos = $(".y.axis").position();
                var rectCount = $(".columnChart .column").length;
                var lineCount = $(".lineChart .line").length;
                expect(yAxisPos.left).toBeLessThan(50);
                expect(rectCount).toBe(0);
                expect(lineCount).toBe(3);
                var y1 = $($(".y.axis")[0]).find(".tick").length;
                var y2 = $($(".y.axis")[1]).find(".tick").length;
                expect(y1).toEqual(8);
                expect(y2).toEqual(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure comboCharts clear - with metadata", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInAnotherDomain(),
                    dataViewFactory.buildDataViewDefault()
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxisCount = $(".y.axis").length;
                var legend = $(".legend").length;
                var rectCount = $(".columnChart .column").length;
                var y2tickCount = $($(".y.axis")[1]).find(".tick").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxisCount).toBe(2);
                expect(legend).toBe(1);
                expect(rectCount).toBe(3);
                expect($(".legend").children.length).toBe(2);
                expect(y2tickCount).toBeGreaterThan(0);
                // clear line
                visualBuilder.onDataChanged({
                    dataViews: [
                        dataViewFactory.buildDataViewInAnotherDomain(),
                        dataViewFactory.buildDataViewEmpty()
                    ]
                });
                setTimeout(function () {
                    var rectCountNew = $(".columnChart .column").length;
                    expect(rectCountNew).toBe(3);
                    var catCountNew = $(".lineChart").find(".cat").length;
                    expect(catCountNew).toBe(0);
                    var y2tickCountNew = $($(".y.axis")[1]).find(".tick").length;
                    expect(y2tickCountNew).toEqual(0);
                    // clear columns, add back line
                    visualBuilder.onDataChanged({
                        dataViews: [
                            dataViewFactory.buildDataViewEmpty(),
                            dataViewFactory.buildDataViewDefault()
                        ]
                    });
                    setTimeout(function () {
                        var rectCountFinal = $(".columnChart .column").length;
                        expect(rectCountFinal).toBe(0);
                        var catCountFinal = $(".lineChart").find(".cat").length;
                        expect(catCountFinal).toBe(3);
                        var y2tickCountFinal = $($(".y.axis")[1]).find(".tick").length;
                        // y2 axis (line value axis) should be shifted to y1 in this case
                        expect(y2tickCountFinal).toEqual(0);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure comboCharts clear - no line measure metadata", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInAnotherDomain(),
                    dataViewFactory.buildDataViewDefault()
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxisCount = $(".y.axis").length;
                var legend = $(".legend").length;
                var rectCount = $(".columnChart .column").length;
                var y2tickCount = $($(".y.axis")[1]).find(".tick").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxisCount).toBe(2);
                expect(legend).toBe(1);
                expect(rectCount).toBe(3);
                expect($(".legend").children.length).toBe(2);
                expect(y2tickCount).toBeGreaterThan(0);
                // clear line - only one dataView sent in
                visualBuilder.onDataChanged({
                    dataViews: [dataViewFactory.buildDataViewInAnotherDomain()]
                });
                setTimeout(function () {
                    var rectCountNew = $(".columnChart .column").length;
                    expect(rectCountNew).toBe(3);
                    var catCountNew = $(".lineChart").find(".cat").length;
                    expect(catCountNew).toBe(0);
                    var y2tickCountNew = $($(".y.axis")[1]).find(".tick").length;
                    expect(y2tickCountNew).toEqual(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both charts and only one axis created with two data views - default", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(),
                    dataViewFactory.buildDataViewDefault()
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect($(".legend").children.length).toBe(2);
                var y1 = $($(".y.axis")[0]).find(".tick").length;
                var y2 = $($(".y.axis")[1]).find(".tick").length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both charts and axis created with two data views - stacked", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(true),
                    dataViewFactory.buildDataViewInAnotherDomain(true)
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both charts and One axis created with two data views - stacked", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(true),
                    dataViewFactory.buildDataViewDefault(true)
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($(".y.axis")[0]).find(".tick").length;
                var y2 = $($(".y.axis")[1]).find(".tick").length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both charts and axis created with two data views - clustered", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(true),
                    dataViewFactory.buildDataViewInAnotherDomain(true)
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both charts and only one axis created with two data views - clustered", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(true),
                    dataViewFactory.buildDataViewDefault(true)
                ]
            });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                var y1 = $($(".y.axis")[0]).find(".tick").length;
                var y2 = $($(".y.axis")[1]).find(".tick").length;
                expect(y2).toEqual(0);
                expect(y1).not.toEqual(y2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("combo chart validate auto margin", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewDefault(true),
                    dataViewFactory.buildDataViewDefault(true)
                ]
            });
            setTimeout(function () {
                var yTranslate = parseFloat($(".axisGraphicsContext .x.axis").attr("transform").split(",")[1].replace("(", ""));
                var xTranslate = parseFloat($(".axisGraphicsContext .y.axis").attr("transform").split(",")[0].split("(")[1]);
                visualBuilder.onDataChanged({
                    dataViews: [
                        dataViewFactory.buildDataViewSuperLongLabels(true),
                        dataViewFactory.buildDataViewSuperLongLabels(true)
                    ]
                });
                setTimeout(function () {
                    var newYTranslate = parseFloat($(".axisGraphicsContext .x.axis").attr("transform").split(",")[1].replace("(", ""));
                    var newXTranslate = parseFloat($(".axisGraphicsContext .y.axis").attr("transform").split(",")[0].split("(")[1]);
                    expect(yTranslate).toBeGreaterThan(newYTranslate);
                    expect(newXTranslate).toBeGreaterThan(xTranslate);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure scrollbar is shown at smaller viewport dimensions", function (done) {
            visualBuilder.setSize("100", "100");
            visualBuilder.buildVisualMinerva("lineClusteredColumnComboChart");
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewManyCategories(true),
                    dataViewFactory.buildDataViewManyCategories(true)
                ]
            });
            setTimeout(function () {
                var yAxis = $(".y.axis").length;
                expect(yAxis).toBe(2);
                var y1 = $(".svgScrollable").attr("width");
                expect(y1).toBeLessThan(visualBuilder.element.width());
                expect($("rect.extent").length).toBe(1);
                expect(parseInt($(".brush .extent")[0].attributes.getNamedItem("width").value, 0)).toBeGreaterThan(8);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure all data points has the default color", function (done) {
            var dataView1 = dataViewFactory.buildDataViewDefault(true);
            var dataView2 = dataViewFactory.buildDataViewInAnotherDomain(true);
            dataView1.metadata.objects = {
                dataPoint: {
                    defaultColor: { solid: { color: "#FF0000" } }
                }
            };
            dataView2.metadata.objects = {
                dataPoint: {
                    defaultColor: { solid: { color: "#FF0000" } }
                }
            };
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var lineCharts = $(".lineChart").length;
                var columnCharts = $(".columnChart").length;
                var yAxis = $(".y.axis").length;
                var legend = $(".legend").length;
                expect(lineCharts).toBe(1);
                expect(columnCharts).toBe(1);
                expect(yAxis).toBe(2);
                expect(legend).toBe(1);
                expect(ColorConverter($($(".legendIcon")[0]).css("fill"))).toBe("#ff0000");
                expect(ColorConverter($($(".legendIcon")[2]).css("fill"))).toBe("#ff0000");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure zero axis line is darkened", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewNegative(true),
                    dataViewFactory.buildDataViewNegative(true)
                ]
            });
            setTimeout(function () {
                var zeroTicks = $("g.tick:has(line.zero-line)");
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        //Data Labels
        it("Ensure data labels are on both charts with default color", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType();
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType();
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                var fillColumnLabel = columnLabels.first().css("fill");
                var fillLineLabel = lineLabels.first().css("fill");
                var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
                expect(ColorConverter(fillColumnLabel)).toBe(labelColor);
                expect(ColorConverter(fillLineLabel)).toBe(labelColor);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure data labels removed when remove column chart values", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType();
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType();
            visualBuilder.onDataChanged({
                dataViews: [dataView1, dataView2]
            });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                visualBuilder.onDataChanged({
                    dataViews: [
                        dataViewFactory.buildDataViewEmpty(),
                        dataView2]
                });
                setTimeout(function () {
                    var columnLabels2 = $('.columnChartMainGraphicsContext .labels .data-labels');
                    var lineLabels2 = $('.lineChartSVG .labels .data-labels');
                    expect(columnLabels2.length).toBe(0);
                    expect(lineLabels2.length).toBeGreaterThan(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it("Labels should support display units with no precision", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType(undefined, 1000, 0);
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType(undefined, 1000, 0);
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.first().text()).toBe("0K");
                expect(lineLabels.first().text()).toBe("0K");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Labels should support display units with precision", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType(undefined, 1000, 1);
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType(undefined, 1000, 1);
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.first().text()).toBe("0.1K");
                expect(lineLabels.first().text()).toBe("0.2K");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Values that have NaN show a warning.", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInvalid(NaN)
                ]
            });
            setTimeout(function () {
                expect(visualBuilder.warningSpy).toHaveBeenCalled();
                expect(visualBuilder.warningSpy.calls.count()).toBe(1);
                expect(visualBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("NaNNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Values that have Negative Infinity show a warning.", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInvalid(Number.NEGATIVE_INFINITY)
                ]
            });
            setTimeout(function () {
                expect(visualBuilder.warningSpy).toHaveBeenCalled();
                expect(visualBuilder.warningSpy.calls.count()).toBe(1);
                expect(visualBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Values that have Positive Infinity show a warning.", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInvalid(Number.POSITIVE_INFINITY)
                ]
            });
            setTimeout(function () {
                expect(visualBuilder.warningSpy).toHaveBeenCalled();
                expect(visualBuilder.warningSpy.calls.count()).toBe(1);
                expect(visualBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Values that are out of range show a warning.", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInvalid(1e301)
                ]
            });
            setTimeout(function () {
                expect(visualBuilder.warningSpy).toHaveBeenCalled();
                expect(visualBuilder.warningSpy.calls.count()).toBe(1);
                expect(visualBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("ValuesOutOfRange");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("All values good do not show a warning.", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInvalid(3)
                ]
            });
            setTimeout(function () {
                expect(visualBuilder.warningSpy).not.toHaveBeenCalled();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure data lables are on both charts with custom color", function (done) {
            var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType(color);
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType(color);
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                var fillColumnLabel = columnLabels.first().css("fill");
                var fillLineLabel = lineLabels.first().css("fill");
                expect(ColorConverter(fillColumnLabel)).toBe(ColorConverter(color.solid.color));
                expect(ColorConverter(fillLineLabel)).toBe(ColorConverter(color.solid.color));
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure data lables are on both charts and removed", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType();
            var dataView2 = dataViewFactory.buildDataForLabelsSecondType();
            dataView1.metadata.objects = { labels: { show: true } };
            dataView2.metadata.objects = { labels: { show: true } };
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var columnLabels = $('.columnChartMainGraphicsContext .labels .data-labels');
                var lineLabels = $('.lineChartSVG .labels .data-labels');
                expect(columnLabels.length).toBeGreaterThan(0);
                expect(lineLabels.length).toBeGreaterThan(0);
                dataView1.metadata.objects = { labels: { show: false } };
                dataView2.metadata.objects = { labels: { show: false } };
                visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
                setTimeout(function () {
                    var columnLabels2 = $('.columnChartMainGraphicsContext .labels .data-labels');
                    var lineLabels2 = $('.lineChartSVG .labels .data-labels');
                    expect(columnLabels2.length).toBe(0);
                    expect(lineLabels2.length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate enumerate labels", function (done) {
            var dataView1 = dataViewFactory.buildDataForLabelsFirstType();
            dataView1.metadata.objects = null;
            visualBuilder.onDataChanged({ dataViews: [dataView1, null] });
            var points = visualBuilder.visual.enumerateObjectInstances({ objectName: "labels" });
            setTimeout(function () {
                expect(points.length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('validate shoulShowLegendCard with single value on column and no line values', function (done) {
            var dataView1 = dataViewFactory.buildDataViewSingleMeasure();
            var lineDataView = null;
            visualBuilder.onDataChanged({ dataViews: [dataView1, lineDataView] });
            var points = visualBuilder.visual.enumerateObjectInstances({ objectName: 'legend' });
            setTimeout(function () {
                expect(points).not.toBeDefined();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('validate shoulShowLegendCard with dynamic series on column and no line values', function (done) {
            var dynamicSeriesDataView = dataViewFactory.buildDataViewDynamicSeries();
            var lineDataView = null;
            visualBuilder.onDataChanged({ dataViews: [dynamicSeriesDataView, lineDataView] });
            var points = visualBuilder.visual.enumerateObjectInstances({ objectName: 'legend' });
            setTimeout(function () {
                expect(points.length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('validate shoulShowLegendCard with static series for column and line', function (done) {
            var dynamicSeriesDataView = dataViewFactory.buildDataViewDefault();
            var staticSeriesDataView = dataViewFactory.buildDataViewDefault();
            visualBuilder.onDataChanged({ dataViews: [dynamicSeriesDataView, staticSeriesDataView] });
            var points = visualBuilder.visual.enumerateObjectInstances({ objectName: 'legend' });
            setTimeout(function () {
                expect(points.length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('xAxis customization- begin and end check', function (done) {
            var objects = {
                general: dataViewFactory.general,
                categoryAxis: {
                    displayName: "scalar",
                    show: true,
                    start: 0,
                    end: 1000,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewNumber(objects),
                    dataViewFactory.buildDataViewNumber(objects)]
            });
            setTimeout(function () {
                var labels = $(".x.axis").children(".tick");
                //Verify begin&end labels
                expect(labels[0].textContent).toBe("0");
                expect(labels[labels.length - 1].textContent).toBe("1,000");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Merge axes when user turns off the secondary axis.", function (done) {
            var objects = {
                general: dataViewFactory.general,
                valueAxis: {
                    secShow: false
                }
            };
            var dataView = dataViewFactory.buildDataViewCustomSingleColumn(objects, [[4000, 6000, 10000]]);
            var dataViewAnotherDomain = dataViewFactory.buildDataViewCustom(objects, [[1], [10], [20]]);
            visualBuilder.onDataChanged({ dataViews: [dataViewAnotherDomain, dataView] });
            setTimeout(function () {
                var axisLabels = $(".axisGraphicsContext .y.axis").first().find(".tick");
                expect(axisLabels[0].textContent).toBe("0K");
                expect(axisLabels[axisLabels.length - 1].textContent).toBe("10K");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Unmerge axis when user turns on the secondary axis.", function (done) {
            var objects = {
                general: dataViewFactory.general,
                valueAxis: {
                    secShow: true
                }
            };
            var dataView = dataViewFactory.buildDataViewCustomSingleColumn(objects, [[5, 15, 25]]);
            var dataViewAnotherDomain = dataViewFactory.buildDataViewCustom(objects, [[1], [10], [30]]);
            visualBuilder.onDataChanged({ dataViews: [dataViewAnotherDomain, dataView] });
            setTimeout(function () {
                var axisLabels = $(".axisGraphicsContext .y.axis").first().find(".tick");
                expect(axisLabels[0].textContent).toBe("0");
                expect(axisLabels[axisLabels.length - 1].textContent).toBe("30");
                axisLabels = $(".axisGraphicsContext .y.axis").last().find(".tick");
                expect(axisLabels[0].textContent).toBe("5");
                expect(axisLabels[axisLabels.length - 1].textContent).toBe("25");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify force to zero works for a positive domain range", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInAnotherDomain(),
                    dataViewFactory.buildDataViewCustom(undefined, [[4000, 6000, 7000]])]
            });
            setTimeout(function () {
                var axisLabels = $(".axisGraphicsContext .y.axis").last().find(".tick");
                //Verify begin&end labels
                expect(axisLabels[0].textContent).toBe("0K");
                expect(axisLabels[axisLabels.length - 1].textContent).toBe("7K");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify force to zero is not set for a negative domain range", function (done) {
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewInAnotherDomain(),
                    dataViewFactory.buildDataViewCustom(undefined, [[-2000, -6000, -7000]])]
            });
            setTimeout(function () {
                var axisLabels = $(".axisGraphicsContext .y.axis").last().find(".tick");
                //Verify begin&end axis labels
                expect(axisLabels[0].textContent).toBe("-7K");
                expect(axisLabels[axisLabels.length - 1].textContent).toBe("-2K");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure both titles created in Line and Stacked column chart", function (done) {
            var objects = {
                general: dataViewFactory.general,
                valueAxis: {
                    show: true,
                    showAxisTitle: true,
                    secShowAxisTitle: true
                }
            };
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewNumber(objects),
                    dataViewFactory.buildDataViewInAnotherDomainOneValue(objects)]
            });
            setTimeout(function () {
                var lineAxisLabel = $(".yAxisLabel").length;
                expect(lineAxisLabel).toBe(2);
                expect($(".yAxisLabel").first().text()).toBe("col2, col3 and col4");
                expect($(".yAxisLabel").last().text()).toBe("col2");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure only secondary title created in Line and Stacked column chart", function (done) {
            var objects = {
                general: dataViewFactory.general,
                valueAxis: {
                    show: true,
                    showAxisTitle: false,
                    secShowAxisTitle: true
                }
            };
            visualBuilder.onDataChanged({
                dataViews: [
                    dataViewFactory.buildDataViewNumber(objects),
                    dataViewFactory.buildDataViewInAnotherDomainOneValue(objects)]
            });
            setTimeout(function () {
                var lineAxisLabel = $(".yAxisLabel").length;
                expect(lineAxisLabel).toBe(1);
                expect($(".yAxisLabel").first().text()).toBe("col2");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Combo chart with dynamic series and static series has correct colors", function (done) {
            var colors = [
                { value: "#000000" },
                { value: "#000001" },
                { value: "#000002" },
                { value: "#000003" },
                { value: "#000004" }
            ];
            visualBuilder.style.colorPalette.dataColors = new powerbi.visuals.DataColorPalette(colors);
            visualBuilder.initVisual();
            var dynamicSeriesDataView = dataViewFactory.buildDataViewDynamicSeries();
            var staticSeriesDataView = dataViewFactory.buildDataViewDefault();
            // Column chart has a dynamic series, line chart has a static series.
            visualBuilder.onDataChanged({ dataViews: [dynamicSeriesDataView, staticSeriesDataView] });
            setTimeout(function () {
                var lines = $(".lineChart .line");
                var columnSeries = $(".columnChart .series");
                expect(columnSeries.length).toBe(2);
                var series1Columns = columnSeries.eq(0).children(".column");
                var series2Columns = columnSeries.eq(1).children(".column");
                // Dynamic series columns
                expect(ColorConverter(series1Columns.eq(0).css("fill"))).toEqual(colors[0].value);
                expect(ColorConverter(series1Columns.eq(1).css("fill"))).toEqual(colors[0].value);
                expect(ColorConverter(series1Columns.eq(2).css("fill"))).toEqual(colors[0].value);
                expect(ColorConverter(series2Columns.eq(0).css("fill"))).toEqual(colors[1].value);
                expect(ColorConverter(series2Columns.eq(1).css("fill"))).toEqual(colors[1].value);
                expect(ColorConverter(series2Columns.eq(2).css("fill"))).toEqual(colors[1].value);
                // Static series lines
                expect(ColorConverter(lines.eq(0).css("stroke"))).toBe(colors[2].value);
                expect(ColorConverter(lines.eq(1).css("stroke"))).toBe(colors[3].value);
                expect(ColorConverter(lines.eq(2).css("stroke"))).toBe(colors[4].value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Combo chart with two static series has correct colors", function (done) {
            var colors = [
                { value: "#000000" },
                { value: "#000001" },
                { value: "#000002" },
                { value: "#000003" },
                { value: "#000004" }
            ];
            visualBuilder.style.colorPalette.dataColors = new powerbi.visuals.DataColorPalette(colors);
            visualBuilder.initVisual();
            var dataView1 = dataViewFactory.buildDataViewCustom(undefined, [[100, 200, 700], [1000, 2000, 7000]], ["a", "b"]);
            var dataView2 = dataViewFactory.buildDataViewCustomWithIdentities([[100, 200, 700], [10000, 20000, 70000]]);
            // Both layers have static series
            visualBuilder.onDataChanged({ dataViews: [dataView1, dataView2] });
            setTimeout(function () {
                var lines = $(".lineChart .line");
                var columnSeries = $(".columnChart .series");
                expect(columnSeries.length).toBe(2);
                var series1Columns = columnSeries.eq(0).children(".column");
                var series2Columns = columnSeries.eq(1).children(".column");
                // Static series columns
                expect(ColorConverter(series1Columns.eq(0).css("fill"))).toEqual(colors[0].value);
                expect(ColorConverter(series1Columns.eq(1).css("fill"))).toEqual(colors[0].value);
                expect(ColorConverter(series2Columns.eq(0).css("fill"))).toEqual(colors[1].value);
                expect(ColorConverter(series2Columns.eq(1).css("fill"))).toEqual(colors[1].value);
                // Static series lines
                expect(ColorConverter(lines.eq(0).css("stroke"))).toBe(colors[2].value);
                expect(ColorConverter(lines.eq(1).css("stroke"))).toBe(colors[3].value);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("SharedColorPalette", function () {
        var dataColors;
        var sharedPalette;
        var colors = [
            { value: "#000000" },
            { value: "#000001" },
            { value: "#000002" },
            { value: "#000003" }
        ];
        beforeEach(function () {
            dataColors = new powerbi.visuals.DataColorPalette(colors);
            sharedPalette = new powerbi.visuals.SharedColorPalette(dataColors);
        });
        it("should get colors for series values from shared series scale", function () {
            var scale1 = dataColors.getColorScaleByKey("series");
            var colorA = scale1.getColor("a");
            var colorB = scale1.getColor("b");
            var scale2 = sharedPalette.getColorScaleByKey("series");
            expect(scale2.getColor("b").value).toEqual(colorB.value);
            expect(scale2.getColor("a").value).toEqual(colorA.value);
        });
        it("should get colors for measures from default scale", function () {
            var scale = sharedPalette.getNewColorScale();
            expect(scale.getColor(0).value).toEqual(colors[0].value);
            expect(scale.getColor(1).value).toEqual(colors[1].value);
        });
        it("measure colors should come after series colors", function () {
            var seriesScale = sharedPalette.getColorScaleByKey("series");
            var seriesColor1 = seriesScale.getColor("key1");
            var seriesColor2 = seriesScale.getColor("key2");
            sharedPalette.rotateScale();
            var measureScale = sharedPalette.getNewColorScale();
            var measureColor1 = measureScale.getColor(0);
            var measureColor2 = measureScale.getColor(1);
            expect(seriesColor1.value).toEqual(colors[0].value);
            expect(seriesColor2.value).toEqual(colors[1].value);
            expect(measureColor1.value).toEqual(colors[2].value);
            expect(measureColor2.value).toEqual(colors[3].value);
        });
        it("measure colors should come after measure colors", function () {
            var measureScale1 = sharedPalette.getNewColorScale();
            var measureColor1 = measureScale1.getColor(0);
            var measureColor2 = measureScale1.getColor(1);
            sharedPalette.rotateScale();
            var measureScale2 = sharedPalette.getNewColorScale();
            var measureColor3 = measureScale2.getColor(1);
            var measureColor4 = measureScale2.getColor(2);
            expect(measureColor1.value).toEqual(colors[0].value);
            expect(measureColor2.value).toEqual(colors[1].value);
            expect(measureColor3.value).toEqual(colors[2].value);
            expect(measureColor4.value).toEqual(colors[3].value);
        });
        it("getSentimentColors should call parent", function () {
            var spy = spyOn(dataColors, "getSentimentColors").and.callThrough();
            sharedPalette.getSentimentColors();
            expect(spy).toHaveBeenCalled();
        });
        it("getBasePickerColors should call parent", function () {
            var spy = spyOn(dataColors, "getBasePickerColors").and.callThrough();
            sharedPalette.getBasePickerColors();
            expect(spy).toHaveBeenCalled();
        });
    });
    var VisualBuilder = (function () {
        function VisualBuilder(pluginName, width, height) {
            if (width === void 0) { width = "400"; }
            if (height === void 0) { height = "400"; }
            this._visual = powerbi.visuals.visualPluginFactory.create().getPlugin(pluginName).create();
            this.setSize(width, height);
        }
        Object.defineProperty(VisualBuilder.prototype, "warningSpy", {
            get: function () {
                return this._warningSpy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VisualBuilder.prototype, "visual", {
            get: function () {
                return this._visual;
            },
            set: function (value) {
                this._visual = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VisualBuilder.prototype, "hostService", {
            get: function () {
                return this._hostService;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VisualBuilder.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VisualBuilder.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VisualBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        VisualBuilder.prototype.setSize = function (width, height) {
            this._width = width;
            this._height = height;
            this.init();
        };
        VisualBuilder.prototype.init = function () {
            this.element = powerbitests.helpers.testDom(this.height, this.width);
            this._hostService = powerbitests.mocks.createVisualHostServices();
            this._style = powerbi.visuals.visualStyles.create();
            this._warningSpy = jasmine.createSpy("warning");
            this._hostService.setWarnings = this.warningSpy;
            this.initVisual();
        };
        VisualBuilder.prototype.buildVisualMinerva = function (pluginName) {
            this._visual =
                powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin(pluginName).create();
            this.init();
        };
        VisualBuilder.prototype.initVisual = function () {
            this.visual.init({
                element: this.element,
                host: this.hostService,
                style: this.style,
                viewport: {
                    height: this.element.height(),
                    width: this.element.width()
                }
            });
        };
        VisualBuilder.prototype.onDataChanged = function (options) {
            this.visual.onDataChanged(options);
        };
        return VisualBuilder;
    })();
    var DataViewBuilder = (function () {
        function DataViewBuilder() {
            this.general = null;
            this._categoriesValues = [];
            this.values = [];
            this.categoricalValues = [];
            this.objects = null;
            this.categoriesColumns = undefined;
            this.isBuildCategoryIdentities = false;
            this.categoryIdentities = null;
            this.identities = [];
            this.valuesIdentities = null;
            this.columnIdentityRef = undefined;
            this.sourceValueColumn = undefined;
        }
        Object.defineProperty(DataViewBuilder.prototype, "categoriesValues", {
            get: function () {
                return this._categoriesValues;
            },
            set: function (value) {
                this._categoriesValues = value;
            },
            enumerable: true,
            configurable: true
        });
        DataViewBuilder.prototype.buildCategoricalValues = function () {
            this.categoricalValues = [];
            for (var i = 0; i < this.values.length; i++) {
                var categoricalValue = {
                    source: this.getSource(i + 1),
                    subtotal: this.getSubtotal(this.values[i]),
                    values: this.values[i],
                    identity: this.valuesIdentities[i]
                };
                this.categoricalValues.push(categoricalValue);
            }
        };
        DataViewBuilder.prototype.getSource = function (index) {
            if (!this.categoriesColumns) {
                return undefined;
            }
            if (this.categoriesColumns[index]) {
                return this.categoriesColumns[index];
            }
            return this.categoriesColumns[this.categoriesColumns.length - 1];
        };
        DataViewBuilder.prototype.getSubtotal = function (values) {
            return values.reduce(function (x, y) { return x + y; });
        };
        DataViewBuilder.prototype.buildMetadata = function () {
            this.metadata = {
                columns: this.columns,
                properties: this.properties,
                objects: this.objects
            };
        };
        DataViewBuilder.prototype.buildCategories = function () {
            this.categories = [{
                    source: this.getSource(0),
                    values: this.categoriesValues,
                    identity: this.categoryIdentities
                }];
        };
        DataViewBuilder.prototype.buildCategoriesColumns = function () {
            if (!this.categoriesColumns) {
                this.categoriesColumns = this.columns;
            }
        };
        DataViewBuilder.prototype.update = function () {
            this.buildCategoriesColumns();
            this.buildCategoryIdentities();
            this.buildValuesIdentities();
            this.buildCategoricalValues();
            this.buildMetadata();
            this.buildCategories();
        };
        DataViewBuilder.prototype.buildCategoryIdentities = function () {
            if (this.isBuildCategoryIdentities) {
                this.categoryIdentities =
                    this.categoriesValues.map(function (value) { return powerbitests.mocks.dataViewScopeIdentity(value); });
            }
        };
        DataViewBuilder.prototype.buildValuesIdentities = function () {
            this.valuesIdentities = this.identities.map(function (value) { return powerbitests.mocks.dataViewScopeIdentity(value); });
        };
        DataViewBuilder.prototype.buildValueColumns = function () {
            if (this.columnIdentityRef !== undefined &&
                this.sourceValueColumn !== undefined) {
                return DataViewTransform.createValueColumns(this.categoricalValues, [this.columnIdentityRef], this.sourceValueColumn);
            }
            return DataViewTransform.createValueColumns(this.categoricalValues);
        };
        DataViewBuilder.prototype.build = function () {
            return {
                metadata: this.metadata,
                categorical: {
                    categories: this.categories,
                    values: this.buildValueColumns()
                }
            };
        };
        return DataViewBuilder;
    })();
    var dataViewFactory;
    (function (dataViewFactory) {
        dataViewFactory.general = {
            visualType1: "Column",
            visualType2: "Line"
        };
        var columns = [
            { displayName: "col1", queryName: "col1", index: 0, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
            { displayName: "col2", queryName: "col2", isMeasure: true, index: 1, groupName: "a", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: "col3", queryName: "col3", isMeasure: true, index: 2, groupName: "b", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: "col4", queryName: "col4", isMeasure: true, index: 3, groupName: "c", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
        ];
        var columnsNumber = [
            { displayName: "col1", queryName: "col1", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: "col2", queryName: "col2", isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: "col3", queryName: "col3", isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: "col4", queryName: "col4", isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
        ];
        var categoriesValues = ["John Domo", "Delta Force", "Jean Tablau"];
        function setGeneral(dataViewBuilder, isGeneral) {
            if (isGeneral === void 0) { isGeneral = false; }
            if (isGeneral) {
                dataViewBuilder.general = dataViewFactory.general;
            }
        }
        function build(dataViewBuilder) {
            dataViewBuilder.update();
            return dataViewBuilder.build();
        }
        function buildDataViewDefault(isGeneral) {
            if (isGeneral === void 0) { isGeneral = false; }
            var dataViewBuilder = new DataViewBuilder();
            setGeneral(dataViewBuilder, isGeneral);
            dataViewBuilder.columns = columns;
            dataViewBuilder.values = [
                [100, 200, 700],
                [1000, 2000, 7000],
                [10000, 20000, 70000]
            ];
            dataViewBuilder.categoriesValues = categoriesValues;
            dataViewBuilder.isBuildCategoryIdentities = true;
            dataViewBuilder.identities = ["a", "b", "c"];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewDefault = buildDataViewDefault;
        function buildDataViewCustom(objects, values, identities) {
            if (identities === void 0) { identities = undefined; }
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.objects = objects;
            dataViewBuilder.columns = columns;
            if (identities !== undefined) {
                dataViewBuilder.isBuildCategoryIdentities = true;
                dataViewBuilder.identities = identities;
            }
            dataViewBuilder.values = values;
            dataViewBuilder.categoriesValues = categoriesValues;
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewCustom = buildDataViewCustom;
        function buildDataViewCustomSingleColumn(objects, values) {
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.objects = objects;
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesColumns = [columns[1]];
            dataViewBuilder.values = values;
            dataViewBuilder.categoriesValues = categoriesValues;
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewCustomSingleColumn = buildDataViewCustomSingleColumn;
        function buildDataViewCustomWithIdentities(values) {
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesColumns = [columns[0], columns[1], columns[3]];
            dataViewBuilder.values = values;
            dataViewBuilder.categoriesValues = categoriesValues;
            dataViewBuilder.isBuildCategoryIdentities = true;
            dataViewBuilder.identities = ["a", "b"];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewCustomWithIdentities = buildDataViewCustomWithIdentities;
        function buildDataViewInAnotherDomainOneValue(objects) {
            if (objects === void 0) { objects = undefined; }
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.objects = objects;
            dataViewBuilder.columns = columns;
            dataViewBuilder.values = [
                [1]
            ];
            dataViewBuilder.categoriesValues = categoriesValues;
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewInAnotherDomainOneValue = buildDataViewInAnotherDomainOneValue;
        function buildDataViewEmpty() {
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.columns = columns;
            dataViewBuilder.values = [];
            dataViewBuilder.categoriesValues = [];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewEmpty = buildDataViewEmpty;
        function buildDataViewInAnotherDomain(isGeneral, objects) {
            if (isGeneral === void 0) { isGeneral = false; }
            if (objects === void 0) { objects = undefined; }
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.objects = objects;
            setGeneral(dataViewBuilder, isGeneral);
            dataViewBuilder.columns = columns;
            dataViewBuilder.values = [[1], [10], [20]];
            dataViewBuilder.categoriesValues = categoriesValues;
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewInAnotherDomain = buildDataViewInAnotherDomain;
        function buildDataViewSuperLongLabels(isGeneral) {
            if (isGeneral === void 0) { isGeneral = false; }
            var dataViewBuilder = new DataViewBuilder();
            setGeneral(dataViewBuilder, isGeneral);
            dataViewBuilder.columns = columns;
            dataViewBuilder.values = [[100, 200, 700], [1000, 2000, 7000], [1000000, 2000000, 7000000]];
            dataViewBuilder.categoriesValues = [
                "This is a pretty long label I think",
                "This is a pretty long label I thought",
                "This is a pretty long label I should think"
            ];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewSuperLongLabels = buildDataViewSuperLongLabels;
        function buildDataViewManyCategories(isGeneral) {
            if (isGeneral === void 0) { isGeneral = false; }
            var dataViewBuilder = new DataViewBuilder();
            setGeneral(dataViewBuilder, isGeneral);
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesValues = ["John Domo", "Delta Force", "Jean Tablau", "Cat1", "Cat2", "Cat3"];
            dataViewBuilder.values = [
                [100, 200, 700],
                [1000, 2000, 7000],
                [10000, 200, 700],
                [10000, 20000, 70000],
                [10000, 200, 700],
                [10000, 20000, 70000]
            ];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewManyCategories = buildDataViewManyCategories;
        function buildDataViewNegative(isGeneral) {
            if (isGeneral === void 0) { isGeneral = false; }
            var dataViewBuilder = new DataViewBuilder();
            setGeneral(dataViewBuilder, isGeneral);
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesValues = categoriesValues;
            dataViewBuilder.values = [
                [-100, -200, 700],
                [1000, -2000, 7000],
                [10000, 20000, -70000]
            ];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewNegative = buildDataViewNegative;
        function setLabels(dataViewBuilder, color, labelDisplayUnits, labelPrecision) {
            var ojects = {};
            ojects.labels = {
                show: true
            };
            if (color !== undefined) {
                ojects.labels.color = color;
            }
            if (labelDisplayUnits !== undefined) {
                ojects.labels.labelDisplayUnits = labelDisplayUnits;
            }
            if (labelPrecision !== undefined) {
                ojects.labels.labelPrecision = labelPrecision;
            }
            dataViewBuilder.objects = ojects;
        }
        function buildDataForLabelsFirstType(color, labelDisplayUnits, labelPrecision) {
            var dataViewBuilder = new DataViewBuilder();
            setLabels(dataViewBuilder, color, labelDisplayUnits, labelPrecision);
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesValues = ["a", "b", "c", "d", "e"];
            dataViewBuilder.values = [[50, 40, 150, 200, 500]];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataForLabelsFirstType = buildDataForLabelsFirstType;
        function buildDataForLabelsSecondType(color, labelDisplayUnits, labelPrecision) {
            var dataViewBuilder = new DataViewBuilder();
            setLabels(dataViewBuilder, color, labelDisplayUnits, labelPrecision);
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesValues = ["a", "b", "c", "d", "e"];
            dataViewBuilder.values = [[200, 100, 300, 250, 400]];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataForLabelsSecondType = buildDataForLabelsSecondType;
        function buildDataViewInvalid(invalidValue) {
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesValues = [["John Domo"]];
            dataViewBuilder.values = [[invalidValue]];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewInvalid = buildDataViewInvalid;
        function buildDataViewNumber(objects) {
            if (objects === void 0) { objects = null; }
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.objects = objects;
            dataViewBuilder.columns = columnsNumber;
            dataViewBuilder.categoriesValues = [0, 500, 1000];
            dataViewBuilder.values = [
                [100, 200, 700],
                [1000, 2000, 7000],
                [10000, 20000, 70000]];
            dataViewBuilder.update();
            return dataViewBuilder.build();
        }
        dataViewFactory.buildDataViewNumber = buildDataViewNumber;
        function buildDataViewDynamicSeries() {
            var dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.columnIdentityRef = powerbi.data.SQExprBuilder.fieldDef({
                schema: "s",
                entity: "e",
                column: "series"
            });
            dataViewBuilder.columns = columns;
            dataViewBuilder.categoriesColumns = [columns[0], columns[2], columns[3]];
            dataViewBuilder.categoriesValues = categoriesValues;
            dataViewBuilder.isBuildCategoryIdentities = true;
            dataViewBuilder.identities = ["a", "b"];
            dataViewBuilder.values = [
                [1000, 2000, 7000],
                [10000, 20000, 70000]
            ];
            return build(dataViewBuilder);
        }
        dataViewFactory.buildDataViewDynamicSeries = buildDataViewDynamicSeries;
        function buildDataViewSingleMeasure() {
            var dataViewBuilder = new DataViewBuilder();
            var measureColumn = {
                displayName: 'sales',
                queryName: 'selectSales',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer),
                objects: { general: { formatString: '$0' } }
            };
            dataViewBuilder.update();
            dataViewBuilder.categories = undefined;
            dataViewBuilder.categoricalValues = DataViewTransform.createValueColumns([
                {
                    source: measureColumn,
                    values: [100]
                }
            ]);
            return dataViewBuilder.build();
        }
        dataViewFactory.buildDataViewSingleMeasure = buildDataViewSingleMeasure;
    })(dataViewFactory || (dataViewFactory = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    describe("DataColorPalette", function () {
        var dataColors = new powerbi.visuals.DataColorPalette();
        it('Check get color no duplicates until wrap-around', function () {
            // Note (param 0): Since conditional formatting is currently not supported, the datavalue param is ignored. For now the
            //                 test will pass in various objects just to make sure we don't crash. Once conditional formatting is
            //                 supported we should pass in objects that will excercise that the conditional formatting code.
            // Note (param 1): We need to support any object as the index key, since some charts will use number or string index keys
            var scale = dataColors.getNewColorScale();
            var color0 = scale.getColor('test datavalue');
            expect(color0).toExist();
            var color1 = scale.getColor('series index N');
            expect(color1).toExist();
            expect(color0.value).not.toBe(color1.value);
            var color2 = scale.getColor({ seriesProperty: 'X' });
            expect(color2).toExist();
            expect(color1.value).not.toBe(color2.value);
            var color3 = scale.getColor(-1);
            expect(color3).toExist();
            expect(color2.value).not.toBe(color3.value);
            // Wrap around occurs after 40 (base color count) * 12 (cycles) colors currently. We should have no duplicates
            // until that point.
            var previousColor = color3;
            for (var i = 4; i < 480; ++i) {
                var nextColor = scale.getColor(i);
                expect(nextColor).toExist();
                expect(nextColor.value).not.toBe(previousColor.value);
                previousColor = nextColor;
            }
            // Wrap around should occur now, verify we are back to the start
            expect(scale.getColor('abc series')).toBe(color0);
        });
        // The Sentiment/KPI color API is just temporary until conditional formatting is avaiable, but while the API is active it needs to be tested.
        // We can remove this test once the Sentiment API is superseded by conditional formatting.
        it('Check get Sentiment color', function () {
            var sentimentColors = dataColors.getSentimentColors();
            // For now our visuals assume that there are 3 colors
            expect(sentimentColors.length).toBe(3);
            // Check for duplicates
            expect(sentimentColors[0].value).not.toBe(sentimentColors[1].value);
            expect(sentimentColors[1].value).not.toBe(sentimentColors[2].value);
            expect(sentimentColors[0].value).not.toBe(sentimentColors[2].value);
        });
        it('Check parameter colors', function () {
            var localDataColors = new powerbi.visuals.DataColorPalette([{ value: '#112233' }]);
            var firstColor = localDataColors.getNewColorScale().getColor(0);
            expect(firstColor.value).toBe('#112233');
        });
        describe('getColorScaleByKey', function () {
            var color1 = dataColors.getColorScaleByKey('scale1').getColor('a');
            var color2 = dataColors.getColorScaleByKey('scale1').getColor('b');
            var color3 = dataColors.getColorScaleByKey('scale2').getColor('a');
            var color4 = dataColors.getColorScaleByKey('scale1').getColor('a');
            it('should return the same color for the same scale and key', function () {
                expect(color1.value).toEqual(color4.value);
            });
            it('should return the same color for the first key in each scale', function () {
                expect(color1.value).toEqual(color3.value);
            });
            it('should return different colors for different values in the same scale', function () {
                expect(color1.value).not.toEqual(color2.value);
            });
        });
        it('getColorByIndex', function () {
            var colors = [
                { value: '#000000' },
                { value: '#000001' },
                { value: '#000002' },
                { value: '#000003' },
            ];
            var localDataColors = new powerbi.visuals.DataColorPalette(colors);
            for (var i = 0; i < colors.length; i++) {
                expect(localDataColors.getColorByIndex(i)).toEqual(colors[i]);
            }
        });
    });
    describe('D3ColorScale', function () {
        var scale;
        var colors = [
            { value: '#000000' },
            { value: '#000001' },
            { value: '#000002' },
            { value: '#000003' },
        ];
        beforeEach(function () {
            scale = powerbi.visuals.D3ColorScale.createFromColors(colors);
        });
        it('should cover all colors and wrap around', function () {
            for (var i = 0; i < colors.length; i++) {
                expect(scale.getColor(i).value).toEqual(colors[i].value);
            }
            expect(scale.getColor(colors.length).value).toEqual(colors[0].value);
        });
        it('Check get color same index key returns same color', function () {
            var indexKey0 = 4;
            var indexKey1 = 'pie slice 7';
            var color0_firstGet = scale.getColor(indexKey0);
            expect(color0_firstGet).toExist();
            var color1_firstGet = scale.getColor(indexKey1);
            expect(color1_firstGet).toExist();
            var color0_secondGet = scale.getColor(indexKey0);
            expect(color0_secondGet).toExist();
            expect(color0_secondGet.value).toBe(color0_firstGet.value);
            var color1_secondGet = scale.getColor(indexKey1);
            expect(color1_secondGet).toExist();
            expect(color1_firstGet.value).toBe(color1_secondGet.value);
        });
        it('clearAndRotate should clear any allocated colors and return the next color', function () {
            var color1 = scale.getColor(0);
            var color2 = scale.getColor(1);
            scale.clearAndRotateScale();
            var color3 = scale.getColor(0);
            expect(color1.value).toEqual(colors[0].value);
            expect(color2.value).toEqual(colors[1].value);
            expect(color3.value).toEqual(colors[2].value);
        });
        it('clone should create a copy preserving allocated colors', function () {
            var color1 = scale.getColor(0);
            var color2 = scale.getColor(1);
            var scale2 = scale.clone();
            var color3 = scale2.getColor(0);
            var color4 = scale2.getColor(2);
            expect(color1.value).toEqual(colors[0].value);
            expect(color2.value).toEqual(colors[1].value);
            expect(color3.value).toEqual(colors[0].value);
            expect(color4.value).toEqual(colors[2].value);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataDotChart = powerbi.visuals.DataDotChart;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var EventType = powerbitests.helpers.ClickEventType;
    var ColumnUtil = powerbi.visuals.ColumnUtil;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    powerbitests.mocks.setLocale();
    describe("Check DataDotChart capabilities", function () {
        it("DataDotChart registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("dataDotChart").capabilities).toBe(DataDotChart.capabilities);
        });
        it("DataDotChart capabilities should include dataRoles", function () {
            expect(DataDotChart.capabilities.dataRoles).toBeDefined();
        });
        it("DataDotChart capabilities should include dataViewMappings", function () {
            expect(DataDotChart.capabilities.dataViewMappings).toBeDefined();
        });
        it("Capabilities should not suppressDefaultTitle", function () {
            expect(DataDotChart.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(DataDotChart.capabilities.objects)).toEqual(DataDotChart.formatStringProp);
        });
    });
    describe("DataDotChart converter", function () {
        var dataViewBuilder;
        var blankCategoryValue = "(Blank)";
        var dataViewMetadata = {
            columns: [
                {
                    displayName: "stringColumn",
                    queryName: "stringColumn",
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: "numberColumn",
                    queryName: "numberColumn",
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: "dateTimeColumn",
                    queryName: "dateTimeColumn",
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime)
                }
            ]
        };
        beforeEach(function () {
            dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.dataViewMetadata = dataViewMetadata;
        });
        it("Check converter with string categories undefined series", function () {
            dataViewBuilder.columns = [dataViewMetadata.columns[0]];
            dataViewBuilder.update();
            dataViewBuilder.categoricalValues = undefined;
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData).toBeDefined();
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(0);
        });
        it("Check converter with string categories and an empty numeric series", function () {
            dataViewBuilder.categoryValues = ["Cat 1", "Cat 2", "Cat 3"];
            dataViewBuilder.columns = [dataViewMetadata.columns[0], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[]];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData).toEqual({
                series: {
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: []
                },
                hasHighlights: false,
                hasDynamicSeries: true
            });
        });
        it("Check converter with string categories and a numeric series", function () {
            dataViewBuilder.categoryValues = ["Cat 1", "Cat 2", "Cat 3"];
            dataViewBuilder.columns = [dataViewMetadata.columns[0], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100, 200, 300]];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[0]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dataView.categorical.categories[0].values[i]);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter with empty categories and single numeric value", function () {
            dataViewBuilder.columns = [dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100]];
            dataViewBuilder.update();
            dataViewBuilder.categoricalCategories = [];
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toBeUndefined();
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(blankCategoryValue);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter with undefined categories and single numeric value", function () {
            dataViewBuilder.columns = [dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100]];
            dataViewBuilder.update();
            dataViewBuilder.categoricalCategories = [];
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toBeUndefined();
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(blankCategoryValue);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter with string categories and multiple numeric series", function () {
            dataViewBuilder.categoryValues = ["Cat 1", "Cat 2", "Cat 3"];
            dataViewBuilder.columns = [dataViewMetadata.columns[0], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [
                [100, 200, 300],
                [101, 201, 301],
                [102, 202, 302]
            ];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[0]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dataView.categorical.categories[0].values[i]);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter with date-time categories and a numeric series", function () {
            var dates = [new Date("2014/9/25"), new Date("2014/12/12"), new Date("2015/9/25")];
            dataViewBuilder.categoryValues = dates;
            dataViewBuilder.columns = [dataViewMetadata.columns[2], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100, 200, 300]];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[2]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dates[i].getTime());
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter with date-time categories and a numeric series where category value is null", function () {
            var dates = [new Date("2014/9/25"), null, new Date("2015/9/25")];
            dataViewBuilder.categoryValues = dates;
            dataViewBuilder.columns = [dataViewMetadata.columns[2], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100, 200, 300]];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.xCol).toEqual(dataView.metadata.columns[2]);
            expect(actualData.series.yCol).toEqual(dataView.metadata.columns[1]);
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.categoryValue).toBe(dates[i] ? dates[i].getTime() : null);
                expect(seriesData.value).toBe(dataView.categorical.values[0].values[i]);
                expect(seriesData.categoryIndex).toBe(i);
                expect(seriesData.seriesIndex).toBe(0);
                expect(seriesData.selected).toBe(false);
            }
        });
        it("Check converter pass string categories and a numeric series produces identities", function () {
            var identityNames = ["John Domo", "Delta Force", "Jean Tablau"];
            var categoryIdentities = identityNames.map(function (item) { return powerbitests.mocks.dataViewScopeIdentity(item); });
            dataViewBuilder.categoryIdentities = categoryIdentities;
            dataViewBuilder.categoryValues = ["Cat 1", "Cat 2", "Cat 3"];
            dataViewBuilder.columns = [dataViewMetadata.columns[0], dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100, 200, 300]];
            dataViewBuilder.update();
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(3);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.identity).toBeDefined();
                expect(seriesData.identity.getKey()).toContain(identityNames[i]);
            }
        });
        it("Check converter passed undefined categories produces measure name identities ", function () {
            dataViewBuilder.columns = [dataViewMetadata.columns[1]];
            dataViewBuilder.values = [[100]];
            dataViewBuilder.update();
            dataViewBuilder.categoricalCategories = [];
            var dataView = dataViewBuilder.dataView;
            var actualData = DataDotChart.converter(dataView, blankCategoryValue);
            expect(actualData.series).toBeDefined();
            expect(actualData.series.data).toBeDefined();
            expect(actualData.series.data.length).toEqual(1);
            for (var i = 0; i < actualData.series.data.length; i++) {
                var seriesData = actualData.series.data[i];
                expect(seriesData.identity).toBeDefined();
                expect(seriesData.identity.getKey()).toContain(dataViewMetadata.columns[1].displayName);
            }
        });
    });
    var dataViewMetadataDefault = {
        columns: [
            {
                displayName: "stringColumn",
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: "numberColumn",
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                format: "0.000"
            },
            {
                displayName: "dateTimeColumn",
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime)
            }
        ]
    };
    describe("DataDotChart render to DOM", function () {
        var dataViewBuilder;
        var categoryValues = ["a", "b", "c", "d", "e"];
        var categoryIdentities = categoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        beforeEach(function () {
            dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.dataViewMetadata = dataViewMetadataDefault;
            dataViewBuilder.columns = dataViewMetadataDefault.columns;
            dataViewBuilder.categoryValues = categoryValues;
            dataViewBuilder.categoryIdentities = categoryIdentities;
        });
        it("NaN in values shows a warning", function (done) {
            dataViewBuilder.values = [[NaN]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect(dataViewBuilder.warningSpy).toHaveBeenCalled();
                expect(dataViewBuilder.warningSpy.calls.count()).toBe(1);
                expect(dataViewBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("NaNNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Negative Infinity in values shows a warning", function (done) {
            dataViewBuilder.values = [[Number.NEGATIVE_INFINITY]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect(dataViewBuilder.warningSpy).toHaveBeenCalled();
                expect(dataViewBuilder.warningSpy.calls.count()).toBe(1);
                expect(dataViewBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Positive Infinity in values shows a warning", function (done) {
            dataViewBuilder.values = [[Number.POSITIVE_INFINITY]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect(dataViewBuilder.warningSpy).toHaveBeenCalled();
                expect(dataViewBuilder.warningSpy.calls.count()).toBe(1);
                expect(dataViewBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Out of range value in values shows a warning", function (done) {
            dataViewBuilder.values = [[-1e301]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect(dataViewBuilder.warningSpy).toHaveBeenCalled();
                expect(dataViewBuilder.warningSpy.calls.count()).toBe(1);
                expect(dataViewBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("ValuesOutOfRange");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Values all okay does not show a warning", function (done) {
            dataViewBuilder.values = [[300]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect(dataViewBuilder.warningSpy).not.toHaveBeenCalled();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check axis in DOM", function (done) {
            dataViewBuilder.values = [[500000, 495000, 490000, 480000, 500000]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                expect($(".dataDotChart .axisGraphicsContext .x.axis .tick").length).toBeGreaterThan(0);
                expect($(".dataDotChart .axisGraphicsContext .y.axis .tick").length).toBeGreaterThan(0);
                expect($(".dataDotChart .axisGraphicsContext .y.axis .tick").find("text").first().text()).toBe("0M");
                expect($(".dataDotChart .axisGraphicsContext .y.axis .tick").find("text").last().text()).toBe("0.5M");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check dots in DOM", function (done) {
            dataViewBuilder.values = [[500000, 495000, 490000, 480000, 500000]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var $dots = $(".dataDotChart .dot");
                expect($dots.length).toBe(5);
                var dotRadius = 0;
                $dots.each(function (index, elem) {
                    var $elem = $(elem);
                    // I verify all dots have the same non-zero radius
                    var radius = +$elem.attr("r");
                    if (index === 0) {
                        expect(radius).toBeGreaterThan(0);
                        dotRadius = radius;
                    }
                    else {
                        expect(radius).toEqual(dotRadius);
                    }
                    expect(+$elem.attr("cx")).toBeGreaterThan(0);
                    // The first and last dots are at the top
                    if (index === 0 || index === 4) {
                        expect(+$elem.attr("cy")).toBe(0);
                    }
                    else {
                        expect(+$elem.attr("cy")).toBeGreaterThan(0);
                    }
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check dot labels in DOM", function (done) {
            dataViewBuilder.values = [[500000, 495000, 490000, 480000, 500000]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var $labels = $(".dataDotChart .label");
                expect($labels.length).toBe(5);
                $labels.each(function (index, elem) {
                    var $elem = $(elem);
                    expect(+$elem.attr("x")).toBeGreaterThan(0);
                    // The first and last dots are at the top
                    if (index === 0 || index === 4) {
                        expect(+$elem.attr("y")).toBe(0);
                    }
                    else {
                        expect(+$elem.attr("y")).toBeGreaterThan(0);
                    }
                });
                var $label1 = $($labels.get(0));
                expect($label1.text()).toBe("0.5M");
                var $label3 = $($labels.get(2));
                expect($label3.text()).toBe("0.49M");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        var overflowCategoryValues = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
        var overflowCategoryIdentities = overflowCategoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        it("Check dots text overflow handled in DOM", function (done) {
            dataViewBuilder.categoryValues = overflowCategoryValues;
            dataViewBuilder.categoryIdentities = overflowCategoryIdentities;
            dataViewBuilder.values = [[
                    999, 888, 777, 666,
                    555, 444, 333, 222,
                    111, 999, 888, 777,
                    666, 555, 444, 333,
                    222, 111, 999, 888,
                    777, 666, 555, 444,
                    333, 222]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var $labels = $(".dataDotChart .label");
                expect($labels.length).toBeGreaterThan(0);
                $labels.each(function (index, elem) {
                    var $elem = $(elem);
                    expect($elem.attr("class")).toContain("overflowed");
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check partial highlighting dots in DOM", function (done) {
            dataViewBuilder.values = [[500000, 495000, 490000, 480000, 500000]];
            dataViewBuilder.highlights = [[100000, 195000, null, 180000, 9000]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var $dots = $(".dataDotChart .dot");
                expect($dots.length).toBe(10);
                // I check partial highlighting
                var defaultOpacity = ColumnUtil.DefaultOpacity.toString();
                var dimmedOpacity = ColumnUtil.DimmedOpacity.toString();
                expect($dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect($dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect($dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect($dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect($dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect($dots[5].style.fillOpacity).toBe(defaultOpacity);
                expect($dots[6].style.fillOpacity).toBe(dimmedOpacity);
                expect($dots[7].style.fillOpacity).toBe(defaultOpacity);
                expect($dots[8].style.fillOpacity).toBe(dimmedOpacity);
                expect($dots[9].style.fillOpacity).toBe(defaultOpacity);
                // I check that null value causes .null-value css
                expect($($dots[5]).attr("class")).toContain("null-value");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure zero line axis is darkened", function (done) {
            dataViewBuilder.values = [[500000, -495000, 490000, 480000, -500000]];
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var zeroTicks = $("g.tick:has(line.zero-line)");
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("DataDotChart interactivity in DOM", function () {
        var dataViewBuilder;
        var defaultOpacity = ColumnUtil.DefaultOpacity.toString();
        var dimmedOpacity = ColumnUtil.DimmedOpacity.toString();
        var categoryValues = ["a", "b", "c", "d", "e"];
        var categoryIdentities = categoryValues.map(function (n) { return powerbitests.mocks.dataViewScopeIdentity(n); });
        beforeEach(function () {
            dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.dataViewMetadata = dataViewMetadataDefault;
            dataViewBuilder.columns = dataViewMetadataDefault.columns;
            dataViewBuilder.values = [[500000, 495000, 490000, 480000, 500000]];
            dataViewBuilder.categoryValues = categoryValues;
            dataViewBuilder.categoryIdentities = categoryIdentities;
        });
        it("Check select dot", function (done) {
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var dots = $(".dataDotChart .dot");
                spyOn(dataViewBuilder.hostServices, "onSelect").and.callThrough();
                dots.first().d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(dataViewBuilder.hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check multi-select dot", function (done) {
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var dots = $(".dataDotChart .dot");
                spyOn(dataViewBuilder.hostServices, "onSelect").and.callThrough();
                dots.first().d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dataViewBuilder.hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check external clear selection", function (done) {
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var dots = $(".dataDotChart .dot");
                spyOn(dataViewBuilder.hostServices, "onSelect").and.callThrough();
                dots.first().d3Click(0, 0);
                dots.last().d3Click(0, 0, EventType.CtrlKey);
                dataViewBuilder.visual.onClearSelection();
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check clearCatcher clear selection", function (done) {
            dataViewBuilder.update();
            dataViewBuilder.onDataChanged();
            setTimeout(function () {
                var dots = $(".dataDotChart .dot");
                dots.first().d3Click(0, 0);
                dots.last().d3Click(0, 0, EventType.CtrlKey);
                spyOn(dataViewBuilder.hostServices, "onSelect").and.callThrough();
                ($(".clearCatcher").last()).d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(dataViewBuilder.hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    var DataViewBuilder = (function () {
        function DataViewBuilder(width, height) {
            if (width === void 0) { width = "500"; }
            if (height === void 0) { height = "500"; }
            this.highlights = null;
            this.values = [];
            this.categoricalCategories = [];
            this.columns = [];
            this.element = powerbitests.helpers.testDom(height, width);
            this._visual = powerbi.visuals.visualPluginFactory.create().getPlugin("dataDotChart").create();
            this._hostServices = powerbitests.mocks.createVisualHostServices();
            this._warningSpy = jasmine.createSpy("warning");
            this._hostServices.setWarnings = this.warningSpy;
            this.initVisual();
        }
        Object.defineProperty(DataViewBuilder.prototype, "visual", {
            get: function () {
                return this._visual;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DataViewBuilder.prototype, "hostServices", {
            get: function () {
                return this._hostServices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DataViewBuilder.prototype, "warningSpy", {
            get: function () {
                return this._warningSpy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DataViewBuilder.prototype, "dataView", {
            get: function () {
                if (!this._dataView) {
                    this.buildDataView();
                }
                return this._dataView;
            },
            enumerable: true,
            configurable: true
        });
        DataViewBuilder.prototype.initVisual = function () {
            this.visual.init({
                element: this.element,
                host: this.hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: this.element.height(),
                    width: this.element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true, isInteractiveLegend: false }
            });
        };
        DataViewBuilder.prototype.update = function () {
            this.buildCategoricalCategories();
            this.buildCategoricalValues();
        };
        DataViewBuilder.prototype.buildCategoricalCategories = function () {
            this.categoricalCategories = [
                {
                    source: this.getValuesSource(0),
                    values: this.categoryValues,
                    identity: this.categoryIdentities
                }
            ];
        };
        DataViewBuilder.prototype.buildCategoricalValues = function () {
            var categoricalValues = [];
            for (var i = 0; i < this.values.length; i++) {
                categoricalValues.push({
                    source: this.getValuesSource(i + 1),
                    values: this.values[i],
                    highlights: this.getHighlights(i)
                });
            }
            this.categoricalValues =
                DataViewTransform.createValueColumns(categoricalValues);
        };
        DataViewBuilder.prototype.getHighlights = function (index) {
            if (this.highlights) {
                return this.highlights[index];
            }
            return undefined;
        };
        DataViewBuilder.prototype.getValuesSource = function (index) {
            if (this.columns[index]) {
                return this.columns[index];
            }
            return this.columns[this.columns.length - 1];
        };
        DataViewBuilder.prototype.buildDataView = function () {
            this._dataView = {
                metadata: this.dataViewMetadata,
                categorical: {
                    categories: this.categoricalCategories,
                    values: this.categoricalValues
                }
            };
        };
        DataViewBuilder.prototype.onDataChanged = function () {
            this.visual.onDataChanged({
                dataViews: [this.dataView]
            });
        };
        return DataViewBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ColorConvertor = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var DonutChart = powerbi.visuals.DonutChart;
    var SelectionId = powerbi.visuals.SelectionId;
    var LegendPosition = powerbi.visuals.LegendPosition;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var donutColors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
    powerbitests.mocks.setLocale();
    describe("DonutChart", function () {
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', queryName: 'col1', },
                { displayName: 'col2', queryName: 'col2', isMeasure: true }]
        };
        var dataViewMetadataWithFormats = {
            columns: [
                { displayName: 'col1', queryName: 'col1', format: '$0' },
                { displayName: 'col2', queryName: 'col2', format: '#,0', isMeasure: true, }]
        };
        var dataViewMetadata3Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1', isMeasure: true, },
                { displayName: 'col2', queryName: 'col2', isMeasure: true, },
                { displayName: 'col3', queryName: 'col3', isMeasure: true, }]
        };
        var dataViewMetadata1Category2Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1', },
                { displayName: 'col2', queryName: 'col2', isMeasure: true, },
                { displayName: 'col3', queryName: 'col3', isMeasure: true, }]
        };
        var dataViewMetadata1Category2MeasureWithFormat = {
            columns: [
                { displayName: 'col1', queryName: 'col1', },
                { displayName: 'col2', queryName: 'col2', isMeasure: true, objects: { general: { formatString: "\$#,0;(\$#,0);\$#,0" } } },
                { displayName: 'col3', queryName: 'col3', isMeasure: true, }]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        it('DonutChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart').capabilities).toBe(powerbi.visuals.donutChartCapabilities);
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.donutChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('Donutchart preferred capabilities requires at least 2 row', function () {
            var dataViewWithSingleRow = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a')]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100],
                            subtotal: 100
                        }])
                }
            };
            var dataViewWithTwoRows = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b')]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200],
                            subtotal: 300
                        }])
                }
            };
            var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart');
            expect(powerbi.DataViewAnalysis.supports(dataViewWithSingleRow, plugin.capabilities.dataViewMappings[0], true)).toBe(false);
            expect(powerbi.DataViewAnalysis.supports(dataViewWithTwoRows, plugin.capabilities.dataViewMappings[0])).toBe(true);
        });
        describe("Data Labels", function () {
            var v;
            var element;
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                        queryName: 'col1',
                    },
                    {
                        displayName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                        queryName: 'col1',
                    }],
            };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('donutChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                });
            });
            function getOptionsForValueWarning(values) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true },
                    categoryLabels: { show: true }
                };
                var options = {
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: values,
                                    }])
                            }
                        }]
                };
                return options;
            }
            it('NaN in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, NaN, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Negative Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, Number.NEGATIVE_INFINITY, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Positive Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, Number.POSITIVE_INFINITY, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Out of range value in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, 1e301, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('All are good in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValueWarning([300, 200, 700]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).not.toHaveBeenCalled();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Layout - with labels and without', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0 },
                    categoryLabels: { show: false }
                };
                var dataViews = [{
                        metadata: dataViewMetadataWithLabels,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabels.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabels.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }];
                v.onDataChanged({
                    dataViews: dataViews,
                });
                setTimeout(function () {
                    var dataLabelsWidth = v['radius'];
                    dataViewMetadataWithLabels.objects['labels']['show'] = false;
                    dataViewMetadataWithLabels.objects['categoryLabels']['show'] = true;
                    dataViews[0].metadata = dataViewMetadataWithLabels;
                    v.onDataChanged({
                        dataViews: dataViews,
                    });
                    setTimeout(function () {
                        var categoryLabelsWidth = v['radius'];
                        dataViewMetadataWithLabels.objects['labels']['show'] = false;
                        dataViewMetadataWithLabels.objects['categoryLabels']['show'] = false;
                        dataViews[0].metadata = dataViewMetadataWithLabels;
                        v.onDataChanged({
                            dataViews: dataViews,
                        });
                        setTimeout(function () {
                            var noLabelsWidth = v['radius'];
                            expect(dataLabelsWidth).toEqual(categoryLabelsWidth);
                            expect(noLabelsWidth).toBeGreaterThan(categoryLabelsWidth);
                            done();
                        }, powerbitests.DefaultWaitForRender);
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - measure and category', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 100");
                    expect($(labels[1]).text()).toBe("b 200");
                    expect($(labels[2]).text()).toBe("c 700");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - measure with default display units from model', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [12345, 15533, 776],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 12.35K");
                    expect($(labels[1]).text()).toBe("b 15.53K");
                    expect($(labels[2]).text()).toBe("c 0.78K");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - measure with display units and no precision', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [12345, 15533, 776],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 12K");
                    expect($(labels[1]).text()).toBe("b 16K");
                    expect($(labels[2]).text()).toBe("c 1K");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - measure with display units and precision', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelDisplayUnits: 1000000, labelPrecision: 3 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [12345, 15533, 776],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a 0.012M");
                    expect($(labels[1]).text()).toBe("b 0.016M");
                    expect($(labels[2]).text()).toBe("c 0.001M");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - measure', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0, },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("100");
                    expect($(labels[1]).text()).toBe("200");
                    expect($(labels[2]).text()).toBe("700");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Show the correct text - category', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toBe("a");
                    expect($(labels[1]).text()).toBe("b");
                    expect($(labels[2]).text()).toBe("c");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('No data labels', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var label = element.find('.donutChart .labels').find('text');
                    expect($(label[0]).length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Verify data labels - default style', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true },
                    categoryLabels: { show: false }
                };
                var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
                var opacity = '1';
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(labelColor));
                    expect($(labels[0]).css('opacity')).toBe(opacity);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Verify data labels - changing measure color', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, color: color },
                    categoryLabels: { show: false }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(color.solid.color));
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Verify data labels - changing category color', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false, color: color },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    var fill = $(labels[0]).css('fill');
                    expect(ColorConvertor(fill)).toBe(ColorConvertor(color.solid.color));
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Long data labels', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['abcdefghijklmnopqrstuvwxyz', '01234567890123456789', 'abcdefg', 'd', 'e'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('abcdefghijklmnopqrstuvwxyz'),
                                            powerbitests.mocks.dataViewScopeIdentity('01234567890123456789'),
                                            powerbitests.mocks.dataViewScopeIdentity('abcdefg'),
                                            powerbitests.mocks.dataViewScopeIdentity('d'),
                                            powerbitests.mocks.dataViewScopeIdentity('e')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [110, 120, 130, 140, 150],
                                        subtotal: 650
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect($(labels[0]).text()).toContain("...");
                    expect($(labels[1]).text()).toContain("...");
                    expect($(labels[2]).text()).toBe("abcdefg");
                    expect($(labels[3]).text()).toBe("d");
                    expect($(labels[4]).text()).toBe("e");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('data labels visibility after resizing', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: true, labelPrecision: 0 },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'),
                                            powerbitests.mocks.dataViewScopeIdentity('b'),
                                            powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [110, 120, 130],
                                        subtotal: 360
                                    }])
                            }
                        }]
                });
                v.onResizing({
                    height: 600,
                    width: 600,
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect(labels.length).toBe(3);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Data lables with null', function (done) {
                var dataViewMetadataWithLabels = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabels.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect(labels.length).toBe(3);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Data labels with multiple formats', function (done) {
                //override view port size
                element = powerbitests.helpers.testDom('1500', '1500');
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                });
                var dataViewMetadataWithLabels = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                            queryName: 'col1',
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                            queryName: 'col1',
                            format: '%#,0',
                        },
                        {
                            displayName: 'col3',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                            queryName: 'col3',
                            format: '#,0'
                        }],
                    objects: {
                        labels: { show: true, labelPrecision: 0, labelDisplayUnits: null },
                        categoryLabels: { show: false }
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabels,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabels.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabels.columns[1],
                                        values: [10, 20, 30],
                                    }, {
                                        source: dataViewMetadataWithLabels.columns[2],
                                        values: [100, 2000, 7000],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var labels = element.find('.donutChart .labels').find('text');
                    expect(labels.first().text()).toBe('%1,000');
                    expect(labels.last().text()).toBe('7,000');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        });
        describe('converter', function () {
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            it('empty', function () {
                var dataView = {
                    categorical: {
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [],
                                    subtotal: 0
                                }])
                        }
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var expectSlices = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: { title: "", dataPoints: [] },
                    hasHighlights: false,
                    dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                    legendObjectProperties: undefined,
                    maxValue: 0,
                    visibleGeometryCulled: false,
                };
                expect(actualData).toEqual(expectSlices);
            });
            it('categorical, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [-300, null, 700]
                            }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    }, {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    }, {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('categorical, no slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [-300, null, 700]
                            }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    }, {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1]
                    }, {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('category and series, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata1Category2Measure.columns[1],
                                values: [-200, null, 150],
                                identity: powerbitests.mocks.dataViewScopeIdentity('foo'),
                            }, {
                                source: dataViewMetadata1Category2Measure.columns[2],
                                values: [-300, 300, -50],
                                identity: powerbitests.mocks.dataViewScopeIdentity('bar'),
                            }])
                    },
                    metadata: dataViewMetadata1Category2Measure,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIds(categoryIdentities[0], dataView.categorical.values[0].identity),
                        measure: -200,
                        value: 0.2,
                        index: 0,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-200" }],
                        color: sliceColors[0],
                    }, {
                        identity: SelectionId.createWithIds(categoryIdentities[0], dataView.categorical.values[1].identity),
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }],
                        color: sliceColors[0],
                    }, {
                        identity: SelectionId.createWithIds(categoryIdentities[1], dataView.categorical.values[0].identity),
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    }, {
                        identity: SelectionId.createWithIds(categoryIdentities[1], dataView.categorical.values[1].identity),
                        measure: 300,
                        value: 0.3,
                        index: 1,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }],
                        color: sliceColors[1],
                    }, {
                        identity: SelectionId.createWithIds(categoryIdentities[2], dataView.categorical.values[0].identity),
                        measure: 150,
                        value: 0.15,
                        index: 2,
                        label: 'col2',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "150" }],
                        color: sliceColors[2],
                    }, {
                        identity: SelectionId.createWithIds(categoryIdentities[2], dataView.categorical.values[1].identity),
                        measure: -50,
                        value: 0.05,
                        index: 2,
                        label: 'col3',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints.length).toBe(3);
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
                expect(actualData.legendData.dataPoints[1].label).toBe('b');
                expect(actualData.legendData.dataPoints[2].label).toBe('c');
            });
            it('categorical, no slicing, formatted color', function () {
                var hexGreen = "#00FF00";
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                                objects: [
                                    undefined,
                                    { dataPoint: { fill: { solid: { color: hexGreen } } } },
                                    undefined,
                                ]
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [-300, null, 700]
                            }])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    hexGreen,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        measure: -300,
                        value: 0.3,
                        index: 0,
                        label: 'a',
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-300" }],
                        color: sliceColors[0],
                    }, {
                        identity: selectionIds[1],
                        measure: 0,
                        value: 0.0,
                        index: 1,
                        label: 'b',
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    }, {
                        identity: selectionIds[2],
                        measure: 700,
                        value: 0.7,
                        index: 2,
                        label: 'c',
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
            });
            it('categorical multi-measure, with slicing', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2Measure.columns[1],
                                values: [-200, null, 150]
                            },
                            {
                                source: dataViewMetadata1Category2Measure.columns[2],
                                values: [-300, 300, -50]
                            }
                        ])
                    },
                    metadata: dataViewMetadata1Category2Measure,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                        measure: -200,
                        label: 'col2',
                        value: 0.2,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-200" }],
                        color: sliceColors[0],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col3'),
                        measure: -300,
                        label: 'col3',
                        value: 0.3,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }],
                        color: sliceColors[0],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                        measure: 0,
                        label: 'col2',
                        value: 0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col3'),
                        measure: 300,
                        label: 'col3',
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }],
                        color: sliceColors[1],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2'),
                        label: 'col2',
                        measure: 150,
                        value: 0.15,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "150" }],
                        color: sliceColors[2],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col3'),
                        label: 'col3',
                        measure: -50,
                        value: 0.05,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints.length).toBe(3);
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
                expect(actualData.legendData.dataPoints[1].label).toBe('b');
                expect(actualData.legendData.dataPoints[2].label).toBe('c');
            });
            it('non-categorical multi-measure, with slicing', function () {
                // Explicitly set the color for the first measure.
                var columnWithColor = powerbi.Prototype.inherit(dataViewMetadata3Measure.columns[0]);
                columnWithColor.objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: columnWithColor,
                                values: [200]
                            },
                            {
                                source: dataViewMetadata3Measure.columns[1],
                                values: [-300]
                            },
                            {
                                source: dataViewMetadata3Measure.columns[2],
                                values: [500]
                            }
                        ])
                    },
                    metadata: dataViewMetadata3Measure,
                };
                // Slicing does not come into effect for non-categorical multi-measure
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = dataViewMetadata3Measure.columns.map(function (c) { return SelectionId.createWithMeasure(c.displayName); });
                var sliceColors = [
                    'red',
                    donutColors.getColorByIndex(1).value,
                    donutColors.getColorByIndex(2).value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 0.2,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                    }, {
                        identity: selectionIds[1],
                        label: 'col2',
                        measure: -300,
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col2", value: "-300" }],
                        color: sliceColors[1],
                    }, {
                        identity: selectionIds[2],
                        label: 'col3',
                        measure: 500,
                        value: 0.5,
                        index: 2,
                        tooltipInfo: [{ displayName: "col3", value: "500" }],
                        color: sliceColors[2],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
            });
            it('non-categorical single-measure, with slicing', function () {
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata3Measure.columns[0],
                                values: [200]
                            }
                        ])
                    },
                    metadata: dataViewMetadata3Measure,
                };
                // Slicing does not come into effect for non-categorical single-measure
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = dataViewMetadata3Measure.columns.map(function (c) { return SelectionId.createWithMeasure(c.displayName); });
                var sliceColors = [donutColors.getColorByIndex(0).value];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 1.0,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
            });
            it('non-categorical series', function () {
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata3Measure.columns[0],
                                values: [200],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col1'),
                            }, {
                                source: dataViewMetadata3Measure.columns[1],
                                values: [300],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col2'),
                            }
                        ], [categoryColumnRef], dataViewMetadata[1])
                    },
                    metadata: dataViewMetadata,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = dataView.categorical.values.map(function (c) { return SelectionId.createWithId(c.identity); });
                var columnRefId = powerbi.data.SQExprShortSerializer.serializeArray([categoryColumnRef]);
                var sliceColors = [
                    donutColors.getColorScaleByKey(columnRefId).getColor('col1').value,
                    donutColors.getColorScaleByKey(columnRefId).getColor('col2').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 0.4,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "200" }],
                        color: sliceColors[0],
                        labelFormatString: undefined,
                    }, {
                        identity: selectionIds[1],
                        label: 'col2',
                        measure: 300,
                        value: 0.6,
                        index: 1,
                        tooltipInfo: [{ displayName: "col2", value: "300" }],
                        color: sliceColors[1],
                        labelFormatString: undefined,
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('');
                expect(actualData.legendData.dataPoints[0].label).toBe('col1');
                expect(actualData.legendData.dataPoints[1].label).toBe('col2');
            });
            it('data with format string', function () {
                var dataView = {
                    categorical: {
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataWithFormats.columns[0],
                                values: [200],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col1'),
                            }, {
                                source: dataViewMetadataWithFormats.columns[1],
                                values: [300],
                                identity: powerbitests.mocks.dataViewScopeIdentity('col2'),
                            }
                        ], [categoryColumnRef], dataViewMetadataWithFormats[1])
                    },
                    metadata: dataViewMetadataWithFormats,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var selectionIds = dataView.categorical.values.map(function (c) { return SelectionId.createWithId(c.identity); });
                var columnRefId = powerbi.data.SQExprShortSerializer.serializeArray([categoryColumnRef]);
                var sliceColors = [
                    donutColors.getColorScaleByKey(columnRefId).getColor('col1').value,
                    donutColors.getColorScaleByKey(columnRefId).getColor('col2').value,
                ];
                var expectSlices = [
                    {
                        identity: selectionIds[0],
                        label: 'col1',
                        measure: 200,
                        value: 0.4,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "$200" }],
                        color: sliceColors[0],
                        categoryLabel: 'col1',
                        labelFormatString: '$0',
                    }, {
                        identity: selectionIds[1],
                        label: 'col2',
                        measure: 300,
                        value: 0.6,
                        index: 1,
                        tooltipInfo: [{ displayName: "col2", value: "300" }],
                        color: sliceColors[1],
                        categoryLabel: 'col2',
                        labelFormatString: '#,0',
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
            });
            it('with highlights', function () {
                // categorical, multi-measure slices, with highlights
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2Measure.columns[1],
                                values: [-200, null, 150],
                                highlights: [-100, null, 15],
                            },
                            {
                                source: dataViewMetadata1Category2Measure.columns[2],
                                values: [-300, 300, -50],
                                highlights: [-150, 75, 50],
                            }
                        ])
                    },
                    metadata: dataViewMetadata1Category2Measure,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var highlightDisplayName = powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                        measure: -200,
                        label: 'col2',
                        highlightRatio: 0.5,
                        value: 0.2,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "-200" }, { displayName: highlightDisplayName, value: "-100" }],
                        color: sliceColors[0],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col3'),
                        measure: -300,
                        label: 'col3',
                        highlightRatio: 0.5,
                        value: 0.3,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }, { displayName: highlightDisplayName, value: "-150" }],
                        color: sliceColors[0],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                        measure: 0,
                        label: 'col2',
                        highlightRatio: 1e-9,
                        value: 0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "0" }],
                        color: sliceColors[1],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col3'),
                        measure: 300,
                        label: 'col3',
                        highlightRatio: 0.25,
                        value: 0.3,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }, { displayName: highlightDisplayName, value: "75" }],
                        color: sliceColors[1],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2'),
                        label: 'col2',
                        highlightRatio: 0.1,
                        measure: 150,
                        value: 0.15,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "150" }, { displayName: highlightDisplayName, value: "15" }],
                        color: sliceColors[2],
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col3'),
                        label: 'col3',
                        highlightRatio: 1,
                        measure: -50,
                        value: 0.05,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }, { displayName: highlightDisplayName, value: "50" }],
                        color: sliceColors[2],
                        labelFormatString: undefined,
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
                // Legend
                expect(actualData.legendData.title).toBe('col1');
                expect(actualData.legendData.dataPoints.length).toBe(3);
                expect(actualData.legendData.dataPoints[0].label).toBe('a');
                expect(actualData.legendData.dataPoints[1].label).toBe('b');
                expect(actualData.legendData.dataPoints[2].label).toBe('c');
            });
            //validate tooltip on highlighted values, the first tooptip is regular because highlighted value is 0, another tooltips are highlighted tooltips 
            it('with highlights - special case tooltip validation', function () {
                // categorical, multi-measure slices, zero-highlight as special case
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150],
                                highlights: [0, null, 10],
                            }, {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                                highlights: [0, 75, 50],
                            }]),
                    },
                    metadata: null,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var highlightName = powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                //regular tooltip
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual([{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($200)" }]);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual([{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }]);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual([{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$0" }]);
                //tooltips with highlighted values
                expect(actualData.dataPoints[3].data.tooltipInfo).toEqual([{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }, { displayName: highlightName, value: "75" }]);
                expect(actualData.dataPoints[4].data.tooltipInfo).toEqual([{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$150" }, { displayName: highlightName, value: "$10" }]);
                expect(actualData.dataPoints[5].data.tooltipInfo).toEqual([{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }, { displayName: highlightName, value: "50" }]);
            });
            //validate tooltip that tooltip info doesn't change if data and category labels are on and off 
            it('on/off data lables - tooltip validation', function () {
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, 100, 150],
                            }, {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                            }]),
                    },
                    metadata: null,
                };
                var tooltipInfo1 = [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($200)" }];
                var tooltipInfo2 = [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-300" }];
                var tooltipInfo3 = [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$100" }];
                var tooltipInfo4 = [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "300" }];
                var tooltipInfo5 = [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$150" }];
                var tooltipInfo6 = [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "-50" }];
                var actualData = DonutChart.converter(dataView, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                expect(actualData.dataPoints[3].data.tooltipInfo).toEqual(tooltipInfo4);
                expect(actualData.dataPoints[4].data.tooltipInfo).toEqual(tooltipInfo5);
                expect(actualData.dataPoints[5].data.tooltipInfo).toEqual(tooltipInfo6);
                //data labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: true },
                    categoryLabels: { show: false }
                };
                actualData = DonutChart.converter(dataView, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                //data labels and category labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: true },
                    categoryLabels: { show: true }
                };
                actualData = DonutChart.converter(dataView, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
                //data labels off and category labels are on
                dataViewMetadata1Category2Measure.objects = {
                    labels: { show: false },
                    categoryLabels: { show: true }
                };
                actualData = DonutChart.converter(dataView, donutColors);
                expect(actualData.dataPoints[0].data.tooltipInfo).toEqual(tooltipInfo1);
                expect(actualData.dataPoints[1].data.tooltipInfo).toEqual(tooltipInfo2);
                expect(actualData.dataPoints[2].data.tooltipInfo).toEqual(tooltipInfo3);
            });
            it('with highlights that overflow', function () {
                // categorical, no slicing - with OverFlow
                var dataView = {
                    categorical: {
                        categories: [{
                                source: dataViewMetadata1Category2Measure.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: categoryIdentities,
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[1],
                                values: [-200, null, 150],
                                highlights: [-100, null, 250 /* NOTE: this highlight value > the corresponding non-highlight value */],
                            }, {
                                source: dataViewMetadata1Category2MeasureWithFormat.columns[2],
                                values: [-300, 300, -50],
                                highlights: [-150, 75, 50],
                            }]),
                    },
                    metadata: null,
                };
                var actualData = DonutChart.converter(dataView, donutColors);
                var categoryColumnId = powerbi.data.SQExprShortSerializer.serializeArray(dataView.categorical.categories[0].identityFields);
                var sliceColors = [
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('a').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('b').value,
                    donutColors.getColorScaleByKey(categoryColumnId).getColor('c').value,
                ];
                var highlightName = powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                var expectSlices = [
                    {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                        measure: -100,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'col2',
                        value: 0.16,
                        highlightRatio: 1.0,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "($100)" }, { displayName: highlightName, value: "($100)" }],
                        color: sliceColors[0],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col3'),
                        measure: -150,
                        measureFormat: undefined,
                        label: 'col3',
                        value: 0.24,
                        highlightRatio: 1.0,
                        index: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col3", value: "-150" }, { displayName: highlightName, value: "-150" }],
                        color: sliceColors[0],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                        label: 'col2',
                        measure: 0,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        value: 0.0,
                        highlightRatio: 1.0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "$0" }],
                        color: sliceColors[1],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col3'),
                        label: 'col3',
                        measure: 75,
                        measureFormat: undefined,
                        value: 0.12,
                        highlightRatio: 1.0,
                        index: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col3", value: "75" }, { displayName: highlightName, value: "75" }],
                        color: sliceColors[1],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2'),
                        measure: 250,
                        measureFormat: "\$#,0;(\$#,0);\$#,0",
                        label: 'col2',
                        value: 0.4,
                        highlightRatio: 1.0,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "$250" }, { displayName: highlightName, value: "$250" }],
                        color: sliceColors[2],
                        labelFormatString: undefined,
                    }, {
                        identity: SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col3'),
                        measure: 50,
                        measureFormat: undefined,
                        label: 'col3',
                        value: 0.08,
                        highlightRatio: 1.0,
                        index: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col3", value: "50" }, { displayName: highlightName, value: "50" }],
                        color: sliceColors[2],
                        labelFormatString: undefined,
                    }].map(buildDataPoint);
                expect(actualData.dataPoints.map(function (value) { return value.data; })).toEqual(expectSlices);
            });
        });
        it('non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', queryName: 'a', isMeasure: true },
                    { displayName: 'b', queryName: 'b', isMeasure: true },
                    { displayName: 'c', queryName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3],
                        }
                    ])
                }
            };
            var actualData = DonutChart.converter(dataView, donutColors);
            expect(actualData.dataPoints[0].data.tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(actualData.dataPoints[1].data.tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(actualData.dataPoints[2].data.tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
        function buildDataPoint(data) {
            return {
                identity: data.identity,
                measure: data.measure,
                measureFormat: data.measureFormat,
                percentage: data.value,
                index: data.index,
                label: data.label,
                selected: false,
                highlightRatio: data.highlightRatio || 0,
                tooltipInfo: data.tooltipInfo,
                color: data.color,
                labelColor: powerbi.visuals.dataLabelUtils.defaultLabelColor,
                labelFormatString: data.labelFormatString,
            };
        }
    });
    function pieChartDomValidation(interactiveChart, hasLegendObject) {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        if (hasLegendObject) {
            dataViewMetadataTwoColumn.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadataTwoColumn.objects = undefined;
        }
        var dataViewMetadata1Category2Measure = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
                { displayName: 'col3', queryName: 'col3', isMeasure: true }]
        };
        if (hasLegendObject) {
            dataViewMetadata1Category2Measure.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadata1Category2Measure.objects = undefined;
        }
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            if (interactiveChart)
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('pieChart').create();
            else
                v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: interactiveChart, selection: true },
                animation: { transitionImmediate: true }
            });
        });
        it('pie chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart dom validation with partial highlights', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [50, 0, 300],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                var dimmedOpacity = interactiveChart ? 0.6 : powerbi.visuals.ColumnUtil.DimmedOpacity;
                var slices = $('.donutChart .slice');
                expect(slices.length).toBe(3);
                slices.each(function (i, element) {
                    return expect(parseFloat($(element).css('fill-opacity'))).toBeCloseTo(dimmedOpacity, 0);
                });
                var highlightSlices = $('.donutChart .slice-highlight');
                expect(highlightSlices.length).toBe(3);
                highlightSlices.each(function (i, element) {
                    return expect(parseFloat($(element).css('fill-opacity'))).toBeCloseTo(powerbi.visuals.ColumnUtil.DefaultOpacity, 2);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart should clear dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart)
                    expect($('.legend-item').length).toBe(3);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: [],
                                        identity: [],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataTwoColumn.columns[1],
                                        values: [],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.donutChart')).toBeInDOM();
                    expect($('.donutChart .slice').length).toBe(0);
                    if (interactiveChart)
                        expect($('.legend-item').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart dom validation with slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata1Category2Measure,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata1Category2Measure.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata1Category2Measure.columns[1],
                                    values: [200, 100, 150]
                                }, {
                                    source: dataViewMetadata1Category2Measure.columns[2],
                                    values: [300, 200, 50]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(6);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart dom validation with normal slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [300, 300, 400],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var svg = $('.donutChart');
                expect(svg).toBeInDOM();
                // Disabling test due to instability in test infrastructure.
                //expect($('.donutChart polyline').filter(function () {
                //       return $(this).css('opacity') === '0.5'
                //    }).length).toBe(3);
                //expect(svg.attr('height')).toBe(initialHeight);
                //expect(svg.attr('width')).toBe(initialWidth);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart label dom validation with thin slices', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [5, 990, 5],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // lines are not present on interactive legend mode, and currently if regular legend is on we hide labels
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').length).toBe(3);
                }
                done();
            }, powerbitests.DefaultWaitForRender * 2);
        });
        it('pie chart with duplicate labels dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'abc', 'abc'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(3);
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').length).toBe(3);
                    expect($('.donutChart .labels text').length).toBe(3);
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart labels visibility after resize', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            v.onResizing({ height: 600, width: 600 });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart .labels text').length).toBe(3);
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart dom validation with very long labels', function (done) {
            //make sure category labels on
            var dataViewMetadataTwoColumnLabels = powerbi.Prototype.inherit(dataViewMetadataTwoColumn);
            dataViewMetadataTwoColumnLabels.objects = { categoryLabels: { show: true }, labels: { show: false } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumnLabels,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumnLabels.columns[0],
                                    values: ['John Domo Who lives far far away', 'Delta Force of the 56th Battalion', 'Jean Tablau from the silicon valley'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumnLabels.columns[1],
                                    values: [300, 300, 400],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                var labels = $('.labels').find('text');
                for (var i = 0; i < labels.length; i++) {
                    var text = $(labels[i]).text().substr(-3);
                    expect(text).toEqual('...');
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart culling invisible slices validation', function (done) {
            //spyOn(hostServices, 'setWarnings').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 50, 0.000001],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                expect($('.donutChart .slice').length).toBe(2);
                if (!interactiveChart)
                    expect(hostServices.setWarnings).toHaveBeenCalledWith([new powerbi.visuals.GeometryCulledWarning()]);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart opacity validation with overlapping slices', function (done) {
            dataViewMetadataTwoColumn.objects = {
                labels: { show: false },
                categoryLabels: { show: true }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'def', 'ghi', 'jkl'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c'), powerbitests.mocks.dataViewScopeIdentity('d')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [1, 1, 5, 90],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // lines are not present on interactive legend mode, and currently if regular legend is on we hide labels
                if (!interactiveChart && !hasLegendObject) {
                    expect($('.donutChart polyline').filter(function () {
                        return $(this).css('opacity') === '0.5';
                    }).length).toBe(2);
                    expect($('.donutChart text').length).toBe(2);
                }
                done();
            }, powerbitests.DefaultWaitForRender * 2);
        });
        it('pie chart radius calculation validation', function (done) {
            // spy on calculateRadius() method
            var pieChart = v;
            spyOn(pieChart, 'calculateRadius').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['abc', 'def', 'ghi', 'jkl'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c'), powerbitests.mocks.dataViewScopeIdentity('d')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [2, 3, 4, 90],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.donutChart')).toBeInDOM();
                // verify the calculateRadius() was called during the rendering on the visual 
                expect(pieChart.calculateRadius).toHaveBeenCalled();
                // call calculateRadius() and test for the result, based on whether the chart is interactive or not
                var radiusResult = pieChart.calculateRadius();
                var height = $('.donutChart').height();
                var width = $('.donutChart').width();
                var widthOrHeight = Math.min(width, height);
                var hw = height / width;
                var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                var expectedRadius = interactiveChart ? widthOrHeight / 2 : widthOrHeight / denom;
                expect(radiusResult).toBeCloseTo(expectedRadius, 0);
                done();
            }, powerbitests.DefaultWaitForRender * 2);
        });
        it('pie chart slice select', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            var slices = $('.donutChart .slice');
            var sliceToClickIndex = 1;
            var sliceToClick = $(slices[sliceToClickIndex]);
            var otherSlices = slices.not(sliceToClick);
            var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
            slices.each(function () {
                expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
            });
            var pieChart = v;
            if (interactiveChart) {
                var interactivityState = pieChart.interactivityState;
                var pieLegend = interactivityState.interactiveLegend;
                spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
                spyOn(pieLegend, 'updateLegend').and.callThrough();
            }
            // Click the first slice
            sliceToClick.d3Click();
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart) {
                    expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(sliceToClickIndex);
                    expect(pieLegend.updateLegend).toHaveBeenCalledWith(sliceToClickIndex);
                }
                else {
                    expect(parseFloat(sliceToClick.css('fill-opacity'))).toBe(1);
                    otherSlices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                    });
                    // Legend
                    if (renderLegend) {
                        expect($('.legend .item').length).toBe(3);
                        var icons = $('.legend .icon.tall');
                        expect(icons[sliceToClickIndex].style.backgroundColor).toBe('rgb(55, 70, 73)');
                        expect(icons[0].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(166, 166, 166)');
                    }
                }
                // Click the background
                var clearCatcher = $('.clearCatcher');
                clearCatcher.d3Click();
                setTimeout(function () {
                    slices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
                    });
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart selecting a slice triggers select', function () {
            if (interactiveChart) {
                // not applicable to interactive charts
                expect($('.donutChart')).toBeInDOM();
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: identities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            var onSelectSpy = spyOn(hostServices, 'onSelect');
            var slices = $('.donutChart .slice');
            var sliceToClick = 1;
            $(slices[sliceToClick]).d3Click();
            expect(onSelectSpy).toHaveBeenCalled();
            expect(onSelectSpy.calls.argsFor(0)[0].data[0]).toEqual({ data: [identities[sliceToClick]] });
        });
        it('pie chart highlighted slice select', function (done) {
            if (interactiveChart) {
                // not applicable to interactive charts
                expect($('.donutChart')).toBeInDOM();
                done();
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: identities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [50, 100, 350],
                                }])
                        }
                    }]
            });
            var slices = $('.donutChart .slice');
            var sliceToClickIndex = 1;
            var sliceToClick = $(slices[sliceToClickIndex]);
            var otherSlices = slices.not(sliceToClick);
            // Click the first slice
            sliceToClick.d3Click();
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                expect(parseFloat(sliceToClick.css('fill-opacity'))).toBe(1);
                otherSlices.each(function () {
                    expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart selecting a highlighted slice triggers select', function () {
            if (interactiveChart) {
                // not applicable to interactive charts
                expect($('.donutChart')).toBeInDOM();
                return;
            }
            var identities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: identities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [50, 100, 350],
                                }])
                        }
                    }]
            });
            var onSelectSpy = spyOn(hostServices, 'onSelect');
            var slices = $('.donutChart .slice-highlight');
            var sliceToClick = 1;
            $(slices[sliceToClick]).d3Click();
            expect(onSelectSpy).toHaveBeenCalled();
            expect(onSelectSpy.calls.argsFor(0)[0].data[0]).toEqual({ data: [identities[sliceToClick]] });
        });
        it('pie chart slice multi-select', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
            var slices = $('.donutChart .slice');
            var slicesToClickIndex = [1, 2];
            var slicesToClick = $(slices).slice(1, 3);
            var otherSlices = slices.not(slicesToClick);
            var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
            slices.each(function () {
                expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
            });
            var pieChart = v;
            if (interactiveChart) {
                var interactivityState = pieChart.interactivityState;
                var pieLegend = interactivityState.interactiveLegend;
                spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
                spyOn(pieLegend, 'updateLegend').and.callThrough();
            }
            // Click the first slice, then the second with ctrl key
            slicesToClick.eq(0).d3Click();
            slicesToClick.eq(1).d3Click(0, 0, powerbitests.helpers.ClickEventType.CtrlKey);
            setTimeout(function () {
                expect($('.donutChart .slice').length).toBe(3);
                if (interactiveChart) {
                    slicesToClickIndex.forEach(function (i) {
                        expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(i);
                        expect(pieLegend.updateLegend).toHaveBeenCalledWith(i);
                    });
                }
                else {
                    otherSlices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBeLessThan(1);
                    });
                    // Legend
                    if (renderLegend) {
                        expect($('.legend .item').length).toBe(3);
                        var icons = $('.legend .icon.tall');
                        expect(icons[0].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[1].style.backgroundColor).toBe('rgb(157, 73, 140)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(187, 203, 80)');
                        var labels = $('.labels').find('text');
                        expect($(labels[0]).css('opacity')).toBe('0');
                        expect($(labels[1]).css('opacity')).toBe('0');
                        expect($(labels[2]).css('opacity')).toBe('0');
                    }
                    else {
                        expect($('.labels').find('text').length).toBe(3);
                    }
                }
                // Click the background
                var clearCatcher = $('.clearCatcher');
                clearCatcher.d3Click();
                setTimeout(function () {
                    slices.each(function () {
                        expect(parseFloat($(this).css('fill-opacity'))).toBe(1);
                    });
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart legend interactivity', function () {
            expect($('.donutChart')).toBeInDOM();
            if (!interactiveChart) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataTwoColumn,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataTwoColumn.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataTwoColumn.columns[1],
                                        values: [100, 200, 700],
                                    }])
                            }
                        }]
                });
                // click on legend item
                var renderLegend = dataViewMetadataTwoColumn.objects && dataViewMetadataTwoColumn.objects['legend'];
                if (renderLegend) {
                    var icons = $('.legend .icon.tall');
                    var slices = $('.donutChart .slice');
                    icons.first().d3Click(0, 0);
                    setTimeout(function () {
                        expect(icons[0].style.backgroundColor).toBe('rgb(1, 184, 170)');
                        expect(icons[1].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(icons[2].style.backgroundColor).toBe('rgb(166, 166, 166)');
                        expect(parseFloat(slices[0].style.fillOpacity)).toBe(1);
                        expect(parseFloat(slices[1].style.fillOpacity)).toBeLessThan(1);
                        expect(parseFloat(slices[2].style.fillOpacity)).toBeLessThan(1);
                    }, powerbitests.DefaultWaitForRender * 2);
                }
            }
        });
        if (hasLegendObject) {
            it('legend formatting', function (done) {
                var dataView = {
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ['a', 'b', 'c'],
                                identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadataTwoColumn.columns[1],
                                values: [100, 200, 700],
                            }])
                    }
                };
                dataView.metadata.objects = { legend: { show: true } };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.donutChart')).toBeInDOM();
                    expect($('.donutChart .slice').length).toBe(3);
                    if (hasLegendObject) {
                        expect($('.legend').attr('orientation')).toBe(LegendPosition.Top.toString());
                    }
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.donutChart')).toBeInDOM();
                        expect($('.donutChart .slice').length).toBe(3);
                        if (hasLegendObject) {
                            expect($('.legend').attr('orientation')).toBe(LegendPosition.Right.toString());
                        }
                        //set title
                        var testTitle = 'Test Title';
                        dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.donutChart')).toBeInDOM();
                            if (hasLegendObject) {
                                expect($('.legend').attr('orientation')).toBe(LegendPosition.Right.toString());
                                expect($('.legendTitle').text()).toBe(testTitle);
                            }
                            //hide legend
                            dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.donutChart')).toBeInDOM();
                                if (hasLegendObject) {
                                    expect($('.legend').attr('orientation')).toBe(LegendPosition.None.toString());
                                }
                                done();
                            }, powerbitests.DefaultWaitForRender);
                        }, powerbitests.DefaultWaitForRender);
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
        }
    }
    describe("PieChart DOM validation", function () { return pieChartDomValidation(false, false); });
    describe("PieChart DOM validation - with legend", function () { return pieChartDomValidation(false, true); });
    describe("Interactive PieChart DOM validation", function () { return pieChartDomValidation(true, false); });
    describe("Pie Chart Interactivity", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: true },
                animation: { transitionImmediate: true },
            });
            var dataViewMetadataTwoColumnLabels = powerbi.Prototype.inherit(dataViewMetadataTwoColumn);
            dataViewMetadataTwoColumnLabels.objects = { categoryLabels: { show: true }, labels: { show: false } };
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataTwoColumnLabels,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumnLabels.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumnLabels.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            });
        });
        it('legend structure', function (done) {
            setTimeout(function () {
                expect($('[data-legend-index=0]>.category').text()).toBe("a");
                expect($('[data-legend-index=0]>.value').text()).toBe("100");
                expect(ColorConvertor($('[data-legend-index=0]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(0).css('fill')));
                expect($('[data-legend-index=1]>.category').text()).toBe("b");
                expect($('[data-legend-index=1]>.value').text()).toBe("200");
                expect(ColorConvertor($('[data-legend-index=1]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(1).css('fill')));
                expect($('[data-legend-index=2]>.category').text()).toBe("c");
                expect($('[data-legend-index=2]>.value').text()).toBe("700");
                expect(ColorConvertor($('[data-legend-index=2]>.percentage').css('color'))).toBe(ColorConvertor($('.slice').eq(2).css('fill')));
                expect($('.donutLegend').length).toBe(1);
                expect($('.legend-item').length).toBe(3);
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('slice drag', function (done) {
            function setD3Event(x, y) {
                var event = document.createEvent('MouseEvents');
                event.sourceEvent = {
                    type: 'mouseEvent',
                    pageX: x,
                    pageY: y,
                    stopPropagation: function () { },
                };
                d3.event = event;
            }
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            spyOn(powerbi.visuals.SVGUtil, 'translateAndRotate');
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieChart, 'getAngleFromDragEvent').and.callThrough();
            // simulate a drag gesture from below the center of the donut to it's upper part, 180 degrees drag.
            var centerCoordinates = interactivityState.donutCenter;
            var dragFromCoordinates = { x: centerCoordinates.x, y: centerCoordinates.y - 20 };
            var dragToCoordinates = { x: centerCoordinates.x, y: centerCoordinates.y + 20 };
            var currentRotation = pieChart.interactivityState.currentRotate;
            // simulate dragging using setting d3.event
            setD3Event(dragFromCoordinates.x, dragFromCoordinates.y);
            pieChart.interactiveDragStart(); // call dragStart
            setD3Event(dragToCoordinates.x, dragToCoordinates.y);
            pieChart.interactiveDragMove(); // call dragMove
            pieChart.interactiveDragEnd(); // complete the drag - call dragEnd
            expect(pieChart.getAngleFromDragEvent.calls.count()).toBe(2); // angle should have been calculated twice (first for dragstart and second for dragEnd)
            expect(powerbi.visuals.SVGUtil.translateAndRotate.calls.first().args[4]).toBe(currentRotation + 180); // first call to rotate (mathches dragMove) should rotate the chart by 180 degrees
            expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(2);
            done();
        });
        function swipeTest(swipeLeft, expectedSliceIndex, done) {
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            var pieLegend = interactivityState.interactiveLegend;
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieLegend, 'updateLegend').and.callThrough();
            // drag on the legend
            pieLegend.dragLegend(swipeLeft);
            setTimeout(function () {
                expect(pieChart.setInteractiveChosenSlice).toHaveBeenCalledWith(expectedSliceIndex);
                expect(pieLegend.updateLegend).toHaveBeenCalledWith(expectedSliceIndex);
                expect($('.donutChart').length).toBe(1);
                expect($('.donutLegend').length).toBe(1);
                expect($('.legend-item').length).toBe(3);
                expect($('.donutChart .slice').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        }
        it('legend items swipe right', function (done) { return swipeTest(false, 2, done); }); // swiping right - exepecting to get the last slice index
        it('legend items swipe left', function (done) { return swipeTest(true, 1, done); }); // swiping left - exepecting to get the second slice index
        function rotateValidation(swipeLeft, done) {
            var pieChart = v;
            var interactivityState = pieChart.interactivityState;
            var pieLegend = interactivityState.interactiveLegend;
            spyOn(pieChart, 'setInteractiveChosenSlice').and.callThrough();
            spyOn(pieLegend, 'updateLegend').and.callThrough();
            // verify the order of the legend items, and their rotation.
            // the middle should be item 0, to the right, item 1 and to the left of item 0 is item 2.
            // meaning, DOM elements order is item2 -> item0 -> item1
            var legendItems = $('.legend-item');
            expect(legendItems.length).toEqual(3);
            expect(legendItems.eq(0).attr('data-legend-index')).toEqual('2');
            expect(legendItems.eq(1).attr('data-legend-index')).toEqual('0');
            expect(legendItems.eq(2).attr('data-legend-index')).toEqual('1');
            // drag on the legend
            pieLegend.dragLegend(swipeLeft);
            setTimeout(function () {
                // items should be rotated
                var rotatedLegendItems = $('.legend-item');
                if (swipeLeft) {
                    expect(rotatedLegendItems.eq(0).attr('data-legend-index')).toBe('0');
                    expect(rotatedLegendItems.eq(1).attr('data-legend-index')).toBe('1');
                    expect(rotatedLegendItems.eq(2).attr('data-legend-index')).toBe('2');
                }
                else {
                    expect(rotatedLegendItems.eq(0).attr('data-legend-index')).toBe('1');
                    expect(rotatedLegendItems.eq(1).attr('data-legend-index')).toBe('2');
                    expect(rotatedLegendItems.eq(2).attr('data-legend-index')).toBe('0');
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        }
        it('legend items are rotated correctly when swiping right', function (done) { return rotateValidation(false, done); });
        it('legend items are rotated correctly when swiping left', function (done) { return rotateValidation(true, done); });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('donutChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check enumeration for categorical', function (done) {
            dataViewMetadataTwoColumn.objects = {
                labels: { show: false },
                categoryLabels: { show: true }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[0].displayName).toEqual('a');
            expect(points[0].properties['fill']).toBeDefined();
            expect(points[1].displayName).toEqual('b');
            expect(points[1].properties['fill']).toBeDefined();
            done();
        });
        it('Check enumeration for category and series', function (done) {
            var dataViewMetadata1Category2Measure = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true }]
            };
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')];
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata1Category2Measure.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata1Category2Measure.columns[1],
                                    values: [-200, null, 150],
                                    identity: powerbitests.mocks.dataViewScopeIdentity('foo'),
                                }, {
                                    source: dataViewMetadata1Category2Measure.columns[2],
                                    values: [-300, 300, -50],
                                    identity: powerbitests.mocks.dataViewScopeIdentity('bar'),
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[0].displayName).toEqual('a');
            expect(points[0].properties['fill']).toBeDefined();
            expect(points[1].displayName).toEqual('b');
            expect(points[1].properties['fill']).toBeDefined();
            done();
        });
        it('Check datapoints enumeration after hiding legend', function (done) {
            var dataView = {
                metadata: dataViewMetadataTwoColumn,
                categorical: {
                    categories: [{
                            source: dataViewMetadataTwoColumn.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataTwoColumn.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            dataView.metadata.objects = { legend: { show: false } };
            v.onDataChanged({
                dataViews: [dataView]
            });
            setTimeout(function () {
                // Check legend is hidden
                expect($('.legend').attr('orientation')).toBe(LegendPosition.None.toString());
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Pie Chart Web Animation", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('pieChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { selection: true },
                animation: { transitionImmediate: true }
            });
        });
        it('pie chart partial highlight animations', function (done) {
            var dataViewsNoHighlights = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            };
            var dataViewsHighlightsA = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [50, 26, 560],
                                }])
                        }
                    }]
            };
            var dataViewsHighlightsB = {
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [20, 126, 60],
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataViewsNoHighlights);
            setTimeout(function () {
                var svgInit = $('.donutChart');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(dataViewsHighlightsA);
                v.onDataChanged(dataViewsHighlightsB);
                v.onDataChanged(dataViewsNoHighlights);
                expect(animator).toBeTruthy();
                expect(animator.animate).toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.donutChart');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('pie chart partial highlight animations - suppressAnimations', function (done) {
            var dataViewsNoHighlights = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                }])
                        }
                    }]
            };
            var dataViewsHighlightsA = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [50, 26, 560],
                                }])
                        }
                    }]
            };
            var dataViewsHighlightsB = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataTwoColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataTwoColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a'), powerbitests.mocks.dataViewScopeIdentity('b'), powerbitests.mocks.dataViewScopeIdentity('c')],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataTwoColumn.columns[1],
                                    values: [100, 200, 700],
                                    highlights: [20, 126, 60],
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataViewsNoHighlights);
            setTimeout(function () {
                var svgInit = $('.donutChart');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(dataViewsHighlightsA);
                v.onDataChanged(dataViewsHighlightsB);
                v.onDataChanged(dataViewsNoHighlights);
                expect(animator).toBeTruthy();
                expect(animator.animate).not.toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.donutChart');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var FunnelChart = powerbi.visuals.FunnelChart;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var EventType = powerbitests.helpers.ClickEventType;
    var SelectionId = powerbi.visuals.SelectionId;
    var ColorConvertor = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    var minHeightFunnelCategoryLabelsVisible = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible;
    var categoryLabelsVisibleGreaterThanMinHeight = minHeightFunnelCategoryLabelsVisible + 1;
    var categoryLabelsSmallerThanMinHeight = minHeightFunnelCategoryLabelsVisible - 1;
    var categoryLabelsVisibleGreaterThanMinHeightString = categoryLabelsVisibleGreaterThanMinHeight.toString();
    var categoryLabelsVisibleSmallerThanMinHeightString = categoryLabelsSmallerThanMinHeight.toString();
    var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
    var defaultInsideLabelColor = '#ffffff';
    powerbitests.mocks.setLocale();
    describe("FunnelChart", function () {
        it('FunnelChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').capabilities).toBe(powerbi.visuals.funnelChartCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.funnelChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.funnelChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.funnelChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.funnelChartCapabilities.objects)).toEqual(powerbi.visuals.funnelChartProps.general.formatString);
        });
    });
    describe("FunnelChart Dataview Validation", function () {
        var colors;
        beforeEach(function () {
            colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        });
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', queryName: 'col1' },
                { displayName: 'col2', queryName: 'col2', isMeasure: true },
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'p' });
        it('Check explicit color is applied', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                            objects: [
                                { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                                { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                                { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                            ]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            expect(actualData.slices[0].color).toBe("#FF0000");
            expect(actualData.slices[0].labelFill).toBe(labelColor);
            expect(actualData.slices[1].color).toBe("#00FF00");
            expect(actualData.slices[1].labelFill).toBe(labelColor);
            expect(actualData.slices[2].color).toBe("#0000FF");
            expect(actualData.slices[2].labelFill).toBe(labelColor);
        });
        it('Check default color is applied', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, colors, defaultDataPointColor);
            actualData.slices.forEach(function (slice) {
                expect(slice.color).toEqual(defaultDataPointColor);
                expect(slice.labelFill).toEqual(labelColor);
            });
        });
        it('Check multi-measures and custom colors', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, objects: { dataPoint: { fill: { solid: { color: "#FF0000" } } } } },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, objects: { dataPoint: { fill: { solid: { color: "#00FF00" } } } } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[0],
                            values: [100],
                        }, {
                            source: dataViewMetadata.columns[1],
                            values: [300],
                        },
                    ])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("col2"),
                SelectionId.createWithMeasure("col3")];
            var expectedData = {
                slices: [
                    {
                        value: 100,
                        label: 'col2',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col2", value: "100" }],
                        color: "#FF0000",
                        labelFill: labelColor,
                    }, {
                        value: 300,
                        label: 'col3',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col2", value: "300" }],
                        color: "#00FF00",
                        labelFill: labelColor,
                    }],
                categoryLabels: ['col2', 'col3'],
                valuesMetadata: [dataViewMetadata.columns[0], dataViewMetadata.columns[1]],
                hasHighlights: false,
                highlightsOverflow: false,
                canShowDataLabels: true,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Check converter with category and single measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[2], 'col2')];
            var sliceColor = colors.getColorByIndex(0).value;
            var expectedData = {
                slices: [
                    {
                        value: 100,
                        label: 'a',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "100" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }, {
                        value: 200,
                        label: 'b',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "200" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }, {
                        value: 700,
                        label: 'c',
                        identity: selectionIds[2],
                        key: selectionIds[2].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 2,
                        tooltipInfo: [{ displayName: "col1", value: "c" }, { displayName: "col2", value: "700" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }],
                categoryLabels: ['a', 'b', 'c'],
                valuesMetadata: [dataViewMetadata.columns[1]],
                hasHighlights: false,
                highlightsOverflow: false,
                canShowDataLabels: true,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Validate highlighted tooltip', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            objects: [
                                { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                                { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                                { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                            ]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [0, 140, 420],
                        }])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, colors, defaultDataPointColor);
            //first tooltip is regular because highlighted value is 0
            expect(actualData.slices[0].tooltipInfo).toEqual([{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }]);
            expect(actualData.slices[1].tooltipInfo).toEqual([{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }]);
            //tooltips with highlighted value
            expect(actualData.slices[2].tooltipInfo).toEqual([{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(actualData.slices[3].tooltipInfo).toEqual([{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(actualData.slices[4].tooltipInfo).toEqual([{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "420" }]);
            expect(actualData.slices[5].tooltipInfo).toEqual([{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "420" }]);
        });
        it('Check converter with multi-category and multi-measures', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
            ];
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['a', 'b'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200],
                            subtotal: 300,
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [300, 500],
                            subtotal: 800,
                        },
                    ])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[0], 'col2'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[1], 'col2'),
            ];
            var sliceColor = colors.getColorByIndex(0).value;
            var expectedData = {
                slices: [
                    {
                        value: 400,
                        label: 'a',
                        identity: selectionIds[0],
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        key: selectionIds[0].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "a" }, { displayName: "col2", value: "400" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }, {
                        value: 700,
                        label: 'b',
                        identity: selectionIds[1],
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        key: selectionIds[1].getKey(),
                        tooltipInfo: [{ displayName: "col1", value: "b" }, { displayName: "col2", value: "700" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }],
                categoryLabels: ['a', 'b'],
                valuesMetadata: [dataViewMetadata.columns[1], dataViewMetadata.columns[2]],
                hasHighlights: false,
                highlightsOverflow: false,
                canShowDataLabels: true,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('Check converter with no category and multi-measures', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 300],
                            subtotal: 600,
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [300, 200, 100],
                            subtotal: 600,
                        },
                    ])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            var selectionIds = [
                SelectionId.createWithMeasure("col2"),
                SelectionId.createWithMeasure("col3")];
            var sliceColor = colors.getColorByIndex(0).value;
            var expectedData = {
                slices: [
                    {
                        value: 600,
                        label: 'col2',
                        identity: selectionIds[0],
                        key: selectionIds[0].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 0,
                        tooltipInfo: [{ displayName: "col2", value: "600" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }, {
                        value: 600,
                        label: 'col3',
                        identity: selectionIds[1],
                        key: selectionIds[1].getKey(),
                        selected: false,
                        categoryOrMeasureIndex: 1,
                        tooltipInfo: [{ displayName: "col2", value: "600" }],
                        color: sliceColor,
                        labelFill: labelColor,
                    }],
                categoryLabels: ['col2', 'col3'],
                valuesMetadata: [dataViewMetadata.columns[1], dataViewMetadata.columns[2]],
                hasHighlights: false,
                highlightsOverflow: false,
                canShowDataLabels: true,
                dataLabelsSettings: powerbi.visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
            };
            expect(actualData).toEqual(expectedData);
        });
        it('non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', queryName: 'a', isMeasure: true },
                    { displayName: 'b', queryName: 'b', isMeasure: true },
                    { displayName: 'c', queryName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1]
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2]
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3]
                        }
                    ])
                }
            };
            var actualData = FunnelChart.converter(dataView, colors);
            expect(actualData.slices[0].tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(actualData.slices[1].tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(actualData.slices[2].tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
    });
    describe("FunnelChart Interactivity", function () {
        var v, element;
        var hostServices;
        var dataViewMetadataCategorySeriesColumns = {
            columns: [
                { displayName: 'Squad', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'Period', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: null, groupName: '201501', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: null, groupName: '201502', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: null, groupName: '201503', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Squad' });
        var DefaultOpacity = "" + FunnelChart.DefaultBarOpacity;
        var DimmedOpacity = "" + FunnelChart.DimmedBarOpacity;
        var interactiveDataViewOptions = {
            dataViews: [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataCategorySeriesColumns.columns[0],
                                values: ['A', 'B'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('a'),
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                            }])
                    }
                }]
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        function getOptionsForValueWarning(values) {
            var interactiveDataViewOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['A', 'B'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: values,
                                    identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                                }])
                        }
                    }]
            };
            return interactiveDataViewOptions;
        }
        it('NaN in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, NaN]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            });
        });
        it('Negative Infinity in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, Number.NEGATIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            });
        });
        it('Positive Infinity in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, Number.POSITIVE_INFINITY]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            });
        });
        it('Out of range value in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, 1e301]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            });
        });
        it('All good in values shows warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarning([110, 120, 300]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            });
        });
        it('funnel chart category select', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                done();
            });
        });
        it('funnel chart category multi-select', function (done) {
            //powerbitests.mocks.setLocale();
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]],
                        }
                    ]
                });
                bars.last().d3Click(0, 0, EventType.CtrlKey);
                //expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]],
                        },
                    ]
                });
                done();
            });
        });
        it('funnel chart external clear', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                v.onClearSelection();
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                done();
            });
        });
        it('funnel chart clear on clearCatcher click', function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var bars = $('.funnelChart .funnelBar');
                spyOn(hostServices, 'onSelect').and.callThrough();
                bars.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]]
                        }
                    ]
                });
                var clearCatcher = $('.clearCatcher');
                clearCatcher.first().d3Click(0, 0);
                expect(bars[0].style.fillOpacity).toBe(DefaultOpacity);
                expect(bars[1].style.fillOpacity).toBe(DefaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            });
        });
    });
    describe("FunnelChart DOM Validation", function () {
        var v, element;
        var translate = 62;
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1' },
                { displayName: 'col2', isMeasure: true, objects: { general: { formatString: '$0' } } },
            ],
            objects: {
                labels: { show: true, labelPrecision: 0 }
            }
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Ensure DOM built', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataView);
                expect($('.funnelChart g').length).toBe(7);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                expect($('.funnelChart .labels').find('text').length).toBe(3);
                expect($('.funnelChart .labels').find('text').first().text()).toBe('$100');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Funnel partial highlight', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataView);
                expect($('.funnelChart g').length).toBe(7);
                expect($('.funnelBar').length).toBe(6);
                expect($('.highlight').length).toBe(3);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeLessThan(+$('.funnelBar')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeGreaterThan(+$('.funnelBar')[0].attributes.getNamedItem('y').value);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Funnel partial highlight with overflow', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [150, 340, 720],
                            subtotal: 1000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataView);
                expect($('.funnelChart g').length).toBe(7);
                expect($('.funnelBar').length).toBe(6);
                expect($('.highlight').length).toBe(3);
                expect(+$('.highlight')[0].attributes.getNamedItem('height').value)
                    .toBeGreaterThan(+$('.funnelBar')[0].attributes.getNamedItem('height').value);
                expect(+$('.highlight')[0].attributes.getNamedItem('y').value)
                    .toBeLessThan(+$('.funnelBar')[0].attributes.getNamedItem('y').value);
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure Max Width is respected', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200],
                            subtotal: 300
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var rect = $('.funnelChart').find('.funnelBar').first();
                expect(rect.attr('width')).toBeLessThan(40);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure Labels that do not fit in the bar are shown outside and are the bar fill color', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { labelPosition: powerbi.labelPosition.insideCenter } };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1000, 2000, 20],
                            subtotal: 3020
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .labels text');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var lastBarHeight = +$('.funnelChart').find('.funnelBar').last().attr('height');
                var lastBarY = +$('.funnelChart').find('.funnelBar').last().attr('y');
                expect(labels.length).toBe(3);
                expect($(labels[0]).attr('x')).toEqual($(labels[1]).attr('x'));
                expect($(labels[1]).attr('x')).not.toEqual($(labels[2]).attr('x'));
                // Check that the first label is inside and white
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(defaultInsideLabelColor);
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // Check that the last label is outside and equal to fill color
                expect(ColorConvertor($(labels[2]).css('fill'))).toEqual(ColorConvertor(labelColor));
                expect($(labels[2]).attr('x')).toBeGreaterThan(lastBarY + lastBarHeight + translate);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure Labels hide when viewport forces bars to be smaller than min height', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                                powerbitests.mocks.dataViewScopeIdentity('Delta Force'),
                                powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                                powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                                powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                                powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 300, 400, 500, 600],
                            subtotal: 2100
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                expect($('.funnelChart g').length).toBe(10);
                expect($('.funnelChart .axis').find('text').length).toBe(6);
                expect($('.funnelChart .labels text').length).toBe(6);
                v.onResizing({ height: 50, width: 100 });
                setTimeout(function () {
                    expect($('.funnelChart g').length).toBe(3); // No 'g' for data labels
                    expect($('.funnelChart .axis').find('text').length).toBe(0);
                    expect($('.funnelChart .labels text').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure Labels show but percent bar hides when adding percent bars would cause labels to hide', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                                powerbitests.mocks.dataViewScopeIdentity('Delta Force'),
                                powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                                powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                                powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                                powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 300, 400, 500, 600],
                            subtotal: 2100
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataView);
                expect($('.funnelChart g').length).toBe(10);
                expect($('.funnelChart .axis').find('text').length).toBe(6);
                expect($('.funnelChart .labels text').length).toBe(6);
                v.onResizing({ height: 100, width: 100 });
                setTimeout(function () {
                    FunnelChartHelpers.validatePercentBars(false, dataView);
                    expect($('.funnelChart g').length).toBe(10);
                    expect($('.funnelChart .axis').find('text').length).toBe(6);
                    expect($('.funnelChart .labels text').length).toBe(6);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure percent bars hide when viewport forces bars to be smaller than min height', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                                powerbitests.mocks.dataViewScopeIdentity('Delta Force'),
                                powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                                powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                                powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                                powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 300, 400, 500, 600],
                            subtotal: 2100
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataView);
                expect($('.funnelChart g').length).toBe(10);
                expect($('.funnelChart .axis').find('text').length).toBe(6);
                expect($('.funnelChart .labels text').length).toBe(6);
                v.onResizing({ height: 50, width: 100 });
                setTimeout(function () {
                    FunnelChartHelpers.validatePercentBars(false, dataView);
                    expect($('.funnelChart g').length).toBe(3); // No 'g' for data labels
                    expect($('.funnelChart .axis').find('text').length).toBe(0);
                    expect($('.funnelChart .labels text').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure percent bars hide when single value data set', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100],
                            subtotal: 100
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(false, dataView);
                expect($('.funnelChart g').length).toBe(5);
                expect($('.funnelChart .axis').find('text').length).toBe(1);
                expect($('.funnelChart .labels text').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Ensure percent bars hide when baseline value is zero', function (done) {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('John Domo'),
                                powerbitests.mocks.dataViewScopeIdentity('Delta Force'),
                                powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                                powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                                powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                                powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [0, 200, 300, 400, 500, 600],
                            subtotal: 2000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(false, dataView);
                expect($('.funnelChart g').length).toBe(10);
                expect($('.funnelChart .axis').find('text').length).toBe(6);
                expect($('.funnelChart .labels text').length).toBe(6);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Default labels validation', function (done) {
            var metadataWithDisplayUnits = $.extend(true, {}, dataViewMetadata);
            metadataWithDisplayUnits.objects = { labels: { labelDisplayUnits: 1000 } };
            var fontSize = '12px';
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadataWithDisplayUnits,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [555, 2000, 20],
                            subtotal: 2575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .labels text');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var lastBarY = +$('.funnelChart').find('.funnelBar').last().attr('y');
                var lastBarHeight = +$('.funnelChart').find('.funnelBar').last().attr('height');
                expect(labels.length).toBe(3);
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(defaultInsideLabelColor);
                expect(ColorConvertor($(labels[2]).css('fill'))).toEqual(labelColor);
                expect($(labels[0]).css('fill-opacity')).toEqual('1');
                expect($(labels[1]).css('fill-opacity')).toEqual('1');
                expect($(labels[2]).css('fill-opacity')).toEqual('1');
                expect($(labels.first().css('font-size')).selector).toBe(fontSize);
                expect($(labels[0]).text()).toEqual('$0.56K');
                // Check that the first label is inside
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // Check that the last label is outside
                expect($(labels[2]).attr('x')).toBeGreaterThan(lastBarY + lastBarHeight);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Validate label colors and positioning', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [2000, 1555, 20],
                            subtotal: 3575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // The funnel bars are rotated 90 degrees, so for the bars, "y" and "height" correspond
                // to what we would think of as the position and size along the x-axis.
                // The funnel data labels are not rotated, so for the labels we need to use "x" and "width".
                var labels = $('.funnelChart .labels text');
                var firstBarY = +$('.funnelChart').find('.funnelBar').first().attr('y');
                var firstBarHeight = +$('.funnelChart').find('.funnelBar').first().attr('height');
                // The first label should be white and should be inside the bar.
                expect($(labels[0]).text()).toEqual('$2K');
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(defaultInsideLabelColor);
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarY + translate);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBarY + firstBarHeight + translate);
                // The third label should be the same as the fill color and should be outside the bar.
                var thirdBarY = +$('.funnelChart').find('.funnelBar').eq(2).attr('y');
                var thirdBarHeight = +$('.funnelChart').find('.funnelBar').eq(2).attr('height');
                //Data labels precision = 0
                expect($(labels[2]).text()).toEqual('$0K');
                expect(ColorConvertor($(labels[2]).css('fill'))).toEqual(ColorConvertor(labelColor));
                expect($(labels[2]).attr('x')).toBeGreaterThan(thirdBarY + thirdBarHeight + translate);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Change labels position validation', function (done) {
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { labelPosition: powerbi.labelPosition.insideBase } };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1000, 2000, 2000],
                            subtotal: 5000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .labels .data-labels');
                var firstBarX = +$('.funnelChart').find('.funnelBar').first().attr('x');
                var firstBarWidth = +$('.funnelChart').find('.funnelBar').first().attr('height');
                var firstBarTranslated = firstBarX - translate;
                var firstBar = firstBarTranslated + firstBarWidth;
                expect(labels.length).toBe(3);
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(ColorConvertor(defaultInsideLabelColor));
                expect(ColorConvertor($(labels[1]).css('fill'))).toEqual(ColorConvertor(defaultInsideLabelColor));
                expect(ColorConvertor($(labels[2]).css('fill'))).toEqual(ColorConvertor(defaultInsideLabelColor));
                //Check that the labels position is inside
                expect($(labels[0]).attr('x')).toBeGreaterThan(firstBarTranslated);
                expect($(labels[0]).attr('x')).toBeLessThan(firstBar);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Change labels color validation', function (done) {
            var color = '#CC0099';
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: {
                    color: { solid: { color: '#CC0099' } },
                }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1555, 2000, 20],
                            subtotal: 3575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .labels text');
                expect(labels.length).toBe(3);
                //inside labels are white
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(ColorConvertor(defaultInsideLabelColor));
                expect(ColorConvertor($(labels[1]).css('fill'))).toEqual(ColorConvertor(defaultInsideLabelColor));
                //outside labels are changed
                expect(ColorConvertor($(labels[2]).css('fill'))).toEqual(ColorConvertor(color.toLowerCase()));
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = { labels: { show: false } };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1555, 2000, 20],
                            subtotal: 3575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var labels = $('.funnelChart .labels text');
                expect(labels.length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Funnel highlighted values - validate labels', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [75, 40, 220],
                            subtotal: 1000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            v.onDataChanged({ dataViews: [dataViewHighlightsA] });
            v.onDataChanged({ dataViews: [dataViewHighlightsB] });
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            setTimeout(function () {
                var labels = $('.funnelChart .labels text');
                expect(labels.length).toBe(3);
                expect(ColorConvertor($(labels[0]).css('fill'))).toEqual(defaultInsideLabelColor);
                expect($(labels[0]).text()).toEqual('$100');
                expect($(labels[1]).text()).toEqual('$200');
                expect($(labels[2]).text()).toEqual('$700');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Funnel highlighted values - validate percent bars', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [75, 40, 220],
                            subtotal: 1000
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataViewNoHighlights);
                v.onDataChanged({ dataViews: [dataViewHighlightsA] });
                setTimeout(function () {
                    FunnelChartHelpers.validatePercentBars(true, dataViewHighlightsA);
                    v.onDataChanged({ dataViews: [dataViewHighlightsB] });
                    setTimeout(function () {
                        FunnelChartHelpers.validatePercentBars(true, dataViewHighlightsB);
                        v.onDataChanged({ dataViews: [dataViewNoHighlights] });
                        setTimeout(function () {
                            FunnelChartHelpers.validatePercentBars(true, dataViewNoHighlights);
                            done();
                        }, powerbitests.DefaultWaitForRender);
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('labels should support display units with no precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1555, 2000, 20],
                            subtotal: 3575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // Commented because TSLINT throws exception on this var: unused variable: 'labels'
                //var labels = $('.funnelChart .labels text');
                expect($('.funnelChart .labels text').first().text()).toBe('$2K');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('labels should support display units with precision', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataViewMetadataWithLabelsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsObject.objects = {
                labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 2 }
            };
            var dataView = {
                metadata: dataViewMetadataWithLabelsObject,
                categorical: {
                    categories: [{
                            source: dataViewMetadataWithLabelsObject.columns[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataWithLabelsObject.columns[1],
                            values: [1555, 2000, 20],
                            subtotal: 3575
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                // Commented because TSLINT throws exception on this var: unused variable: 'labels'
                //var labels = $('.funnelChart .labels text');
                expect($('.funnelChart .labels text').first().text()).toBe('$1.56K');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("funnel chart web animation", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1' },
                { displayName: 'col2' },
                { displayName: 'col3' }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('funnel').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('funnel highlight animation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [75, 40, 220],
                            subtotal: 1000
                        }])
                }
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            v.onDataChanged({ dataViews: [dataViewHighlightsA] });
            v.onDataChanged({ dataViews: [dataViewHighlightsB] });
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            expect(animator).toBeTruthy();
            expect(animator.animate).toHaveBeenCalled();
            done();
        });
        it('funnel highlight animation - percent bars', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [75, 40, 220],
                            subtotal: 1000
                        }])
                }
            };
            var animator = v.animator;
            expect(animator).toBeTruthy();
            var animatorSpy = spyOn(animator, 'animate');
            animatorSpy.and.callThrough();
            v.onDataChanged({ dataViews: [dataViewNoHighlights] });
            expect(animator.animate).toHaveBeenCalled();
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataViewNoHighlights);
                v.onDataChanged({ dataViews: [dataViewHighlightsA] });
                setTimeout(function () {
                    FunnelChartHelpers.validatePercentBars(true, dataViewHighlightsA);
                    v.onDataChanged({ dataViews: [dataViewHighlightsB] });
                    setTimeout(function () {
                        FunnelChartHelpers.validatePercentBars(true, dataViewHighlightsB);
                        v.onDataChanged({ dataViews: [dataViewNoHighlights] });
                        setTimeout(function () {
                            FunnelChartHelpers.validatePercentBars(true, dataViewNoHighlights);
                            expect(animator.animate).toHaveBeenCalled();
                            expect(animatorSpy.calls.count()).toBe(4);
                            done();
                        }, powerbitests.DefaultWaitForRender);
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('funnel highlight animation - suppressAnimations', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewNoHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsA = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [50, 140, 420],
                            subtotal: 1000
                        }])
                }
            };
            var dataViewHighlightsB = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                            highlights: [75, 40, 220],
                            subtotal: 1000
                        }])
                }
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged({ suppressAnimations: true, dataViews: [dataViewNoHighlights] });
            v.onDataChanged({ suppressAnimations: true, dataViews: [dataViewHighlightsA] });
            v.onDataChanged({ suppressAnimations: true, dataViews: [dataViewHighlightsB] });
            v.onDataChanged({ suppressAnimations: true, dataViews: [dataViewNoHighlights] });
            expect(animator).toBeTruthy();
            expect(animator.animate).not.toHaveBeenCalled();
            done();
        });
        it('funnel highlight animation - small viewport forcing small bars also hides category and data labels', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
                powerbitests.mocks.dataViewScopeIdentity('Bugs Bunny'),
                powerbitests.mocks.dataViewScopeIdentity('Mickey Mouse'),
                powerbitests.mocks.dataViewScopeIdentity('Donald Duck'),
                powerbitests.mocks.dataViewScopeIdentity('VRM Jones'),
            ];
            var dataViewHighlights = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau', 'Bugs Bunny', 'Mickey Mouse', 'Donald Duck', 'VRM Jones'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 300, 400, 500, 600, 700],
                            highlights: [50, 140, 220, 386, 418, 563, 610],
                            subtotal: 2800
                        }])
                }
            };
            var animator = v.animator;
            spyOn(animator, 'animate').and.callThrough();
            v.onDataChanged({ dataViews: [dataViewHighlights] });
            expect(animator).toBeTruthy();
            expect(animator.animate).toHaveBeenCalled();
            setTimeout(function () {
                FunnelChartHelpers.validatePercentBars(true, dataViewHighlights);
                expect($('.funnelChart g').length).toBe(11);
                expect($('.funnelChart .axis').find('text').length).toBe(7);
                expect($('.funnelChart .labels text').length).toBe(7);
                v.onResizing({ height: 50, width: 100 });
                setTimeout(function () {
                    FunnelChartHelpers.validatePercentBars(false, dataViewHighlights);
                    expect($('.funnelChart g').length).toBe(3); // No 'g' for data labels
                    expect($('.funnelChart .axis').find('text').length).toBe(0);
                    expect($('.funnelChart .labels text').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Enumerate Objects", function () {
        var visual, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    isMeasure: true
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    isMeasure: true
                }
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            visual = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            visual.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check enumeration: category measure', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("a"),
                powerbitests.mocks.dataViewScopeIdentity("b"),
                powerbitests.mocks.dataViewScopeIdentity("c"),
            ];
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadata.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }])
                        }
                    }]
            };
            visual.onDataChanged(dataChangedOptions);
            var points = visual.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(4);
            expect(points[1].displayName).toBe('a');
            expect(points[1].properties['fill']).toBeDefined();
            expect(points[2].displayName).toBe('b');
            expect(points[2].properties['fill']).toBeDefined();
        });
        it('Check enumeration: multi-measure', function () {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [100]
                                }, {
                                    source: dataViewMetadata.columns[2],
                                    values: [200]
                                }])
                        }
                    }]
            };
            visual.onDataChanged(dataChangedOptions);
            var points = visual.enumerateObjectInstances({ objectName: 'dataPoint' });
            expect(points.length).toBe(3);
            expect(points[1].displayName).toBe('col2');
            expect(points[1].properties['fill']).toBeDefined();
            expect(points[2].displayName).toBe('col3');
            expect(points[2].properties['fill']).toBeDefined();
        });
        it('enumerateObjectInstances - Gradient color', function () {
            var dataColors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var dataViewGradientMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var colors = ["#d9f2fb", "#ff557f", "#b1eab7"];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: colors[0] } } } },
                { dataPoint: { fill: { solid: { color: colors[1] } } } },
                { dataPoint: { fill: { solid: { color: colors[2] } } } }
            ];
            var dataView = {
                metadata: dataViewGradientMetadata,
                categorical: {
                    categories: [{
                            source: dataViewGradientMetadata.columns[0],
                            values: ['a', 'b', 'c'],
                            objects: objectDefinitions
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewGradientMetadata.columns[1],
                            values: [100, 200, 300, 400, 500]
                        }, {
                            source: dataViewGradientMetadata.columns[2],
                            values: [200, 400, 600, 800, 1000]
                        }])
                }
            };
            var defaultDataPointColor = "#00FF00";
            var actualData = FunnelChart.converter(dataView, dataColors, defaultDataPointColor);
            expect(actualData.slices[0].color).toBe(colors[0]);
            expect(actualData.slices[1].color).toBe(colors[1]);
            expect(actualData.slices[2].color).toBe(colors[2]);
        });
    });
    describe('funnel categoryLabels tests', function () {
        it('funnel categoryLabels test with view port categoryLabelsVisibleSmallerThanMinHeight mobile', function (done) {
            FunnelChartHelpers.testCategoryLabels(categoryLabelsVisibleSmallerThanMinHeightString, true);
            setTimeout(function () {
                expect($('.funnelChart .axis').find('text').length).toBe(0);
                done();
            });
        });
        it('funnel categoryLabels test with view port categoryLabelsVisibleGreaterThanDefaultMinHeight mobile', function (done) {
            FunnelChartHelpers.testCategoryLabels(categoryLabelsVisibleGreaterThanMinHeightString, true);
            setTimeout(function () {
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            });
        });
        it('funnel categoryLabels test with view port categoryLabelsVisibleSmallerThanDefaultMinHeight', function (done) {
            FunnelChartHelpers.testCategoryLabels(categoryLabelsVisibleSmallerThanMinHeightString, false);
            setTimeout(function () {
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            });
        });
        it('funnel categoryLabels test with view port categoryLabelsVisibleGreaterThanDefaultMinHeight', function (done) {
            FunnelChartHelpers.testCategoryLabels(categoryLabelsVisibleGreaterThanMinHeightString, false);
            setTimeout(function () {
                expect($('.funnelChart .axis').find('text').length).toBe(3);
                done();
            });
        });
    });
    var FunnelChartHelpers;
    (function (FunnelChartHelpers) {
        function validatePercentValues(dataView) {
            var _this = this;
            var values = dataView.categorical.values[0].values;
            var highlights = dataView.categorical.values[0].highlights;
            var hasHighlights = !!highlights;
            var topPercent = $(FunnelChart.Selectors.percentBar.text.selector)[0].textContent;
            var bottomPercent = $(FunnelChart.Selectors.percentBar.text.selector)[1].textContent;
            [topPercent, bottomPercent].map(function (percent) {
                var validFormat = !!percent.match(_this.PercentBarValueFormatRegex);
                expect(validFormat).toBeTruthy();
                var bottomPercentValue = hasHighlights
                    ? highlights[highlights.length - 1] / highlights[0]
                    : values[values.length - 1] / values[0];
                var bottomPercentText = powerbi.formattingService.formatValue(bottomPercentValue, powerbi.visuals.valueFormatter.getLocalizedString("Percentage1"));
                expect(topPercent).toBe("100%");
                expect(bottomPercent).toBe(bottomPercentText);
            });
        }
        function validatePercentBarComponents(shown) {
            var count = shown ? 2 : 0;
            expect($(FunnelChart.Selectors.percentBar.mainLine.selector).length).toBe(count);
            expect($(FunnelChart.Selectors.percentBar.leftTick.selector).length).toBe(count);
            expect($(FunnelChart.Selectors.percentBar.rightTick.selector).length).toBe(count);
            expect($(FunnelChart.Selectors.percentBar.text.selector).length).toBe(count);
        }
        function validatePercentBars(shown, dataView) {
            validatePercentBarComponents(shown);
            if (shown) {
                validatePercentValues(dataView);
            }
        }
        FunnelChartHelpers.validatePercentBars = validatePercentBars;
        function testCategoryLabels(domSizeString, isMobile) {
            var v, element;
            element = powerbitests.helpers.testDom(domSizeString, domSizeString);
            if (isMobile) {
                v = powerbi.visuals.visualPluginFactory.createMobile().getPlugin('funnel').create();
            }
            else {
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('funnel').create();
            }
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Jean Tablau"),
            ];
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
        }
        FunnelChartHelpers.testCategoryLabels = testCategoryLabels;
    })(FunnelChartHelpers = powerbitests.FunnelChartHelpers || (powerbitests.FunnelChartHelpers = {}));
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var GaugeVisual = powerbi.visuals.Gauge;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var sideNumbersVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightGaugeSideNumbersVisible;
    var sideNumbersVisibleGreaterThanMinHeight = sideNumbersVisibleMinHeight + 1;
    var sideNumbersVisibleSmallerThanMinHeight = sideNumbersVisibleMinHeight - 1;
    var sideNumbersVisibleGreaterThanMinHeightString = sideNumbersVisibleGreaterThanMinHeight.toString();
    var sideNumbersVisibleSmallerThanMinHeightString = sideNumbersVisibleSmallerThanMinHeight.toString();
    var marginsOnSmallViewPort = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.GaugeMarginsOnSmallViewPort;
    var GaugeDataBuilder = (function () {
        function GaugeDataBuilder(pluginName, height, width, isMobile) {
            if (height === void 0) { height = "500"; }
            if (width === void 0) { width = "500"; }
            if (isMobile === void 0) { isMobile = false; }
            this._dataViewMetadata = {
                columns: [
                    {
                        displayName: "col1",
                        roles: { "Y": true },
                        isMeasure: true,
                        objects: { general: { formatString: "$0" } },
                    }, {
                        displayName: "col2",
                        roles: { "MinValue": true },
                        isMeasure: true
                    }, {
                        displayName: "col3",
                        roles: { "MaxValue": true },
                        isMeasure: true
                    }, {
                        displayName: "col4",
                        roles: { "TargetValue": true },
                        isMeasure: true
                    }],
                groups: [],
                measures: [0],
            };
            this._values = [];
            this._isMobile = false;
            this._pluginName = pluginName;
            this._height = height;
            this._width = width;
            this.init();
        }
        Object.defineProperty(GaugeDataBuilder.prototype, "dataViewMetadata", {
            get: function () {
                return this._dataViewMetadata;
            },
            set: function (value) {
                this._dataViewMetadata = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "visual", {
            get: function () {
                return this._visual;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "element", {
            get: function () {
                return this._element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (value) {
                this._height = value;
                this.init();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this.init();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "pluginName", {
            get: function () {
                return this._pluginName;
            },
            set: function (value) {
                this._pluginName = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "hostServices", {
            get: function () {
                return this._hostServices;
            },
            set: function (value) {
                this._hostServices = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "singleValue", {
            get: function () {
                return this._singleValue;
            },
            set: function (value) {
                this._singleValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "categoricalValues", {
            get: function () {
                return this._categoricalValues;
            },
            set: function (value) {
                this._categoricalValues = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (value) {
                this._values = value;
                this.buildCategorialValues();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "isMobile", {
            get: function () {
                return this._isMobile;
            },
            set: function (value) {
                this._isMobile = value;
                this.init();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeDataBuilder.prototype, "dataView", {
            get: function () {
                if (!this._dataView) {
                    this.buildDataView();
                }
                return this._dataView;
            },
            enumerable: true,
            configurable: true
        });
        GaugeDataBuilder.prototype.init = function () {
            this._element = powerbitests.helpers.testDom(this.height, this.width);
            this.buildVisual();
            this._hostServices = powerbitests.mocks.createVisualHostServices();
            this._style = powerbi.visuals.visualStyles.create();
            this.visualInit();
        };
        GaugeDataBuilder.prototype.buildVisual = function () {
            if (this.isMobile) {
                this._visual = powerbi.visuals.visualPluginFactory.createMobile().getPlugin(this.pluginName).create();
            }
            else {
                this._visual = powerbi.visuals.visualPluginFactory.create().getPlugin(this.pluginName).create();
            }
        };
        GaugeDataBuilder.prototype.buildCategorialValues = function () {
            var categorialValues = [];
            for (var i = 0; i < this.values.length; i++) {
                var categorialValue = {
                    source: this.dataViewMetadata.columns[i],
                    values: this.values[i]
                };
                categorialValues.push(categorialValue);
            }
            this._categoricalValues = DataViewTransform.createValueColumns(categorialValues);
        };
        GaugeDataBuilder.prototype.visualInit = function () {
            this.visual.init({
                element: this.element,
                host: this.hostServices,
                style: this.style,
                viewport: {
                    height: this.element.height(),
                    width: this.element.width()
                },
                animation: { transitionImmediate: true }
            });
        };
        GaugeDataBuilder.prototype.buildDataView = function () {
            this._dataView = {
                metadata: this.dataViewMetadata,
                single: { value: this.singleValue },
                categorical: {
                    values: this.categoricalValues
                }
            };
        };
        GaugeDataBuilder.prototype.onDataChanged = function () {
            this.visual.onDataChanged({
                dataViews: [this.dataView]
            });
        };
        return GaugeDataBuilder;
    })();
    var GaugeVisualDataBuilder = (function (_super) {
        __extends(GaugeVisualDataBuilder, _super);
        function GaugeVisualDataBuilder(pluginName) {
            _super.call(this, pluginName);
            this._warningSpy = jasmine.createSpy("warning");
            this.hostServices.setWarnings = this.warningSpy;
            this.initGaugeSpy();
        }
        Object.defineProperty(GaugeVisualDataBuilder.prototype, "gauge", {
            get: function () {
                return this.visual;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GaugeVisualDataBuilder.prototype, "warningSpy", {
            get: function () {
                return this._warningSpy;
            },
            enumerable: true,
            configurable: true
        });
        GaugeVisualDataBuilder.prototype.initGaugeSpy = function () {
            spyOn(this.gauge, "getGaugeVisualProperties").and.callThrough();
            spyOn(this.gauge, "getAnimatedNumberProperties").and.callThrough();
            spyOn(this.gauge, "drawViewPort").and.callThrough();
        };
        GaugeVisualDataBuilder.prototype.onDataChanged = function () {
            this.gauge.onDataChanged({
                dataViews: [this.dataView]
            });
        };
        GaugeVisualDataBuilder.prototype.onResizing = function (height, width) {
            this.gauge.onResizing({
                height: height,
                width: width
            });
        };
        return GaugeVisualDataBuilder;
    })(GaugeDataBuilder);
    describe("Gauge", function () {
        beforeEach(function () {
            powerbitests.mocks.setLocale();
        });
        it("Capabilities should include dataViewMappings", function () {
            expect(GaugeVisual.capabilities.dataViewMappings).toBeDefined();
        });
        it("Capabilities should include dataRoles", function () {
            expect(GaugeVisual.capabilities.dataRoles).toBeDefined();
        });
        it("Capabilities should not suppressDefaultTitle", function () {
            expect(GaugeVisual.capabilities.suppressDefaultTitle).toBeUndefined();
        });
        it("Capabilities should include dataRoles", function () {
            expect(GaugeVisual.capabilities.dataRoles).toBeDefined();
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(GaugeVisual.capabilities.objects)).toEqual(GaugeVisual.formatStringProp);
        });
    });
    describe("Gauge DOM tests", function () {
        var gaugeDataBuilder;
        beforeEach(function () {
            gaugeDataBuilder = new GaugeDataBuilder("gauge");
        });
        it("Ensure min & target dont overlap", function (done) {
            gaugeDataBuilder.singleValue = 10;
            gaugeDataBuilder.values = [[10], [0], [300], [0]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var targetText = $(".targetText");
                var maxLabel = $($(".labelText")[0]);
                expect(targetText.length).toBe(1);
                var xyTarget = { x: targetText.attr("x"), y: targetText.attr("y") };
                var xyMaxlabel = { x: maxLabel.attr("x"), y: maxLabel.attr("y") };
                expect(xyTarget.x).not.toEqual(xyMaxlabel.x);
                expect(xyTarget.y).not.toEqual(xyMaxlabel.y);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Ensure max & target dont overlap", function (done) {
            gaugeDataBuilder.singleValue = 10;
            gaugeDataBuilder.values = [[10], [0], [300], [300]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var targetText = $(".targetText");
                var maxLabel = $($(".labelText")[1]);
                expect(targetText.length).toBe(1);
                var xyTarget = { x: targetText.attr("x"), y: targetText.attr("y") };
                var xyMaxlabel = { x: maxLabel.attr("x"), y: maxLabel.attr("y") };
                expect(xyTarget.x).not.toEqual(xyMaxlabel.x);
                expect(xyTarget.y).not.toEqual(xyMaxlabel.y);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check Gauge DOM", function (done) {
            gaugeDataBuilder.singleValue = 10;
            gaugeDataBuilder.values = [[10], [0], [300], [200]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                // Check Arc Drawn
                var backgroundArc = $(".backgroundArc");
                var foregroundArc = $(".foregroundArc");
                expect(backgroundArc.length).toBe(1);
                expect(backgroundArc.attr("d")).toBeDefined();
                expect(foregroundArc.length).toBe(1);
                expect(foregroundArc.attr("d")).toBeDefined();
                expect($(".mainText").length).toBe(1);
                expect($(".mainText").text()).toEqual("$10");
                var translateString = $(".animatedNumber").attr("transform");
                var xy = SVGUtil.parseTranslateTransform(translateString);
                expect(xy.x).toBeGreaterThan(120);
                expect(xy.y).toBeGreaterThan(220);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("If value less that zero, then scale should be 0-1, but number should show negative value", function (done) {
            gaugeDataBuilder.values = [[-25]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var backgroundArc = $(".backgroundArc");
                var foregroundArc = $(".foregroundArc");
                expect(backgroundArc.length).toBe(1);
                expect(backgroundArc.attr("d")).toBeDefined();
                expect(foregroundArc.length).toBe(1);
                expect(foregroundArc.attr("d")).toBeDefined();
                var labels = $(".labelText");
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual("$0");
                expect($(labels[1]).text()).toEqual("$1");
                expect($(".mainText").length).toBe(1);
                expect($(".mainText").text()).toEqual("-$25");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Check Gauge DOM on Style Changed", function (done) {
            gaugeDataBuilder.singleValue = 10;
            gaugeDataBuilder.values = [[10], [0], [500], [200]];
            gaugeDataBuilder.onDataChanged();
            var dataColors = new powerbi.visuals.DataColorPalette();
            gaugeDataBuilder.visual.onStyleChanged({
                titleText: {
                    color: { value: "rgba(51,51,51,1)" }
                },
                subTitleText: {
                    color: { value: "rgba(145,145,145,1)" }
                },
                labelText: {
                    color: {
                        value: "#008000",
                    },
                    fontSize: "11px"
                },
                colorPalette: {
                    dataColors: dataColors,
                },
                isHighContrast: false,
            });
            setTimeout(function () {
                var labels = $(".labelText");
                var color = $(labels[0]).css("fill");
                expect(color === "#008000" || color === "rgb(0, 128, 0)").toBeTruthy();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Gauge Data Tests", function () {
        var gaugeDataBuilder;
        beforeEach(function () {
            powerbitests.mocks.setLocale();
            gaugeDataBuilder = new GaugeDataBuilder("gauge");
            gaugeDataBuilder.dataViewMetadata.columns[3].objects = {
                general: { formatString: "$0" }
            };
        });
        it("Gauge registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("gauge").capabilities).toBe(GaugeVisual.capabilities);
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(GaugeVisual.capabilities.objects)).toEqual(GaugeVisual.formatStringProp);
        });
        it("Gauge_greaterThanMax", function () {
            gaugeDataBuilder.singleValue = 500;
            gaugeDataBuilder.values = [[500], [0], [300], [200]];
            gaugeDataBuilder.onDataChanged();
            expect(GaugeVisual.converter(gaugeDataBuilder.dataView).percent).toBe(1);
        });
        it("Gauge_smallerThanMin", function () {
            gaugeDataBuilder.singleValue = -3;
            gaugeDataBuilder.values = [[-3], [0], [300], [200]];
            gaugeDataBuilder.onDataChanged();
            expect(GaugeVisual.converter(gaugeDataBuilder.dataView).percent).toBe(0);
        });
        it("Gauge_betweenMinMax", function () {
            gaugeDataBuilder.singleValue = 200;
            gaugeDataBuilder.values = [[200], [100], [300], [200]];
            gaugeDataBuilder.onDataChanged();
            expect(GaugeVisual.converter(gaugeDataBuilder.dataView).percent).toBe(0.5);
        });
        it("Gauge_Nulls", function () {
            gaugeDataBuilder.singleValue = null;
            gaugeDataBuilder.values = [[null], [null], [null], [null]];
            gaugeDataBuilder.onDataChanged();
            var data = GaugeVisual.converter(gaugeDataBuilder.dataView);
            expect(data.percent).toBe(0);
            expect(data.targetSettings).toEqual({
                min: 0,
                max: 0,
                target: 0,
            });
        });
        it("Gauge_tooltip_work", function () {
            gaugeDataBuilder.singleValue = 500;
            gaugeDataBuilder.values = [[10], [0], [500], [200]];
            gaugeDataBuilder.onDataChanged();
            var data = GaugeVisual.converter(gaugeDataBuilder.dataView);
            var expectedValues = {
                percent: 0.02,
                adjustedTotal: 10,
                total: 10,
                metadataColumn: gaugeDataBuilder.dataViewMetadata.columns[0],
                targetSettings: {
                    min: 0,
                    max: 500,
                    target: 200
                },
                tooltipInfo: [{ displayName: "col1", value: "$10" }, { displayName: "col4", value: "$200" }],
            };
            expect(data).toEqual(expectedValues);
        });
        it("Gauge_Nulls_Tooltip_Data", function () {
            gaugeDataBuilder.singleValue = null;
            gaugeDataBuilder.values = [[null], [null], [null], [null]];
            gaugeDataBuilder.onDataChanged();
            var data = GaugeVisual.converter(gaugeDataBuilder.dataView);
            var expectedValues = {
                percent: 0,
                adjustedTotal: 0,
                total: 0,
                metadataColumn: gaugeDataBuilder.dataViewMetadata.columns[0],
                targetSettings: { min: 0, max: 0, target: 0 },
                tooltipInfo: []
            };
            expect(data).toEqual(expectedValues);
        });
        it("Gauge_betweenMinMax_Tooltip_Data", function () {
            gaugeDataBuilder.singleValue = 200;
            gaugeDataBuilder.values = [[200], [100], [300], [200]];
            gaugeDataBuilder.onDataChanged();
            var data = GaugeVisual.converter(gaugeDataBuilder.dataView);
            var expectedValues = {
                percent: 0.5,
                adjustedTotal: 200,
                total: 200,
                metadataColumn: {
                    displayName: "col1",
                    roles: { Y: true },
                    isMeasure: true,
                    objects: { general: { formatString: "$0" } },
                },
                targetSettings: { min: 100, max: 300, target: 200 },
                tooltipInfo: [{ displayName: "col1", value: "$200" }, { displayName: "col4", value: "$200" }]
            };
            expect(data).toEqual(expectedValues);
        });
        describe("Gauge Rendering Tests", function () {
            var gaugeVisualDataBuilder;
            beforeEach(function () {
                gaugeDataBuilder = new GaugeDataBuilder("gauge");
                gaugeDataBuilder.singleValue = 10;
                gaugeDataBuilder.values = [[10], [0], [300], [200]];
                gaugeVisualDataBuilder = new GaugeVisualDataBuilder("gauge");
                gaugeVisualDataBuilder.dataViewMetadata.columns[3].objects = {
                    general: { formatString: "$0" }
                };
                gaugeVisualDataBuilder.singleValue = 10;
                gaugeVisualDataBuilder.values = [[10], [0], [300], [200]];
            });
            it("Get_Animated_Number_Properties works", function () {
                var expectedNumberProperty = {
                    transformString: "translate(0.2928932188134524,0.29289321881345254)",
                    viewport: {
                        "height": 0.7071067811865475,
                        "width": 1.4142135623730951
                    }
                };
                var animatedNumberProperty = gaugeVisualDataBuilder.gauge.getAnimatedNumberProperties(1, 1, 1, 1);
                expect(animatedNumberProperty).toEqual(expectedNumberProperty);
            });
            it("Get_Viewport_Properties works", function () {
                var expectedViewPortProperty = {
                    radius: 205,
                    innerRadiusOfArc: 143.5,
                    left: 250,
                    top: 352.5,
                    height: 460,
                    width: 410,
                    margin: {
                        top: 20,
                        bottom: 20,
                        left: 45,
                        right: 45
                    },
                    transformString: "translate(250,352.5)",
                    innerRadiusFactor: 0.7
                };
                var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
                expect(viewPortProperty).toEqual(expectedViewPortProperty);
            });
            it("NaN in values shows a warning", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [NaN, 1], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.warningSpy).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.warningSpy.calls.count()).toBe(1);
                    expect(gaugeVisualDataBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("NaNNotSupported");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("Negative Infinity in values shows a warning", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [Number.NEGATIVE_INFINITY], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.warningSpy).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.warningSpy.calls.count()).toBe(1);
                    expect(gaugeVisualDataBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("Positive Infinity in values shows a warning", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [Number.POSITIVE_INFINITY], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.warningSpy).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.warningSpy.calls.count()).toBe(1);
                    expect(gaugeVisualDataBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("InfinityValuesNotSupported");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("Value out of range in values shows a warning", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [1e301], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.warningSpy).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.warningSpy.calls.count()).toBe(1);
                    expect(gaugeVisualDataBuilder.warningSpy.calls.argsFor(0)[0][0].code).toBe("ValuesOutOfRange");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("All okay in values shows a warning", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [20], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.warningSpy).not.toHaveBeenCalled();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("OnDataChange calls expected methods", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [300], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.gauge.drawViewPort).toHaveBeenCalled();
                    //Changing data should trigger new calls for viewport and animated number properties
                    expect(gaugeVisualDataBuilder.gauge.getGaugeVisualProperties).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.gauge.getAnimatedNumberProperties).toHaveBeenCalled();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("onResizing calls expected methods", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [300], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                gaugeVisualDataBuilder.onResizing(200, 300);
                setTimeout(function () {
                    expect(gaugeVisualDataBuilder.gauge.getGaugeVisualProperties).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.gauge.getAnimatedNumberProperties).toHaveBeenCalled();
                    expect(gaugeVisualDataBuilder.gauge.drawViewPort).toHaveBeenCalled();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("onResizing aspect ratio check", function (done) {
                gaugeVisualDataBuilder.values = [[10], [0], [300], [200]];
                gaugeVisualDataBuilder.onDataChanged();
                gaugeVisualDataBuilder.onResizing(100, 400);
                setTimeout(function () {
                    var foregroundArc = $(".foregroundArc");
                    var path = foregroundArc.attr("d");
                    // ensure the radius is correct
                    expect(path.indexOf("A 60 60") > -1 || path.indexOf("A60,60") > -1 || path.indexOf("A60 60") > -1).toBeTruthy();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("check target has decimal values", function (done) {
                gaugeVisualDataBuilder.dataViewMetadata.columns[0].objects = {
                    general: { formatString: "0.00" }
                };
                gaugeVisualDataBuilder.values = [[5.5], [0], [10], [6.5]];
                gaugeVisualDataBuilder.onDataChanged();
                gaugeVisualDataBuilder.onResizing(100, 400);
                setTimeout(function () {
                    var targetText = $(".targetText").text();
                    expect(targetText).toEqual("6.50");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("Gauge_default_gauge_values", function () {
                var dataView = {
                    metadata: null,
                    single: { value: 500 },
                    categorical: null
                };
                var expectedValues = {
                    percent: 0,
                    adjustedTotal: 0,
                    total: 0,
                    metadataColumn: null,
                    targetSettings: {
                        min: 0,
                        max: 1,
                        target: undefined
                    },
                    tooltipInfo: undefined
                };
                expect(GaugeVisual.converter(dataView)).toEqual(expectedValues);
            });
        });
    });
    describe("Gauge margins tests", function () {
        var gaugeVisualDataBuilder;
        beforeEach(function () {
            powerbitests.mocks.setLocale();
            gaugeVisualDataBuilder = new GaugeVisualDataBuilder("gauge");
        });
        it("Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString", function () {
            gaugeVisualDataBuilder.height = gaugeVisualDataBuilder.width =
                sideNumbersVisibleGreaterThanMinHeightString;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString", function () {
            gaugeVisualDataBuilder.height = gaugeVisualDataBuilder.width =
                sideNumbersVisibleGreaterThanMinHeightString;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString mobile", function () {
            gaugeVisualDataBuilder.height = gaugeVisualDataBuilder.width =
                sideNumbersVisibleGreaterThanMinHeightString;
            gaugeVisualDataBuilder.isMobile = true;
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 45
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString mobile", function () {
            gaugeVisualDataBuilder.height = gaugeVisualDataBuilder.width =
                sideNumbersVisibleSmallerThanMinHeightString;
            gaugeVisualDataBuilder.isMobile = true;
            var expectedViewPortProperty = {
                margin: {
                    top: marginsOnSmallViewPort,
                    bottom: marginsOnSmallViewPort,
                    left: marginsOnSmallViewPort,
                    right: marginsOnSmallViewPort
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with height greater than width", function () {
            gaugeVisualDataBuilder.height = "200";
            gaugeVisualDataBuilder.width = "199";
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 15
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with target on left and height greater than width", function () {
            gaugeVisualDataBuilder.height = "200";
            gaugeVisualDataBuilder.width = "199";
            gaugeVisualDataBuilder.singleValue = 10;
            gaugeVisualDataBuilder.values = [[10], [0], [300], [0]];
            gaugeVisualDataBuilder.onDataChanged();
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 45,
                    right: 15
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with target on right and height greater than width", function () {
            gaugeVisualDataBuilder.height = "200";
            gaugeVisualDataBuilder.width = "199";
            gaugeVisualDataBuilder.singleValue = 10;
            gaugeVisualDataBuilder.values = [[10], [0], [300], [250]];
            gaugeVisualDataBuilder.onDataChanged();
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 45
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
        it("Gauge margin test with small width and target", function () {
            gaugeVisualDataBuilder.height = "200";
            gaugeVisualDataBuilder.width = "140";
            gaugeVisualDataBuilder.singleValue = 10;
            gaugeVisualDataBuilder.values = [[10], [0], [300], [250]];
            gaugeVisualDataBuilder.onDataChanged();
            var expectedViewPortProperty = {
                margin: {
                    top: 20,
                    bottom: 20,
                    left: 15,
                    right: 15
                },
            };
            var viewPortProperty = gaugeVisualDataBuilder.gauge.getGaugeVisualProperties();
            expect(viewPortProperty.margin).toEqual(expectedViewPortProperty.margin);
        });
    });
    describe("Gauge side number tests", function () {
        var gaugeDataBuilder;
        beforeEach(function () {
            powerbitests.mocks.setLocale();
            gaugeDataBuilder = new GaugeDataBuilder("gauge");
        });
        it("Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString mobile", function (done) {
            gaugeDataBuilder.height = gaugeDataBuilder.width = sideNumbersVisibleSmallerThanMinHeightString;
            gaugeDataBuilder.values = [[-25]];
            gaugeDataBuilder.isMobile = true;
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var labels = $(".labelText");
                expect(labels.length).toBe(0);
                expect($(labels[0]).text()).toEqual("");
                expect($(labels[1]).text()).toEqual("");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString mobile", function (done) {
            gaugeDataBuilder.height = gaugeDataBuilder.width = sideNumbersVisibleGreaterThanMinHeightString;
            gaugeDataBuilder.values = [[-25]];
            gaugeDataBuilder.isMobile = true;
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var labels = $(".labelText");
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual("$0");
                expect($(labels[1]).text()).toEqual("$1");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Gauge margin test with view port sideNumbersVisibleSmallerThanMinHeightString", function (done) {
            gaugeDataBuilder.height = gaugeDataBuilder.width = sideNumbersVisibleSmallerThanMinHeightString;
            gaugeDataBuilder.isMobile = false;
            gaugeDataBuilder.values = [[-25]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var labels = $(".labelText");
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual("$0");
                expect($(labels[1]).text()).toEqual("$1");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Gauge margin test with view port sideNumbersVisibleGreaterThanMinHeightString", function (done) {
            gaugeDataBuilder.height = gaugeDataBuilder.width = sideNumbersVisibleGreaterThanMinHeightString;
            gaugeDataBuilder.isMobile = false;
            gaugeDataBuilder.values = [[-25]];
            gaugeDataBuilder.onDataChanged();
            setTimeout(function () {
                var labels = $(".labelText");
                expect(labels.length).toBe(2);
                expect($(labels[0]).text()).toEqual("$0");
                expect($(labels[1]).text()).toEqual("$1");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var GeocodingManager = powerbi.visuals.BI.Services.GeocodingManager;
    describe("GeocodingManagerTests", function () {
        describe("GeocodingManager.isCategoryType", function () {
            it("GeocodingManager.CategoryTypes.Address", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Address)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.City", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.City)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.Continent", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Continent)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes Country", function () {
                expect(GeocodingManager.isCategoryType("Country")).toBeTruthy(); // Country is special
            });
            it("GeocodingManager.CategoryTypes.County", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.County)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.Longitude", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Longitude)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.Latitude", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Latitude)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.Place", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.Place)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.PostalCode", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.PostalCode)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes.StateOrProvince", function () {
                expect(GeocodingManager.isCategoryType(GeocodingManager.CategoryTypes.StateOrProvince)).toBeTruthy();
            });
            it("GeocodingManager.CategoryTypes empty", function () {
                expect(GeocodingManager.isCategoryType("")).toBeFalsy();
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ImageVisual = powerbi.visuals.ImageVisual;
    describe("ImageVisual", function () {
        var imageVisualDataBuilder;
        beforeEach(function () {
            imageVisualDataBuilder = new ImageVisualDataBuilder();
        });
        it("ImageVisual registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("image").capabilities).toBe(ImageVisual.capabilities);
        });
        it("ImageVisual registered capabilities: objects", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("image").capabilities.objects).toBeDefined();
        });
        it("Image no visual configuration", function () {
            expect(imageVisualDataBuilder.element.children().length).toBe(0);
        });
        it("Image to about:blank", function () {
            imageVisualDataBuilder.imageUrl = "about:blank";
            imageVisualDataBuilder.onDataChanged();
            //invalid image data url
            expect(imageVisualDataBuilder.element.find(".imageBackground").css("backgroundImage")).toBe("none");
        });
        it("Image from base64 string", function () {
            var imageBase64value = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAkFBMVEX" +
                "////+/v78+/vz8e/29PLr5+Tw7etwWEdbPyzTy8Tj3trn4t78+/mTgHOsnZLCt69PMRzX0cvJwLml" +
                "lYm1qJ53YE8zEQBsUj9QMR68sKZHKRREJA+aiHx+aViGcF7q5t6NeWpkSDafjoAvCwA4FgC4rKSnm" +
                "JE+HAaKdWhVOCeHeG1TPi5jT0BxX1J5aFtlSznQd83pAAACIklEQVQYGZXBiVraQBiG0ff7s8BMQs" +
                "JkEaNsalspXbj/u2us1Scg7TM9B64R/0X8H6FMxBPu53ePiCS6bz/qkljCfatK4hnHIxjRjPURiWj" +
                "Cf69AIpYIP44eRCxRdj/bBBFLkHZHh4glQbYOiGgykgoRT2QDIprIhxwRr3AJ8VTuChDvJPFPZQri" +
                "jQyQuE6vTC94IUiLHMRHMnFGQmSHu+f7vkBckIDcN0PXfR7qJmR5Caj4+mnR1LN5InFGENrDYVHVL" +
                "viiKIJzIWQp65uG0anCmBKu7ytvTCjNdmVwmJWqDogJEU4NIzPTG0YlCEzdAjFhDPOMP/QbryTAWF" +
                "cYE4L262lfucx4l7jq0CFAtvGICeGTpN6v5svl/DTrN5t+9rB8/vR0WyMw6kfElHiYMUp8XS22/Wx" +
                "1WvWbRRXESOT7RGJKrOYmE5cEIm094oxY32cISTaSkMxMYpQOHnHOcDcO443Eu9TliAtSulxjXFHu" +
                "SsQHxn4ucYVAfCT8vZOIV3KYYUSznfLlgBFHZBk0S09JFOEzjM8PASQuyMQFEQpkNLPOQBITxjVJj" +
                "WTkj4s6Y0oi/eIQ54QbwAzyuhtclpa8kAT17VODuCCaKgczIE2LXSnJDAj9022D+ECExy5jJEbiRV" +
                "r3N3ePCeIKoXq/HnzKq9R3m+XzvMpBXCWQa7f9ZrvdbvrV/O521gbAxN+IURKGqm3brvElIxP/ImN" +
                "CJi78AkZVGOZlPDldAAAAAElFTkSuQmCC";
            imageVisualDataBuilder.imageUrl = imageBase64value;
            imageVisualDataBuilder.onDataChanged();
            expect(imageVisualDataBuilder.element.find(".imageBackground").css("backgroundImage")).toBe("url(" + imageBase64value + ")");
        });
    });
    var ImageVisualDataBuilder = (function () {
        function ImageVisualDataBuilder() {
            this._element = powerbitests.helpers.testDom("200", "300");
            this._hostService = powerbitests.mocks.createVisualHostServices();
            this._style = powerbi.visuals.visualStyles.create();
            this._image = new ImageVisual();
            this.init();
        }
        Object.defineProperty(ImageVisualDataBuilder.prototype, "element", {
            get: function () {
                return this._element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImageVisualDataBuilder.prototype, "image", {
            get: function () {
                return this._image;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ImageVisualDataBuilder.prototype, "imageUrl", {
            get: function () {
                return this._imageUrl;
            },
            set: function (value) {
                this._imageUrl = value;
            },
            enumerable: true,
            configurable: true
        });
        ImageVisualDataBuilder.prototype.init = function () {
            this.image.init({
                element: this._element,
                host: this._hostService,
                style: this._style,
                viewport: {
                    height: this._element.height(),
                    width: this._element.width()
                },
                animation: {
                    transitionImmediate: true
                }
            });
        };
        ImageVisualDataBuilder.prototype.onDataChanged = function () {
            this.image.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [],
                            objects: {
                                general: {
                                    imageUrl: this.imageUrl
                                }
                            }
                        }
                    }]
            });
        };
        return ImageVisualDataBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var LegendIcon = powerbi.visuals.LegendIcon;
    var LegendPosition = powerbi.visuals.LegendPosition;
    describe("DOM validation", function () {
        var element;
        var viewport;
        var legend;
        var interactivityService;
        var hostServices;
        beforeEach(function () {
            powerbitests.mocks.setLocale();
            element = powerbitests.helpers.testDom('500', '500');
            hostServices = powerbitests.mocks.createVisualHostServices();
            interactivityService = powerbi.visuals.createInteractivityService(hostServices);
            legend = powerbi.visuals.createLegend(element, false, interactivityService, true);
            viewport = {
                height: element.height(),
                width: element.width()
            };
        });
        it('legend dom validation one legend item count validation', function (done) {
            var legendData = [
                {
                    label: 'California', color: 'red', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.legendItem').length).toBe(1);
                expect($('.legendText').length).toBe(1);
                expect($('.legendIcon').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items count validation', function (done) {
            var legendData = [
                { label: 'California', color: '#ff0000', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: '#0000ff', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: '00ff00', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.legendItem').length).toBe(3);
                expect($('.legendText').length).toBe(3);
                expect($('.legendIcon').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation incremental build', function (done) {
            // Draw the legend once with the 3 states
            var initialData = [
                { label: 'California', color: '#fff000', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: '#ff00ff', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: '#fff000', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.drawLegend({ dataPoints: initialData }, viewport);
            setTimeout(function () {
                validateLegendDOM(initialData);
                // Draw the legend against with a new state at the start
                var legendData = [
                    { label: 'Alaska', color: '#fff000', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { label: 'California', color: '#fff00d', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { label: 'Texas', color: '#fffe00', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { label: 'Washington', color: '#0000dd', icon: LegendIcon.Box, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
                ];
                legend.reset();
                legend.drawLegend({ dataPoints: legendData }, viewport);
                setTimeout(function () {
                    validateLegendDOM(legendData);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items first item text', function (done) {
            var legendData = [
                { label: 'California', color: 'red', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: 'blue', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: 'green', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.reset();
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.legendText').first().text()).toBe('California');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items last item text', function (done) {
            var legendData = [
                { label: 'California', color: 'red', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: 'blue', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: 'green', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.legendText').last().text()).toBe('Washington');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items colors count', function (done) {
            var legendData = [
                { label: 'California', color: 'red', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Texas', color: 'blue', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { label: 'Washington', color: 'green', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.legendIcon').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend defaults', function () {
            var legendArray = getLotsOfLegendData();
            var legendData = { dataPoints: legendArray, title: '' };
            var props = {};
            powerbi.visuals.LegendData.update(legendData, props);
            expect(props[powerbi.visuals.legendProps.show]).toBe(true);
            expect(props[powerbi.visuals.legendProps.position]).toEqual(powerbi.legendPosition.top);
        });
        it('legend with title', function () {
            var legendData = getLotsOfLegendData();
            legend.drawLegend({ dataPoints: legendData, title: 'states' }, viewport);
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendTitle').length).toBe(1);
        });
        it('legend with long title on Right', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData, title: 'This is a super long title and should be truncated by now' }, viewport);
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendTitle').text()).toEqual('This is a super long title...');
        });
        it('legend no title', function () {
            var legendData = getLotsOfLegendData();
            legend.drawLegend({ dataPoints: legendData }, viewport);
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendTitle').length).toBe(0);
        });
        it('legend Top & horizontal trim', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBeGreaterThan(5);
            expect($('.legendItem').length).toBeLessThan(52);
        });
        it('legend Bottom & horizontal trim', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Bottom);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBeGreaterThan(5);
            expect($('.legendItem').length).toBeLessThan(52);
        });
        it('legend Left & vertical trim', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Left);
            legend.drawLegend({ dataPoints: legendData }, { height: 200, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBeGreaterThan(5);
            expect($('.legendItem').length).toBeLessThan(52);
        });
        it('legend Right & vertical trim', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 200, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBeGreaterThan(5);
            expect($('.legendItem').length).toBeLessThan(52);
        });
        it('Intelligent Layout: Low label count should result in longer max-width', function () {
            var legendData = [{
                    label: 'Really long label, but i have the space to show',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBe(1);
            expect($($('.legendText')[0]).text()).not.toContain('...');
        });
        it('Intelligent Layout: Lots of small labels should get compacted in horizontal layout', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.legendItem').length).toBe(25);
        });
        it('Intelligent Layout: If labels in horizontal layout have small widths, width of legend should be small', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect(legend.getMargins().width).toBeLessThan(200);
        });
        it('Intelligent Layout: If labels in horizontal layout have large widths, width of legend should be 30% of viewport', function () {
            var legendData = [{
                    label: 'I am a really long label, but you should not allow me to take more than 300px',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect(legend.getMargins().width).toBe(300);
        });
        it('Intelligent Layout: Only right arrow shown at start ', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: No arrows when you have enough horizontal space ', function () {
            var legendData = [{
                    label: 'Skywalker',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }, {
                    label: 'The End',
                    color: 'blue',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Bottom);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(0);
        });
        it('Intelligent Layout: No arrows when you have enough vertical space ', function () {
            var legendData = [{
                    label: 'Skywalker',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }, {
                    label: 'The End',
                    color: 'blue',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(0);
        });
        it('Intelligent Layout: No arrows when you have enough horizontal space, but appears on resize ', function () {
            var legendData = [{
                    label: 'Skywalker',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }, {
                    label: 'The End',
                    color: 'blue',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(0);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 100 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: No arrows when you have enough vertical space, but appears on resize ', function () {
            var legendData = [{
                    label: 'Skywalker',
                    color: 'red',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }, {
                    label: 'The End',
                    color: 'blue',
                    icon: LegendIcon.Line,
                    identity: powerbi.visuals.SelectionId.createNull(), selected: false
                }];
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(0);
            legend.drawLegend({ dataPoints: legendData }, { height: 20, width: 100 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: Only down arrow shown at start ', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: Only down arrow shown at start ', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: Second arrow appears when you page right', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
            $('.navArrow').first().d3Click(0, 0);
            expect($('.navArrow').length).toBe(2);
        });
        it('Intelligent Layout: Second arrow appears when you page down', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Left);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
            $('.navArrow').first().d3Click(0, 0);
            expect($('.navArrow').length).toBe(2);
        });
        it('Intelligent Layout: Second arrow disappears when you page rigth to last page', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Top);
            legend.drawLegend({ dataPoints: legendData }, { height: 100, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
            $('.navArrow').first().d3Click(0, 0);
            expect($('.navArrow').length).toBe(2);
            $('.navArrow').last().d3Click(0, 0);
            expect($('.navArrow').length).toBe(1);
        });
        it('Intelligent Layout: Second arrow disappears when you page down to last page', function () {
            var legendData = getLotsOfLegendData();
            legend.changeOrientation(LegendPosition.Right);
            legend.drawLegend({ dataPoints: legendData }, { height: 500, width: 1000 });
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            expect($('.navArrow').length).toBe(1);
            $('.navArrow').first().d3Click(0, 0);
            expect($('.navArrow').length).toBe(2);
            $('.navArrow').last().d3Click(0, 0);
            expect($('.navArrow').length).toBe(1);
        });
        it('legend interactivity test ', function () {
            var scopeId1 = powerbitests.mocks.dataViewScopeIdentity('California');
            var scopeId2 = powerbitests.mocks.dataViewScopeIdentity('Texas');
            var scopeId3 = powerbitests.mocks.dataViewScopeIdentity('Washington');
            var legendData = [
                { label: 'California', color: '#ff0000', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createWithId(scopeId1), selected: false },
                { label: 'Texas', color: '#0000ff', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createWithId(scopeId2), selected: false },
                { label: 'Washington', color: '#00ff00', icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createWithId(scopeId3), selected: false }
            ];
            var viewport = {
                height: 500,
                width: 500
            };
            legend = powerbi.visuals.createLegend(element, false, interactivityService);
            legend.drawLegend({ title: "Top Data", dataPoints: legendData }, viewport);
            var icons = $('.legendIcon');
            spyOn(hostServices, 'onSelect').and.callThrough();
            // Click first legend
            icons.first().d3Click(0, 0);
            expect(icons[0].style.fill).toBe('#ff0000');
            expect(icons[1].style.fill).toBe('#a6a6a6');
            expect(icons[2].style.fill).toBe('#a6a6a6');
            // Click the last legend item, should just select current and clear others
            icons.last().d3Click(0, 0);
            expect(icons[0].style.fill).toBe('#a6a6a6');
            expect(icons[1].style.fill).toBe('#a6a6a6');
            expect(icons[2].style.fill).toBe('#00ff00');
            // Control + Click legend item, should multiselect
            icons.first().d3Click(0, 0, powerbitests.helpers.ClickEventType.CtrlKey);
            expect(icons[0].style.fill).toBe('#ff0000');
            expect(icons[1].style.fill).toBe('#a6a6a6');
            //expect(icons[2].style.fill).toBe('#00ff00');
            // Click the clear catcher should clear the legend selection
            ($('.clearCatcher').first()).d3Click(0, 0);
            expect(icons[0].style.fill).toBe('#ff0000');
            expect(icons[1].style.fill).toBe('#0000ff');
            expect(icons[2].style.fill).toBe('#00ff00');
        });
        function validateLegendDOM(expectedData) {
            var len = expectedData.length;
            var labels = $('.legendText');
            expect(labels.length).toBe(len);
            var icons = $('.legendIcon');
            expect(icons.length).toBe(len);
            for (var i = 0; i < len; ++i) {
                var expectedDatum = expectedData[i];
                expect($(labels.get(i)).text()).toBe(expectedDatum.label);
                expect($(icons.get(i)).css('fill')).toBe(expectedDatum.color);
            }
        }
        function getLotsOfLegendData() {
            var states = ['AL', 'AK', 'AS', 'AZ', 'AR', 'CA', 'CO',
                'CT', 'DE', 'DC', 'FM', 'FL', 'GA', 'GU', 'HI', 'ID',
                'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MH', 'MD',
                'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH',
                'NJ', 'NM', 'NY', 'NC', 'ND', 'MP', 'OH', 'OK', 'OR',
                'PW', 'PA', 'PR', 'RI', 'SC', 'SD', 'TN', 'TX', 'UT',
                'VT', 'VI', 'VA', 'WA', 'WV', 'WI', 'WY', 'AE', 'AA',
                'AP'];
            var colors = d3.scale.category20c();
            var legendData = [];
            for (var i = 0; i < states.length; i++) {
                legendData.push({ label: states[i], color: colors(i), icon: LegendIcon.Line, identity: powerbi.visuals.SelectionId.createNull(), selected: false });
            }
            return legendData;
        }
    });
    describe("interactive legend DOM validation", function () {
        var element;
        var viewport;
        var legend;
        var colorStyle = 'color: {0};';
        var defaultLegendHeight = 65;
        var interactivityService;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            var hostServices = powerbitests.mocks.createVisualHostServices();
            interactivityService = powerbi.visuals.createInteractivityService(hostServices);
            legend = powerbi.visuals.createLegend(element, true, interactivityService);
        });
        it('legend dom validation one legend item count validation', function (done) {
            var legendData = [
                { category: 'state', label: 'California', color: 'red', icon: LegendIcon.Line, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false }
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.interactive-legend .title').length).toBe(1);
                expect($('.interactive-legend .item').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items count validation', function (done) {
            var legendData = [
                { category: 'state', label: 'California', color: 'red', icon: LegendIcon.Line, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'blue', icon: LegendIcon.Line, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Washington', color: 'green', icon: LegendIcon.Line, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.interactive-legend .title').length).toBe(1);
                expect($('.interactive-legend .item').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation incremental build', function (done) {
            // Draw the legend once with the 3 states
            var initialData = [
                { category: 'state', label: 'California', color: 'red', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'blue', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Washington', color: 'green', icon: LegendIcon.Box, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.drawLegend({ dataPoints: initialData }, viewport);
            setTimeout(function () {
                validateLegendDOM(initialData);
                // Draw the legend against with a new state at the start
                var legendData = [
                    { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { category: 'state', label: 'California', color: 'blue', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { category: 'state', label: 'Texas', color: 'green', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { category: 'state', label: 'Washington', color: 'orange', icon: LegendIcon.Box, measure: 15, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                ];
                legend.reset();
                legend.drawLegend({ dataPoints: legendData }, viewport);
                setTimeout(function () {
                    validateLegendDOM(legendData);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items first item name and measure', function (done) {
            var legendData = [
                { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'California', color: 'blue', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'green', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.interactive-legend .title').text()).toBe(legendData[0].category);
                expect($('.interactive-legend .item').first().find('.itemName').text().trim()).toBe('Alaska');
                expect($('.interactive-legend .item').first().find('.itemMeasure').text().trim()).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items last item name and measure', function (done) {
            var legendData = [
                { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'California', color: 'blue', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'green', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.interactive-legend .title').text()).toBe(legendData[0].category);
                // last item is actually the second item since values should be placed in a two-row table.
                expect($('.interactive-legend .item').last().find('.itemName').text().trim()).toBe('California');
                expect($('.interactive-legend .item').last().find('.itemMeasure').text().trim()).toBe('5');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('legend dom validation three legend items colors count', function (done) {
            var legendData = [
                { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'California', color: 'blue', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                { category: 'state', label: 'Texas', color: 'green', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
            ];
            legend.drawLegend({ dataPoints: legendData }, viewport);
            setTimeout(function () {
                expect($('.interactive-legend .icon').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        // Legend Height tests - legend height is constant regardless of data.
        it('legend getHeight empty', function () {
            expect(legend.getMargins().height).toBe(defaultLegendHeight);
        });
        it('legend getHeight no data', function () {
            legend.drawLegend({ dataPoints: [] }, viewport);
            expect(legend.getMargins().height).toBe(defaultLegendHeight);
        });
        it('legend getHeight data', function () {
            legend.drawLegend({
                dataPoints: [
                    { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { category: 'state', label: 'California', color: 'blue', icon: LegendIcon.Box, measure: 5, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                    { category: 'state', label: 'Texas', color: 'green', icon: LegendIcon.Box, measure: 10, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                ]
            }, viewport);
            expect(legend.getMargins().height).toBe(defaultLegendHeight);
        });
        it('legend getHeight one data point', function () {
            legend.drawLegend({
                dataPoints: [
                    { category: 'state', label: 'Alaska', color: 'red', icon: LegendIcon.Box, measure: 0, identity: powerbi.visuals.SelectionId.createNull(), selected: false },
                ]
            }, viewport);
            expect(legend.getMargins().height).toBe(defaultLegendHeight);
        });
        function validateLegendDOM(expectedData) {
            var len = expectedData.length;
            var items = $('.interactive-legend .item');
            expect($('.interactive-legend .title').length).toBe(1);
            expect(items.length).toBe(len);
            var icons = $('.interactive-legend .icon');
            expect(icons.length).toBe(len);
            // items are returned from the table, first row and then second row.
            // rearrage it to match the way the legend outputs it: by columns.
            var rearrangedItems = [];
            var rearrangedIcons = [];
            for (var i = 0; i < len; i = i + 2) {
                rearrangedItems.push($(items.get(i)));
                rearrangedIcons.push($(icons.get(i)));
            }
            for (var i = 1; i < len; i = i + 2) {
                rearrangedItems.push($(items.get(i)));
                rearrangedIcons.push($(icons.get(i)));
            }
            for (var i = 0; i < len; ++i) {
                var expectedDatum = expectedData[i];
                var item = rearrangedItems[i];
                var icon = rearrangedIcons[i];
                expect(item.find('.itemName').text()).toBe(expectedDatum.label);
                expect(item.find('.itemMeasure').text().trim()).toBe(expectedDatum.measure.toString());
                expect(icon.attr('style').trim()).toBe(jsCommon.StringExtensions.format(colorStyle, expectedDatum.color));
            }
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var AxisType = powerbi.axisType;
    var ColorUtility = powerbitests.utils.ColorUtility;
    var DataViewPivotCategorical = powerbi.data.DataViewPivotCategorical;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var LineChart = powerbi.visuals.LineChart;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var SelectionId = powerbi.visuals.SelectionId;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
    powerbitests.mocks.setLocale();
    describe("LineChart Dataview Validation", function () {
        var blankCategoryValue = '(Blank)';
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    // for secondary grouping (legend/series)
                    displayName: 'col5',
                    queryName: 'col5',
                    isMeasure: false,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
            ]
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        it('LineChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').capabilities).toBe(powerbi.visuals.lineChartCapabilities);
        });
        it('LineChart registered customizeQuery', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').customizeQuery).toBe(LineChart.customizeQuery);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.lineChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.lineChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.lineChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.lineChartCapabilities.objects)).toEqual(powerbi.visuals.lineChartProps.general.formatString);
        });
        it('CustomizeQuery picks sample based on data type', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ sample: {} });
        });
        it('CustomizeQuery picks top based on data type', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery no category', function () {
            var objects = {
                categoryAxis: {}
            };
            var dataViewMapping = createCompiledDataViewMapping(null, objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery explicit scalar axis on non-scalar type', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar'
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('CustomizeQuery explicit categorical axis on scalar type', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar'
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text), objects);
            LineChart.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.categorical.categories.dataReductionAlgorithm).toEqual({ top: {} });
        });
        it('Sortable roles with scalar axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Scalar',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            expect(LineChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toBeNull();
        });
        it('Sortable roles with categorical axis', function () {
            var objects = {
                categoryAxis: {
                    axisType: 'Categorical',
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime), objects);
            expect(LineChart.getSortableRoles({
                dataViewMappings: [dataViewMapping]
            })).toEqual(['Category']);
        });
        function createCompiledDataViewMapping(categoryType, objects) {
            var categoryItems = [];
            if (categoryType)
                categoryItems.push({ type: categoryType });
            return {
                metadata: {
                    objects: objects
                },
                categorical: {
                    categories: {
                        for: {
                            in: { role: 'Category', items: categoryItems }
                        },
                        dataReductionAlgorithm: { top: {} }
                    },
                    values: {
                        group: {
                            by: { role: 'Series', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) }] },
                            select: [
                                { for: { in: { role: 'Y', items: [{ type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) }] } } }
                            ],
                            dataReductionAlgorithm: { top: {} }
                        }
                    }
                }
            };
        }
        it('Check convert empty + fill color', function () {
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: '#41BEE0' } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: [],
                            objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } }]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: metadata.columns[1],
                            values: [],
                            subtotal: 0
                        }])
                }
            };
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false);
            expect(actualData.series).toEqual([]);
        });
        it('Check convert categorical + fill color', function () {
            var seriesColor = '#41BEE0';
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColor } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: metadata.columns[1],
                            values: [100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: SelectionId.createWithMeasure('col2'),
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical multi-series + fill colors', function () {
            var seriesId1 = SelectionId.createWithMeasure('col2');
            var seriesKey1 = seriesId1.getKey();
            var seriesId2 = SelectionId.createWithMeasure('col3');
            var seriesKey2 = seriesId2.getKey();
            var seriesId3 = SelectionId.createWithMeasure('col4');
            var seriesKey3 = seriesId3.getKey();
            var seriesColors = [
                '#41BEE0',
                '#41BEE1',
                '#41BEE2',
            ];
            var metadata = {
                columns: [
                    dataViewMetadata.columns[0],
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[0] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[2], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[1] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[3], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[2] } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau'],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [100, 200, 700],
                        }, {
                            source: metadata.columns[2],
                            values: [700, 100, 200],
                        }, {
                            source: metadata.columns[3],
                            values: [200, 700, 100],
                        }], undefined, metadata.columns[4])
                },
            };
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [
                {
                    key: seriesKey1,
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo', value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId1,
                    selected: false
                },
                {
                    key: seriesKey2,
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[2],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 700,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col3", value: "700" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 100,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col3", value: "100" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col3", value: "200" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId2,
                    selected: false
                },
                {
                    key: seriesKey3,
                    lineIndex: 2,
                    color: seriesColors[2],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[3],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col4", value: "200" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 700,
                            categoryIndex: 1,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col4", value: "700" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 100,
                            categoryIndex: 2,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col4", value: "100" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId3,
                    selected: false,
                },
            ];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical multi-series', function () {
            var seriesId1 = SelectionId.createWithMeasure('col2');
            var seriesKey1 = seriesId1.getKey();
            var seriesId2 = SelectionId.createWithMeasure('col3');
            var seriesKey2 = seriesId2.getKey();
            var seriesId3 = SelectionId.createWithMeasure('col4');
            var seriesKey3 = seriesId3.getKey();
            dataViewMetadata.objects = undefined;
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [700, 100, 200],
                        }, {
                            source: dataViewMetadata.columns[3],
                            values: [200, 700, 100],
                        }]),
                },
            };
            var seriesColors = [
                colors.getColorByIndex(0).value,
                colors.getColorByIndex(1).value,
                colors.getColorByIndex(2).value,
            ];
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectedData = [
                {
                    key: seriesKey1,
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo', value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: seriesId1,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey1, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId1,
                    selected: false
                },
                {
                    key: seriesKey2,
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[2],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 700,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col3", value: "700" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 100,
                            categoryIndex: 1,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col3", value: "100" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col3", value: "200" }],
                            identity: seriesId2,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey2, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId2,
                    selected: false
                },
                {
                    key: seriesKey3,
                    lineIndex: 2,
                    color: seriesColors[2],
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[3],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col4", value: "200" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 700,
                            categoryIndex: 1,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col4", value: "700" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 100,
                            categoryIndex: 2,
                            seriesIndex: 2,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col4", value: "100" }],
                            identity: seriesId3,
                            selected: false,
                            key: JSON.stringify({ ser: seriesKey3, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: seriesId3,
                    selected: false,
                },
            ];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical dynamic series with undefined grouped', function () {
            dataViewMetadata.objects = undefined;
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [100, 200, 700],
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [700, 100, 200],
                        }, {
                            source: dataViewMetadata.columns[3],
                            values: [200, 700, 100],
                        }], undefined, dataViewMetadata.columns[4]),
                },
            };
            // set grouped() to return an empty array
            dataView.categorical.values.grouped = function () { return []; };
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false);
            expect(actualData.series.length).toBe(3);
        });
        it('Check convert non-category multi-measure + fill colors', function () {
            var seriesColors = [
                '#41BEE0',
                '#41BEE1',
            ];
            var metadata = {
                columns: [
                    powerbi.Prototype.inherit(dataViewMetadata.columns[0], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[0] } } } }; }),
                    powerbi.Prototype.inherit(dataViewMetadata.columns[1], function (c) { return c.objects = { dataPoint: { fill: { solid: { color: seriesColors[1] } } } }; }),
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [100],
                        }, {
                            source: metadata.columns[1],
                            values: [200],
                        }])
                }
            };
            var ids = [SelectionId.createWithMeasure('col1'), SelectionId.createWithMeasure('col2')];
            var keys = [ids[0].getKey(), ids[1].getKey()];
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var expectSlices = [
                {
                    key: keys[0],
                    lineIndex: 0,
                    color: seriesColors[0],
                    xCol: undefined,
                    yCol: dataView.metadata.columns[0],
                    data: [
                        {
                            categoryValue: blankCategoryValue,
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "100" }],
                            identity: ids[0],
                            selected: false,
                            key: JSON.stringify({ ser: keys[0], catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        }
                    ],
                    identity: ids[0],
                    selected: false,
                },
                {
                    key: keys[1],
                    lineIndex: 1,
                    color: seriesColors[1],
                    xCol: undefined,
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: blankCategoryValue,
                            value: 200,
                            categoryIndex: 0,
                            seriesIndex: 1,
                            tooltipInfo: [{ displayName: "col2", value: "200" }],
                            identity: ids[1],
                            selected: false,
                            key: JSON.stringify({ ser: keys[1], catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        }
                    ],
                    identity: ids[1],
                    selected: false
                }
            ];
            expect(actualData).toEqual(expectSlices);
        });
        it('Check convert date time', function () {
            var dateTimeColumnsMetadata = {
                columns: [
                    { displayName: 'Date', queryName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                    { displayName: 'PowerBI Customers', queryName: 'PowerBI Customers', isMeasure: true }]
            };
            var dataView = {
                metadata: dateTimeColumnsMetadata,
                categorical: {
                    categories: [{
                            source: dateTimeColumnsMetadata.columns[0],
                            values: [new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dateTimeColumnsMetadata.columns[1],
                            values: [8000, 20000, 1000000],
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('PowerBI Customers');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, true).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: new Date('2014/9/25').getTime(),
                            value: 8000,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "9/25/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "8000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: new Date('2014/12/12').getTime(),
                            value: 20000,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "12/12/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "20000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: new Date('2015/9/25').getTime(),
                            value: 1000000,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "9/25/2015 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "1000000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert datetime category with null category value', function () {
            var dateTimeColumnsMetadata = {
                columns: [
                    { displayName: 'Date', queryName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                    { displayName: 'PowerBI Customers', queryName: 'PowerBI Customers', isMeasure: true }]
            };
            var dataView = {
                metadata: dateTimeColumnsMetadata,
                categorical: {
                    categories: [{
                            source: dateTimeColumnsMetadata.columns[0],
                            values: [null, new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dateTimeColumnsMetadata.columns[1],
                            values: [30000, 8000, 20000, 1000000],
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('PowerBI Customers');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, true).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: new Date('2014/9/25').getTime(),
                            value: 8000,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "9/25/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "8000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: new Date('2014/12/12').getTime(),
                            value: 20000,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "12/12/2014 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "20000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: new Date('2015/9/25').getTime(),
                            value: 1000000,
                            categoryIndex: 3,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "Date", value: "9/25/2015 12:00:00 AM" }, { displayName: "PowerBI Customers", value: "1000000" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 3 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with null category value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', null, 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, 300, 200, 700],
                            subtotal: 1300
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: null,
                            value: 300,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "(Blank)" }, { displayName: "col2", value: "300" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: 200,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "200" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 3,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 3 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with positive infinity value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, Number.POSITIVE_INFINITY, 700],
                            subtotal: 800
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: Number.MAX_VALUE,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "1.7976931348623157E+308" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with negative infinity value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, Number.NEGATIVE_INFINITY, 700],
                            subtotal: 800
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: -Number.MAX_VALUE,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }, { displayName: "col2", value: "-1.7976931348623157E+308" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert categorical with NaN value', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['John Domo', 'Delta Force', 'Jean Tablau']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [100, Number.NaN, 700],
                            subtotal: 800
                        }])
                }
            };
            var selectionId = SelectionId.createWithMeasure('col2');
            var key = selectionId.getKey();
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, false).series;
            var seriesColor = colors.getColorByIndex(0).value;
            var expectedData = [{
                    key: key,
                    lineIndex: 0,
                    color: seriesColor,
                    xCol: dataView.metadata.columns[0],
                    yCol: dataView.metadata.columns[1],
                    data: [
                        {
                            categoryValue: 'John Domo',
                            value: 100,
                            categoryIndex: 0,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "John Domo" }, { displayName: "col2", value: "100" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 0 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Delta Force',
                            value: null,
                            categoryIndex: 1,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Delta Force" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 1 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                        {
                            categoryValue: 'Jean Tablau',
                            value: 700,
                            categoryIndex: 2,
                            seriesIndex: 0,
                            tooltipInfo: [{ displayName: "col1", value: "Jean Tablau" }, { displayName: "col2", value: "700" }],
                            identity: selectionId,
                            selected: false,
                            key: JSON.stringify({ ser: key, catIdx: 2 }),
                            labelFill: labelColor,
                            labelFormatString: undefined,
                        },
                    ],
                    identity: selectionId,
                    selected: false,
                }];
            expect(actualData).toEqual(expectedData);
        });
        it('Check convert scalar with all null values returns empty series array', function () {
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[2],
                            values: [3, 6, 15]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [null, null, null],
                        }])
                }
            };
            var actualData = LineChart.converter(dataView, blankCategoryValue, colors, true /*isScalar*/).series;
            var expectedData = [];
            expect(actualData).toEqual(expectedData);
        });
        function lineChartDomValidation(interactiveChart) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                    },
                    {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                        objects: { general: { formatString: '0.000' } },
                    },
                    {
                        displayName: 'col3',
                        queryName: 'col3',
                        isMeasure: false,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),
                        objects: { general: { formatString: 'd' } },
                    },
                    {
                        displayName: 'col4',
                        queryName: 'col4',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer),
                        objects: { general: { formatString: '0' } },
                    }],
            };
            var dataViewMetadataWithScalarObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithScalarObject.objects = { categoryAxis: { scalar: true } };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            function getOptionsForValuesWarning(values) {
                var options = {
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: values,
                                        subtotal: 246500
                                    }])
                            }
                        }]
                };
                return options;
            }
            it('NaN in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([NaN, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Negative Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([Number.NEGATIVE_INFINITY, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Positive Infinity in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([Number.POSITIVE_INFINITY, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Out of range value in values shows a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([-1e301, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).toHaveBeenCalled();
                    expect(warningSpy.calls.count()).toBe(1);
                    expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('All okay in values does not show a warning', function (done) {
                var warningSpy = jasmine.createSpy('warning');
                hostServices.setWarnings = warningSpy;
                var options = getOptionsForValuesWarning([480000, 495000, 490000, 480000, 500000]);
                v.onDataChanged(options);
                setTimeout(function () {
                    expect(warningSpy).not.toHaveBeenCalled();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('480K');
                    if (interactiveChart) {
                        expect(LineChart.getInteractiveLegendDomElement(element)).toBeDefined();
                    }
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('verify viewport when filtering data', function (done) {
                // Clone in order to keep the original as it is
                var dataViewMeta = _.clone(dataViewMetadata);
                dataViewMeta.objects = {
                    categoryAxis: {
                        show: true,
                        start: 490001,
                        end: 495001,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                var svgBox = $('.mainGraphicsContext').parent()[0].getBoundingClientRect();
                if (interactiveChart) {
                    setTimeout(function () {
                        expect(svgBox.height).toBeCloseTo(405, 0);
                        expect(svgBox.width).toBeCloseTo(384, 0);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }
                else {
                    setTimeout(function () {
                        expect(svgBox.height).toBeCloseTo(470, 0);
                        expect(svgBox.width).toBeCloseTo(384, 0);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }
            });
            it('ensure line chart is cleared when an empty dataview is applied', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var catCount = $('.lineChart').find('.line').length;
                    expect(catCount).toBe(1);
                    v.onDataChanged({
                        dataViews: [{
                                metadata: dataViewMetadata,
                                categorical: {
                                    categories: [{
                                            source: dataViewMetadata.columns[0],
                                            values: []
                                        }],
                                    values: DataViewTransform.createValueColumns([])
                                }
                            }]
                    });
                    setTimeout(function () {
                        var catCountNew = $('.lineChart').find('.line').length;
                        expect(catCountNew).toBe(0);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart check if date time axis has margin allocated in DOM', function (done) {
                var dateTimeColumnsMetadata = {
                    columns: [
                        { displayName: 'Date', queryName: 'col1', type: ValueType.fromDescriptor({ dateTime: true }) },
                        { displayName: 'PowerBI Customers', queryName: 'col2', isMeasure: true }]
                };
                var dataView = {
                    metadata: dateTimeColumnsMetadata,
                    categorical: {
                        categories: [{
                                source: dateTimeColumnsMetadata.columns[0],
                                values: [new Date('2014/9/25'), new Date('2014/12/12'), new Date('2015/9/25')]
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dateTimeColumnsMetadata.columns[1],
                                values: [8000, 20000, 1000000],
                            }])
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var ticks = $('.lineChart .axisGraphicsContext .x.axis .tick text');
                    expect(ticks.length).toBe(4);
                    var expectedValues = [
                        'Sep 2014',
                        'Jan 2015',
                        'May 2015',
                        'Sep 2015'];
                    for (var i = 0, ilen = ticks.length; i < ilen; i++) {
                        var tick = $(ticks[i]).text();
                        var tickDate = new Date(tick).toUTCString();
                        var expectedDate = new Date(expectedValues[i]).toUTCString();
                        expect(tickDate).toEqual(expectedDate);
                    }
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Line chart with an undefined domain', function (done) {
                var dateTimeColumnsMetadata = {
                    columns: [
                        { displayName: 'Date', queryName: 'Date', type: ValueType.fromDescriptor({ dateTime: true }) },
                        { displayName: 'PowerBI Fans', queryName: 'PowerBI Fans', isMeasure: true, type: ValueType.fromDescriptor({ numeric: true }) }]
                };
                var dataView = {
                    metadata: dateTimeColumnsMetadata,
                    categorical: {
                        categories: [{
                                source: dateTimeColumnsMetadata.columns[0],
                                values: []
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dateTimeColumnsMetadata.columns[1],
                                values: [],
                            }])
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with small interval dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [1.000, 0.995, 0.990, 0.985, 0.995],
                                        subtotal: 4.965
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.984');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart validate auto margin', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['ReallyLongValuesSoYouRotate1', 'ReallyLongValuesSoYouRotate2', 'ReallyLongValuesSoYouRotate3', 'ReallyLongValuesSoYouRotate4', 'ReallyLongValuesSoYouRotate5']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[3],
                                        values: [50000, 45000, 49000, 48000, 52000],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var yTranslate = parseFloat($('.lineChart .axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                    var xTranslate = parseFloat($('.lineChart .axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                    v.onDataChanged({
                        dataViews: [{
                                metadata: dataViewMetadata,
                                categorical: {
                                    categories: [{
                                            source: dataViewMetadata.columns[0],
                                            values: ['a', 'b', 'c', 'd', 'e']
                                        }],
                                    values: DataViewTransform.createValueColumns([{
                                            source: dataViewMetadata.columns[3],
                                            values: [0, 1, 2, 3, 4],
                                        }])
                                }
                            }]
                    });
                    setTimeout(function () {
                        var newYTranslate = parseFloat($('.lineChart .axisGraphicsContext .x.axis').attr('transform').split(',')[1].replace('(', ''));
                        var newXTranslate = parseFloat($('.lineChart .axisGraphicsContext .y.axis').attr('transform').split(',')[0].split('(')[1]);
                        expect(yTranslate).toBeLessThan(newYTranslate);
                        expect(xTranslate).toBeLessThan(newXTranslate);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart multi-series dom validation', function (done) {
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            queryName: 'col1',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                        },
                        {
                            displayName: 'col2',
                            queryName: 'col2',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        },
                        {
                            displayName: 'col3',
                            queryName: 'col3',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        }]
                };
                var seriesIdentities = [
                    powerbitests.mocks.dataViewScopeIdentity('col2'),
                    powerbitests.mocks.dataViewScopeIdentity('col3'),
                ];
                var measureColumn = { displayName: 'sales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
                var col3Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesIdentities[0],
                    }, {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesIdentities[1],
                    }], [col3Ref]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e'],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: valueColumns
                            }
                        }]
                });
                setTimeout(function () {
                    var lines = $('.lineChart .mainGraphicsContext .line');
                    expect(lines.length).toEqual(2);
                    var lineOne = $(lines.get(0)).attr('style');
                    expect(lineOne).toBeDefined();
                    var lineTwo = $(lines.get(1)).attr('style');
                    expect(lineTwo).toBeDefined();
                    if (!interactiveChart)
                        expect($('.legendTitle').text()).toBe('sales');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with nulls dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [0, 10, null, 15, 5],
                                        subtotal: 20
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .mainGraphicsContext .line')[0].getAttribute('d')).toBeDefined();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('Regression Test: Ensure chart does not miraculously shrink with data updates', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    },
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var svg = $('.lineChart svg');
                    var height = svg.height();
                    //expect(svg.length).toBe(3);
                    for (var i = 0; i < 5; i++) {
                        v.onDataChanged({
                            dataViews: [{
                                    metadata: dataViewMetadata,
                                    categorical: {
                                        categories: [{
                                                source: dataViewMetadata.columns[0],
                                                values: ['a', 'b', 'c', 'd', 'e']
                                            }],
                                        values: DataViewTransform.createValueColumns([{
                                                source: dataViewMetadata.columns[1],
                                                values: [1, 2, 3, 4, 5],
                                                subtotal: 15
                                            },
                                            {
                                                source: dataViewMetadata.columns[1],
                                                values: [1, 2, 3, 4, 6],
                                                subtotal: 16
                                            }])
                                    }
                                }]
                        });
                    }
                    setTimeout(function () {
                        var newHeight = $('.lineChart svg').height();
                        expect(newHeight).toBe(height);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with null points dom validation (in the middle)', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [null, 10, null, 15, null],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(!interactiveChart ? 2 : 5);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(2);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with null points dom validation (first and last)', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [10, null, 5, null, 15],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(!interactiveChart ? 3 : 5);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(3);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with null points dom validation (first and last) - scalar does not draw dots', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithScalarObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[2],
                                        values: [new Date("2014/1/1"), new Date("2014/2/1"), new Date("2014/3/1"), new Date("2014/4/1"), new Date("2014/5/1")]
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [10, null, 5, null, 15],
                                        subtotal: 15
                                    }])
                            },
                        }]
                });
                setTimeout(function () {
                    var dots = $('.dot').filter('[r^="4"]');
                    expect(dots.length).toBe(0);
                    var lines = $('.lineChart .mainGraphicsContext .line');
                    expect(lines.length).toBe(1);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('ensure selection circle is removed from dom when series is dropped', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [null, 10, null, 15, null],
                                        subtotal: 15
                                    },
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [null, 10, null, 15, null],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var dots = $('.selection-circle');
                    expect(dots.length).toBe(!interactiveChart ? 0 : 2);
                    v.onDataChanged({
                        dataViews: [{
                                metadata: dataViewMetadata,
                                categorical: {
                                    categories: [{
                                            source: dataViewMetadata.columns[0],
                                            values: ['a', 'b', 'c', 'd', 'e']
                                        }],
                                    values: DataViewTransform.createValueColumns([{
                                            source: dataViewMetadata.columns[1],
                                            values: [null, 10, null, 15, null],
                                            subtotal: 15
                                        }])
                                }
                            }]
                    });
                    setTimeout(function () {
                        var dots = $('.selection-circle');
                        expect(dots.length).toBe(!interactiveChart ? 0 : 1);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart non-category multi-measure dom validation', function (done) {
                var metadata = {
                    columns: [
                        { displayName: 'col1', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                        { displayName: 'col2', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                    ]
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadata.columns[0],
                                        values: [100]
                                    }, {
                                        source: dataViewMetadata.columns[1],
                                        values: [200]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    if (interactiveChart) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(2);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(1)').attr('r')).toEqual('4');
                    }
                    else {
                        expect($('.lineChart')).toBeInDOM();
                    }
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart series only dom validation', function (done) {
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            queryName: 'col1',
                            properties: { Series: true },
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                        },
                        {
                            displayName: 'col2',
                            queryName: 'col2',
                            properties: { Y: true },
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        }
                    ]
                };
                v.onDataChanged({
                    dataViews: [DataViewPivotCategorical.apply({
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [
                                            powerbitests.mocks.dataViewScopeIdentity('a'),
                                            powerbitests.mocks.dataViewScopeIdentity('b'),
                                            powerbitests.mocks.dataViewScopeIdentity('c'),
                                        ],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3]
                                    }])
                            }
                        })]
                });
                setTimeout(function () {
                    if (interactiveChart) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(3);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(1)').attr('r')).toEqual('4');
                        expect($('.lineChart .hover-line .selection-circle:eq(2)').attr('r')).toEqual('4');
                    }
                    else {
                        expect($('.lineChart')).toBeInDOM();
                    }
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('empty line chart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: []
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with single point dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [4]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var dots = $('.dot');
                    expect(dots.length).toBe(1);
                    var visibleDots = dots.filter('[r^="4"]');
                    expect(visibleDots.length).toBe(1);
                    if (interactiveChart) {
                        expect($('.lineChart .hover-line .selection-circle').length).toEqual(1);
                        expect($('.lineChart .hover-line .selection-circle:eq(0)').attr('r')).toEqual('4');
                    }
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('5');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart does not show less ticks dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [26.125, 26.125]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('30');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart shows less ticks dom validation', function (done) {
                var dataViewMetadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            queryName: 'col1',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                        },
                        {
                            displayName: 'col2',
                            queryName: 'col2',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        }],
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [5, 5]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('6');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart on small tile shows at least two tick lines dom validation', function (done) {
                v.onResizing({
                    height: 101,
                    width: 226
                });
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [0.1495, 0.15, 0.1633]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.150');
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('0.160');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart zero axis line is darkened', function (done) {
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            isMeasure: false,
                            properties: { Series: true },
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: false,
                            properties: { Y: true },
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        }
                    ]
                };
                v.onDataChanged({
                    dataViews: [DataViewPivotCategorical.apply({
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c'],
                                        identity: [
                                            powerbitests.mocks.dataViewScopeIdentity('a'),
                                            powerbitests.mocks.dataViewScopeIdentity('b'),
                                            powerbitests.mocks.dataViewScopeIdentity('c'),
                                        ],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [-1, 2, -3]
                                    }])
                            }
                        })]
                });
                setTimeout(function () {
                    var zeroTicks = $('g.tick:has(line.zero-line)');
                    expect(zeroTicks.length).toBe(2);
                    zeroTicks.each(function (i, item) {
                        expect(d3.select(item).datum() === 0).toBe(true);
                    });
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        }
        describe("lineChart DOM validation", function () { return lineChartDomValidation(false); });
        describe("interactive lineChart DOM validation", function () { return lineChartDomValidation(true); });
        function areaChartDomValidation(interactiveChart) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                    },
                    {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }]
            };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('areaChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            it('check area rendered', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [50000, 49500, 49000, 48000, 50000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('check linear scale with big interval renders', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('480K');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('check linear scale with small interval renders', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [1.000, 0.995, 0.990, 0.985, 0.995],
                                        subtotal: 4.965
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.cat')).toBeDefined();
                    expect($('.catArea')).toBeDefined();
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.98');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('empty areaChart dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: []
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .x.axis .tick').length).toBe(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                    expect($('.lineChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('10');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        }
        describe("areaChart DOM validation", function () { return areaChartDomValidation(false); });
        describe("interactive areaChart DOM validation", function () { return areaChartDomValidation(true); });
        //Data Labels
        function lineChartDataLabelsValidation(interactiveChart) {
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                    },
                    {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    },
                    {
                        displayName: 'col3',
                        queryName: 'col3',
                        isMeasure: false,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),
                        format: 'd'
                    }],
            };
            var dataViewMetadataWithLabelsOnObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsOnObject.objects = { labels: { show: true, labelPrecision: 0 } };
            var dataViewMetadataWithLabelsOffObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsOffObject.objects = { labels: { show: false } };
            var dataViewMetadataWithDisplayUnitsObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithDisplayUnitsObject.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 0 } };
            var dataViewMetadataWithDisplayUnitsAndPrecisionObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithDisplayUnitsAndPrecisionObject.objects = { labels: { show: true, labelDisplayUnits: 1000, labelPrecision: 1 } };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: hostServices,
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true },
                    interactivity: { isInteractiveLegend: interactiveChart },
                });
            });
            it('line chart show labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabelsOnObject.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOnObject.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBeGreaterThan(0);
                    // First and last labels are hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('495K');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart labels style validation', function (done) {
                var opacity = '1';
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabelsOnObject.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOnObject.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var fill = $('.lineChart .axisGraphicsContext .labels .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill)).toBe(labelColor);
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().css('fill-opacity')).toBe(opacity);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart labels custom style validation', function (done) {
                var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
                var dataViewMetadataWithLabelsFillObject = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadataWithLabelsFillObject.objects = { labels: { show: true, color: color } };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsFillObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadataWithLabelsFillObject.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsFillObject.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var fill = $('.lineChart .axisGraphicsContext .labels .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill)).toBe(ColorUtility.convertFromRGBorHexToHex(color.solid.color));
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart hide labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOffObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOffObject.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('labels should support display units with no precision', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithDisplayUnitsObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOffObject.columns[1],
                                        values: [500123, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('500K');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('labels should support display units with precision', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithDisplayUnitsAndPrecisionObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOffObject.columns[1],
                                        values: [500123, 495000, 490000, 480000, 500000],
                                        subtotal: 246500
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('500.1K');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            //multi series
            it('line chart data labels multi-series', function (done) {
                var seriesScopeIdentities = [powerbitests.mocks.dataViewScopeIdentity('col2'), powerbitests.mocks.dataViewScopeIdentity('col3')];
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text),
                        },
                        {
                            displayName: 'col2',
                            queryName: 'col2',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                            format: '#,0.00'
                        },
                        {
                            displayName: 'col3',
                            queryName: 'col3',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                            format: '$#,0'
                        }]
                };
                metadata.objects = { labels: { show: true } };
                var measureColumn = { displayName: 'sales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
                var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    }, {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesScopeIdentities[1],
                    }], [measureColumnRef]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e'],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: valueColumns
                            }
                        }]
                });
                setTimeout(function () {
                    var fill0 = $('.lineChart .axisGraphicsContext .labels .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill0)).toBe(labelColor);
                    var fill1 = $('.lineChart .axisGraphicsContext .labels .data-labels').last().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill1)).toBe(labelColor);
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('110.00');
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').last().text()).toBe('$250');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart data labels multi-series to one series', function (done) {
                var seriesScopeIdentities = [powerbitests.mocks.dataViewScopeIdentity('col2'), powerbitests.mocks.dataViewScopeIdentity('col3')];
                var metadata = {
                    columns: [
                        {
                            displayName: 'col1',
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                        },
                        {
                            displayName: 'col2',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        },
                        {
                            displayName: 'col3',
                            isMeasure: true,
                            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                        }]
                };
                metadata.objects = { labels: { show: true } };
                var measureColumn = { displayName: 'sales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
                var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
                var valueColumns = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    }, {
                        source: metadata.columns[2],
                        values: [210, 220, 230, 240, 250],
                        identity: seriesScopeIdentities[1],
                    }], [measureColumnRef]);
                valueColumns.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e'],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: valueColumns
                            }
                        }]
                });
                //to one series
                var valueColumns2 = DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [110, 120, 130, 140, 150],
                        identity: seriesScopeIdentities[0],
                    }], [measureColumnRef]);
                valueColumns2.source = measureColumn;
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                categories: [{
                                        source: metadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e'],
                                        identityFields: [categoryColumnRef],
                                    }],
                                values: valueColumns2
                            }
                        }]
                });
                setTimeout(function () {
                    var fill0 = $('.lineChart .axisGraphicsContext .labels .data-labels').first().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill0)).toBe(labelColor);
                    var fill1 = $('.lineChart .axisGraphicsContext .labels .data-labels').last().css('fill');
                    expect(ColorUtility.convertFromRGBorHexToHex(fill1)).toBe(labelColor);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart with nulls dom validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [null, 10, null, 15, null],
                                        subtotal: 20
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    // One label is hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(1);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('change line chart dom data label validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOnObject.columns[1],
                                        values: [500000, 495000, 490000, 480000, 500000],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(3);
                    // First and last labels are hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('495K');
                    v.onDataChanged({
                        dataViews: [{
                                metadata: dataViewMetadataWithLabelsOnObject,
                                categorical: {
                                    categories: [{
                                            source: dataViewMetadata.columns[0],
                                            values: ['q', 'w', 'r', 't']
                                        }],
                                    values: DataViewTransform.createValueColumns([{
                                            source: dataViewMetadataWithLabelsOnObject.columns[1],
                                            values: [400, 500, 300, 200],
                                        }])
                                }
                            }]
                    });
                    setTimeout(function () {
                        // One label is hidden due to collision detection
                        expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(3);
                        expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toBe('400');
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
            it('line chart non-category multi-measure dom data label validation', function (done) {
                var metadata = {
                    columns: [
                        { displayName: 'col1', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                        { displayName: 'col2', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                    ]
                };
                metadata.objects = { labels: { show: true } };
                v.onDataChanged({
                    dataViews: [{
                            metadata: metadata,
                            categorical: {
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadata.columns[0],
                                        values: [100]
                                    }, {
                                        source: dataViewMetadata.columns[1],
                                        values: [200]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    // One label is hidden due to collision detection
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(1);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            //empty dom
            it('empty line chart dom data labels validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: []
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            //One point
            it('line chart with single point dom data label validation', function (done) {
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['a']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [4]
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.lineChart .axisGraphicsContext .labels .data-labels').text()).toBe('4');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        }
        describe("lineChart Data Labels validation", function () { return lineChartDataLabelsValidation(false); });
        describe("interactive lineChart Data Labels validation", function () { return lineChartDataLabelsValidation(true); });
    });
    describe("Line Chart Legend Formatting", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    format: 'd',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: [new Date("Thu Dec 18 2014 00:08:00"),
                                        new Date("Thu Dec 19 2014 00:20:00"),
                                        new Date("Thu Dec 20 2014 00:11:00")]
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
        });
        it('verify legend formatted as date', function () {
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('12/18/2014');
        });
    });
    describe("Line Chart Interactivity", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer)
                }],
            objects: {
                labels: {
                    show: true,
                    labelPrecision: 0,
                }
            }
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
        });
        it('line chart drag and click interaction validation', function () {
            var lineChart = v.layers[0];
            var mainGraphicsContext = $('.mainGraphicsContext');
            expect(mainGraphicsContext.length).toBe(1);
            // instead of clicking on the graph, which can be unstable due to different user's configurations
            // we will validate that the code knows how to deal with such a click
            var calculatedIndex = lineChart.findIndex(250);
            expect(calculatedIndex).toBe(2);
        });
        it('select column validation', function () {
            var lineChart = v.layers[0];
            spyOn(lineChart, 'setHoverLine').and.callThrough();
            ;
            // trigger select column
            lineChart.selectColumn(2);
            // verify legend was changed to correct values
            var legend = $('.interactive-legend');
            var title = legend.find('.title');
            var item = legend.find('.item');
            var hoverLine = $('.hover-line');
            expect(legend.length).toBe(1);
            expect(title.text().trim()).toBe('c');
            expect(item.find('.itemName').text()).toBe('col2');
            expect(item.find('.itemMeasure').text().trim()).toBe('490000');
            expect(lineChart.setHoverLine).toHaveBeenCalled();
            var arg = lineChart.setHoverLine.calls ? lineChart.setHoverLine.calls.allArgs()[0][0] : 193;
            expect(Math.floor(arg) === 192 || arg === 193).toBeTruthy();
            expect(hoverLine.length).toBe(1);
        });
    });
    describe("Line Chart Interactivity - Creation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            // Invoke onDataChange to force creation of chart layers.
            v.onDataChanged({ dataViews: [] });
        });
        it('select column validation', function () {
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            var hoverLine = $('.hover-line');
            expect(lineChart.selectColumn).toHaveBeenCalledWith(0, true);
            expect(hoverLine.length).toBe(1);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                },
                {
                    displayName: 'col4',
                    queryName: 'col4',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c'],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadata.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadata.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadata.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(3);
                expect(points[0].displayName).toEqual('col2');
                expect(points[0].properties['fill']).toBeDefined();
                expect(points[1].displayName).toEqual('col3');
                expect(points[1].properties['fill']).toBeDefined();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Line Chart Scrollbar Validation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('150', '50');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                scrollableVisuals: true,
            }).getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000, 500000, 500000, 500000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
        });
        it('Line Chart Scrollbar DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.lineChart')).toBeInDOM();
                expect($('rect.extent').length).toBe(1);
                var transform = SVGUtil.parseTranslateTransform($('.lineChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').first().attr('transform').split(',')[0].split('(')[1]).toBe('22.5');
                expect($('.brush').first().attr('transform').split(',')[1].split(')')[0]).toBe('75');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(1);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        describe("xAxis Validations", function () {
            var path;
            var points;
            var gap;
            var lastIndex;
            var v, element;
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }, {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    },
                    {
                        displayName: 'col3',
                        queryName: 'col3',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }],
            };
            var nonNumericDataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                    }, {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    },
                    {
                        displayName: 'col3',
                        queryName: 'col3',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }],
            };
            beforeEach(function () {
                element = powerbitests.helpers.testDom('500', '500');
                v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
                v.init({
                    element: element,
                    host: powerbitests.mocks.createVisualHostServices(),
                    style: powerbi.visuals.visualStyles.create(),
                    viewport: {
                        height: element.height(),
                        width: element.width()
                    },
                    animation: { transitionImmediate: true }
                });
            });
            function setAxis(xType) {
                points = [];
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: xType,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                var dataChangedOptions = {
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: [1, 2, 5, 10, 20],
                                    }],
                                values: DataViewTransform.createValueColumns([
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [100, 200, 300, 400, 500]
                                    }, {
                                        source: dataViewMetadata.columns[2],
                                        values: [200, 400, 600, 800, 1000]
                                    }])
                            }
                        }]
                };
                v.onDataChanged(dataChangedOptions);
                path = $('.line').first().attr('d');
                var dots = path.split('L');
                dots[0] = dots[0].substr(1);
                for (var i = 0; i < dots.length; i++) {
                    var strPoint = dots[i].split(',');
                    var point = { x: strPoint[0], y: strPoint[1] };
                    points.push(point);
                }
                gap = +points[1].x - +points[0].x;
                lastIndex = points.length - 1;
            }
            it('Category vs Scalar Check', function () {
                setAxis(AxisType.scalar);
                expect(+points[lastIndex].x - +points[lastIndex - 1].x).toBeGreaterThan(gap);
                setAxis(AxisType.categorical);
                expect(+points[lastIndex].x - +points[lastIndex - 1].x).toBeCloseTo(gap, 2);
            });
            it('enumerateObjectInstances: Verify instances on ordinal category axis', function () {
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: nonNumericDataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: nonNumericDataViewMetadata.columns[0],
                                        values: ['a', 'b', 'c', 'd', 'e']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: nonNumericDataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    },
                                    {
                                        source: nonNumericDataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points[0].properties['start']).toBeUndefined();
                expect(points[0].properties['end']).toBeUndefined();
                expect(points[0].properties['axisType']).toBeUndefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
            });
            it('enumerateObjectInstances: Verify instances on numerical category axis', function () {
                dataViewMetadata.objects = {
                    categoryAxis: {
                        show: true,
                        start: 0,
                        end: 25,
                        axisType: AxisType.scalar,
                        showAxisTitle: true,
                        axisStyle: true
                    }
                };
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: [1, 2, 3, 4, 5]
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    },
                                    {
                                        source: dataViewMetadata.columns[1],
                                        values: [1, 2, 3, 4, 5],
                                        subtotal: 15
                                    }])
                            }
                        }]
                });
                var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
                expect(points[0].properties['start']).toBeDefined();
                expect(points[0].properties['end']).toBeDefined();
                expect(points[0].properties['axisType']).toBeDefined();
                expect(points[0].properties['show']).toBeDefined;
                expect(points[0].properties['showAxisTitle']).toBeDefined;
                expect(points[0].properties['axisStyle']).toBeDefined;
            });
        });
    });
    describe("Area Chart Scrollbar Validation", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                }, {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }],
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('150', '50');
            v = powerbi.visuals.visualPluginFactory.createMinerva({
                scrollableVisuals: true,
            }).getPlugin('areaChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000, 500000, 500000, 500000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
        });
        it('Area Chart Scrollbar DOM Validation', function (done) {
            setTimeout(function () {
                expect($('.catArea')).toBeInDOM();
                expect($('rect.extent').length).toBe(1);
                var transform = SVGUtil.parseTranslateTransform($('.lineChart .axisGraphicsContext .x.axis .tick').last().attr('transform'));
                expect(transform.x).toBeLessThan(element.width());
                expect($('.brush').first().attr('transform').split(',')[0].split('(')[1]).toBe('22.5');
                expect($('.brush').first().attr('transform').split(',')[1].split(')')[0]).toBe('75');
                expect(parseInt($('.brush .extent')[0].attributes.getNamedItem('width').value, 0)).toBeGreaterThan(1);
                expect($('.brush .extent')[0].attributes.getNamedItem('x').value).toBe('0');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Line Chart Tooltips", function () {
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var v, element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            // Invoke onDataChange to force creation of chart layers.
            v.onDataChanged({ dataViews: [] });
        });
        it('Scalar xAxis - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }, {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }],
            };
            var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: [2001, 2002, 2003, 2004, 2005],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            var lineChart = v.layers[0];
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2001' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2002' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2004' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2005' }, { displayName: 'col2', value: '500000' }]);
        });
        it('Scalar xAxis, multi series - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }, {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    },
                    {
                        displayName: 'col3',
                        queryName: 'col3',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                        isMeasure: true
                    }],
            };
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('col2'),
                powerbitests.mocks.dataViewScopeIdentity('col3'),
            ];
            var measureColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col2' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: dataViewMetadata.columns[1],
                    values: [500000, 495000, 490000, 480000, 500000],
                    identity: seriesIdentities[0],
                }, {
                    source: dataViewMetadata.columns[2],
                    values: [null, null, 490000, 480000, 500000],
                    identity: seriesIdentities[1],
                }], [measureColumnRef]);
            valueColumns.source = dataViewMetadata.columns[2];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: [2001, 2002, 2003, 2004, 2005]
                        }],
                    values: valueColumns
                }
            };
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [dataView]
            });
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2001' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2002' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2004' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: '2005' }, { displayName: 'col3', value: '(Blank)' }, { displayName: 'col2', value: '500000' }]);
        });
        it('Line Chart X and Y-axis show/hide Title ', function () {
            var element = powerbitests.helpers.testDom('500', '500');
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var categoryIdentities = [powerbitests.mocks.dataViewScopeIdentity("John Domo")];
            var v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
            });
            var dataViewMetadataOneColumn = {
                columns: [
                    {
                        displayName: 'AxesTitleTest',
                        queryName: 'AxesTitleTest',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }],
                objects: {
                    categoryAxis: {
                        showAxisTitle: true
                    },
                    valueAxis: {
                        showAxisTitle: true
                    }
                }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataOneColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataOneColumn.columns[0],
                                    values: [500, 2000, 5000, 10000],
                                    identity: categoryIdentities
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataOneColumn.columns[0],
                                    values: [20, 1000],
                                    subtotal: 1020
                                }])
                        }
                    }]
            });
            expect($('.xAxisLabel').first().text()).toBe('AxesTitleTest');
            expect($('.yAxisLabel').first().text()).toBe('AxesTitleTest');
            dataViewMetadataOneColumn.objects = {
                categoryAxis: {
                    showAxisTitle: false
                },
                valueAxis: {
                    showAxisTitle: false
                }
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataOneColumn,
                    }]
            });
            expect($('.xAxisLabel').length).toBe(0);
            expect($('.yAxisLabel').length).toBe(0);
        });
        it('Non scalar xAxis - closest data point', function () {
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: 'col1',
                        queryName: 'col1',
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                    }, {
                        displayName: 'col2',
                        queryName: 'col2',
                        isMeasure: true,
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }],
            };
            var lineChart = v.layers[0];
            spyOn(lineChart, 'selectColumn').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            var lineChart = v.layers[0];
            var pointX = 10;
            var dataPoint = lineChart.data.series[0];
            var tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col2', value: '500000' }]);
            pointX = 120;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col2', value: '495000' }]);
            pointX = 303;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'd' }, { displayName: 'col2', value: '480000' }]);
            pointX = 450;
            tooltipInfo = LineChart.getTooltipInfoByPointX(lineChart, dataPoint, pointX);
            expect(tooltipInfo).toEqual([{ displayName: 'col1', value: 'e' }, { displayName: 'col2', value: '500000' }]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var Map = powerbi.visuals.Map;
    var DataLabelUtils = powerbi.visuals.dataLabelUtils;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    var LegendPosition = powerbi.visuals.LegendPosition;
    powerbitests.mocks.setLocale();
    describe("Map", function () {
        var element;
        var mockGeotaggingAnalyzerService;
        beforeEach(function () {
            mockGeotaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(function (stringId) { return powerbitests.mocks.getLocalizedString(stringId); });
            element = powerbitests.helpers.testDom('800', '500');
        });
        it('Map registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('map').capabilities).toBe(powerbi.visuals.mapCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.mapCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.mapCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.mapCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('Capabilities DataRole preferredTypes', function () {
            //Map's Category, X and Y fieldWells have preferences for geographic locations, longitude and latitude respectively
            expect(powerbi.visuals.mapCapabilities.dataRoles.map(function (r) { return !!r.preferredTypes; })).toEqual([
                true,
                false,
                true,
                true,
                false,
                false,
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[0].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromExtendedType(powerbi.ExtendedType.Address),
                ValueType.fromExtendedType(powerbi.ExtendedType.City),
                ValueType.fromExtendedType(powerbi.ExtendedType.Continent),
                ValueType.fromExtendedType(powerbi.ExtendedType.Country),
                ValueType.fromExtendedType(powerbi.ExtendedType.County),
                ValueType.fromExtendedType(powerbi.ExtendedType.Place),
                ValueType.fromExtendedType(powerbi.ExtendedType.PostalCode_Text),
                ValueType.fromExtendedType(powerbi.ExtendedType.Region),
                ValueType.fromExtendedType(powerbi.ExtendedType.StateOrProvince)
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[2].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double, "Longitude")
            ]);
            expect(powerbi.visuals.mapCapabilities.dataRoles[3].preferredTypes.map(ValueType.fromDescriptor)).toEqual([
                ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double, "Latitude")
            ]);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.mapCapabilities.objects)).toEqual(powerbi.visuals.mapProps.general.formatString);
        });
        it('Map.getMeasureIndexOfRole', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [1, 2, 3],
                            subtotal: 6
                        }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(0);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(1);
        });
        it('Map.calculateGroupSizes', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var groupSizeTotals = [];
            var range = null;
            var sizeIndex = 0;
            var result = Map.calculateGroupSizes(dataView.categorical, grouped, groupSizeTotals, sizeIndex, range);
            expect(result.min).toBe(-100);
            expect(result.max).toBe(700);
            expect(groupSizeTotals.length).toBe(3);
            expect(groupSizeTotals[0]).toBe(-100);
            expect(groupSizeTotals[1]).toBe(200);
            expect(groupSizeTotals[2]).toBe(700);
            groupSizeTotals = [];
            sizeIndex = -1;
            result = Map.calculateGroupSizes(dataView.categorical, grouped, groupSizeTotals, sizeIndex, range);
            expect(result).toBe(null);
            expect(groupSizeTotals.length).toBe(3);
            expect(groupSizeTotals[0]).toBe(null);
            expect(groupSizeTotals[1]).toBe(null);
            expect(groupSizeTotals[2]).toBe(null);
        });
        it('Map.createMapDataPoint', function () {
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var group = "Arizona";
            var value = 100;
            var mapSeriesInfo = {
                sizeValuesForGroup: [{
                        value: 100,
                        index: 0,
                        fill: "#112233",
                        stroke: "#223344",
                        seriesId: powerbitests.mocks.dataViewScopeIdentity("Sales"),
                    }],
                latitude: null,
                longitude: null,
            };
            var radius = 3;
            // No seriesInfo means the result is null
            var result = Map.createMapDataPoint(group, value, null, radius, colors, null);
            expect(result).toBe(null);
            result = Map.createMapDataPoint(group, value, mapSeriesInfo, radius, colors, powerbitests.mocks.dataViewScopeIdentity("Arizona"));
            expect(result.seriesInfo).toBe(mapSeriesInfo);
            expect(result.radius).toBe(radius);
            expect(result.location).toBe(null);
            expect(result.cachedLocation).toBe(result.location);
            expect(result.geocodingQuery).toBe(group);
            expect(result.categoryValue).toBe(group);
            // No group, latitude, or longitude shouldn't render
            group = null;
            result = Map.createMapDataPoint(group, value, mapSeriesInfo, radius, colors, null);
            expect(result).toBe(null);
        });
        it('Map.calculateSeriesInfo', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, latIndex, longIndex, colors);
            expect(result.sizeValuesForGroup.length).toBe(1);
            expect(result.sizeValuesForGroup[0].value).toBe(-100);
            expect(result.sizeValuesForGroup[0].index).toBe(0);
            expect(result.latitude).toBe(null);
            expect(result.longitude).toBe(null);
        });
        function getDataViewMultiSeries(firstGroupName, secondGroupName) {
            if (firstGroupName === void 0) { firstGroupName = 'Canada'; }
            if (secondGroupName === void 0) { secondGroupName = 'United States'; }
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: '',
                        format: '0',
                    }, {
                        displayName: '',
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                        groupName: firstGroupName,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                        groupName: firstGroupName,
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                        groupName: secondGroupName,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                        groupName: secondGroupName,
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                    }
                ]
            };
            var colP1Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p1' });
            var colP2Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p2' });
            var seriesValues = [null, firstGroupName, secondGroupName];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var dataViewValueColumns = [
                {
                    source: dataViewMetadata.columns[2],
                    values: [150, 177, 157],
                    identity: seriesIdentities[1],
                }, {
                    source: dataViewMetadata.columns[3],
                    values: [30, 25, 28],
                    identity: seriesIdentities[1],
                }, {
                    source: dataViewMetadata.columns[4],
                    values: [100, 149, 144],
                    identity: seriesIdentities[2],
                }, {
                    source: dataViewMetadata.columns[5],
                    values: [300, 250, 280],
                    identity: seriesIdentities[2],
                }
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: [2012, 2011, 2010],
                            identity: [seriesIdentities[0]],
                            identityFields: [
                                colP1Ref
                            ]
                        }],
                    values: DataViewTransform.createValueColumns(dataViewValueColumns, [colP2Ref])
                },
            };
            dataView.categorical.values.source = dataViewMetadata.columns[1];
            return dataView;
        }
        it('Map.calculateSeriesInfo multi-series', function () {
            var dataView = getDataViewMultiSeries();
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var categoryColumnRef = dataView.categorical.values.identityFields;
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors, undefined, undefined, categoryColumnRef);
            expect(result.sizeValuesForGroup.length).toBe(2);
            expect(result.sizeValuesForGroup[0].value).toBe(150);
            expect(result.sizeValuesForGroup[0].index).toBe(0);
            expect(result.sizeValuesForGroup[0].fill).not.toBeNull();
            expect(result.sizeValuesForGroup[0].stroke).not.toBeNull();
            expect(result.sizeValuesForGroup[1].value).toBe(100);
            expect(result.sizeValuesForGroup[1].index).toBe(1);
            expect(result.sizeValuesForGroup[1].fill).not.toBeNull();
            expect(result.sizeValuesForGroup[1].stroke).not.toBeNull();
            expect(result.sizeValuesForGroup[1].fill).not.toBe(result.sizeValuesForGroup[0].fill);
            expect(result.latitude).toBe(null);
            expect(result.longitude).toBe(null);
        });
        it('Map.calculateSeriesInfo with lat long and no size', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [46.87, 37.81, 34.68],
                            subtotal: 72.49
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [-114, -122.46, -111.76],
                            subtotal: -348.22
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = -1;
            var latIndex = 0;
            var longIndex = 1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors);
            expect(result.sizeValuesForGroup.length).toBe(1);
            expect(result.sizeValuesForGroup[0].value).toBe(null);
            expect(result.sizeValuesForGroup[0].index).toBe(0);
            expect(result.latitude).toBe(46.87);
            expect(result.longitude).toBe(-114);
        });
        it('Map.calculateSeriesLegend colors from palette with dynamic series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2' },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, groupName: 'a' },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, groupName: 'b' },
                ]
            };
            var col3Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col3' });
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, 'a'),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, 'b')
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona'],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[2],
                            values: [-100, 200, 700],
                            identity: seriesIdentities[0],
                        }, {
                            source: dataViewMetadata.columns[3],
                            values: [200, 400, 500],
                            identity: seriesIdentities[1],
                        }], [col3Ref])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(col3Ref)).getColor('a');
            var series2Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(col3Ref)).getColor('b');
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, undefined, [col3Ref]);
            expect(result.length).toBe(2);
            expect(result[0].color).toBe(series1Color.value);
            expect(result[1].color).toBe(series2Color.value);
        });
        it('Map.calculateSeriesLegend colors from palette with static series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true },
                ]
            };
            var col1Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col1' });
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('col2'),
                powerbitests.mocks.dataViewScopeIdentity('col3'),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona'],
                            identityFields: [col1Ref],
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            identity: seriesIdentities[0],
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [200, 400, 500],
                            identity: seriesIdentities[1],
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var series1Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(col1Ref)).getColor('col2').value;
            var series2Color = colors.getColorScaleByKey(SQExprShortSerializer.serialize(col1Ref)).getColor('col3').value;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, undefined, [col1Ref]);
            expect(result.length).toBe(2);
            expect(result[0].color).toBe(series1Color);
            expect(result[1].color).toBe(series2Color);
        });
        // TODO: verify this works when 4906998 is fixed
        //it('Map.calculateSeriesInfo same field category & series',() => {
        //    var dataViewMetadata: powerbi.DataViewMetadata = {
        //        columns: [
        //            { displayName: 'col1', roles: { 'Category': true, 'Series': true } },
        //            { displayName: 'col2', isMeasure: true, queryName: 'selectCol2' },
        //            { displayName: 'lat', isMeasure: true, queryName: 'selectLat' },
        //            { displayName: 'long', isMeasure: true, queryName: 'selectLong' },
        //        ]
        //    };
        //    var dataView: powerbi.DataView = powerbi.data.DataViewSelfCrossJoin.apply({
        //        metadata: dataViewMetadata,
        //        categorical: {
        //            categories: [{
        //                source: dataViewMetadata.columns[0],
        //                values: ['Montana', 'California', 'Arizona'],
        //                identity: [mocks.dataViewScopeIdentity('M'), mocks.dataViewScopeIdentity('C'), mocks.dataViewScopeIdentity('A')]
        //            }],
        //            values: DataViewTransform.createValueColumns([
        //                {
        //                    source: dataViewMetadata.columns[1],
        //                    values: [-100, 200, 700],
        //                }, {
        //                    source: dataViewMetadata.columns[2],
        //                    values: [49, 54, 101],
        //                }, {
        //                    source: dataViewMetadata.columns[3],
        //                    values: [0, 40, 20],
        //                }
        //            ])
        //        }
        //    });
        //    var groupedValues = dataView.categorical.values.grouped();
        //    var sizeIndex = 0;
        //    var latIndex = 1;
        //    var longIndex = 2;
        //    var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
        //    var result0 = Map.calculateSeriesInfo(groupedValues, 0, sizeIndex, longIndex, latIndex, colors);
        //    expect(result0.sizeValuesForGroup.length).toBe(1);
        //    expect(result0.sizeValuesForGroup[0].value).toBe(-100);
        //    expect(result0.sizeValuesForGroup[0].index).toBe(0);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBeNull();
        //    expect(result0.sizeValuesForGroup[0].stroke).not.toBeNull();
        //    expect(result0.latitude).toBe(49);
        //    expect(result0.longitude).toBe(0);
        //    var result1 = Map.calculateSeriesInfo(groupedValues, 1, sizeIndex, longIndex, latIndex, colors);
        //    expect(result1.sizeValuesForGroup.length).toBe(1);
        //    expect(result1.latitude).toBe(54);
        //    expect(result1.longitude).toBe(40);
        //    var result2 = Map.calculateSeriesInfo(groupedValues, 2, sizeIndex, longIndex, latIndex, colors);
        //    expect(result2.sizeValuesForGroup.length).toBe(1);
        //    expect(result2.latitude).toBe(101);
        //    expect(result2.longitude).toBe(20);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBe(result1.sizeValuesForGroup[0].fill);
        //    expect(result1.sizeValuesForGroup[0].fill).not.toBe(result2.sizeValuesForGroup[0].fill);
        //    expect(result0.sizeValuesForGroup[0].fill).not.toBe(result2.sizeValuesForGroup[0].fill);
        //});
        it('Map.calculateSeriesLegend', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona'],
                            objects: [
                                { dataPoint: { fill: { solid: { color: "#FF0000" } } } },
                                { dataPoint: { fill: { solid: { color: "#00FF00" } } } },
                                { dataPoint: { fill: { solid: { color: "#0000FF" } } } }
                            ]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result.length).toBe(1);
        });
        it('Map.calculateSeriesLegend default color', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, hexDefaultColorRed);
            expect(result.length).toBe(1);
            expect(result[0].color).toBe(hexDefaultColorRed);
        });
        it('Map.calculateSeriesLegend multi-series', function () {
            var dataView = getDataViewMultiSeries();
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result.length).toBe(2);
        });
        it('Map.calculateSeriesLegend null legend', function () {
            var dataView = getDataViewMultiSeries(null);
            var groupIndex = 0, sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var result = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors);
            expect(result[0].label).toBe(powerbi.visuals.valueFormatter.format(null));
        });
        it('Map.calculateRadius', function () {
            var range = { min: -100, max: 100 };
            // Null should be the minimum size
            var diff = 0;
            var result = Map.calculateRadius(range, 0, null);
            expect(result).toBe(6);
            // Min
            diff = range.max - range.min;
            result = Map.calculateRadius(range, diff, -100);
            expect(result).toBe(6);
            // Middle of zero
            result = Map.calculateRadius(range, diff, 0);
            expect(result).toBe(14 / 2 + 6);
            // Max
            result = Map.calculateRadius(range, diff, 100);
            expect(result).toBe(20);
            // No scale (div by zero or no range scenario
            result = Map.calculateRadius({ min: 100, max: 100 }, 0, 100);
            expect(result).toBe(6);
        });
        it('Map.getGeocodingCategory', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', roles: { "StateOrProvince": true } },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, roles: { "Size": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var result = Map.getGeocodingCategory(dataView.categorical, mockGeotaggingAnalyzerService);
            expect(result).toBe("StateOrProvince");
        });
        it('Map.getGeocodingCategoryDataCategory', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', type: ValueType.fromDescriptor({ geography: { stateOrProvince: true } }) },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, roles: { "Size": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 1000
                        }])
                }
            };
            var result = Map.getGeocodingCategory(dataView.categorical, mockGeotaggingAnalyzerService);
            expect(result).toBe("StateOrProvince");
        });
        /* Disable due to way tests run in GCI */
        /*
        it('Map Geocode With Size',() => {
            
            v = powerbi.visuals.VisualFactory.getPlugin('map').create();
            v.init({
                element: element,
                host: mocks.createHostService(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });

            v.onDataChanged([dataView]);
            
            // Only validation at this point is no exceptions are thrown
        });
        */
        it('Map.hasSizeField', function () {
            var dataViewMetadataOneColumn = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', roles: { 'Category': true } }
                ]
            };
            var dataViewMetadataTwoColumnsWithRoles = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', roles: { 'Category': true } },
                    { displayName: 'col2', queryName: 'col2', roles: { 'Size': true } }
                ]
            };
            var dataViewMetadataTwoColumnsWithoutRoles = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'col2', queryName: 'col2', type: ValueType.fromDescriptor({ numeric: true }) }
                ]
            };
            var dataViewMetadataThreeColumns = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', roles: { 'Category': true } },
                    { displayName: 'col2', queryName: 'col2', roles: { 'Y': true } },
                    { displayName: 'col3', queryName: 'col3', roles: { 'X': true } }
                ]
            };
            var dataViewOneColumn = {
                metadata: dataViewMetadataOneColumn,
                categorical: {
                    categories: [{
                            source: dataViewMetadataOneColumn.columns[0],
                            values: ['98052', '98004', '98034', '12345', '67890']
                        }]
                }
            };
            var dataViewTwoColumnsWithRoles = {
                metadata: dataViewMetadataTwoColumnsWithRoles,
                categorical: {
                    categories: [{
                            source: dataViewMetadataTwoColumnsWithRoles.columns[0],
                            values: ['San Diego', 'San Francisco', 'Seattle']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumnsWithRoles.columns[1],
                            values: [3, 4, 5],
                            subtotal: 12
                        }
                    ])
                }
            };
            var dataViewTwoColumnsWithoutRoles = {
                metadata: dataViewMetadataTwoColumnsWithoutRoles,
                categorical: {
                    categories: [{
                            source: dataViewMetadataTwoColumnsWithoutRoles.columns[0],
                            values: ['San Diego', 'San Francisco', 'Seattle']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataTwoColumnsWithoutRoles.columns[1],
                            values: [3, 4, 5],
                            subtotal: 12
                        }
                    ])
                }
            };
            var dataViewThreeColumns = {
                metadata: dataViewMetadataThreeColumns,
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumns.columns[0],
                            values: ['San Diego', 'San Francisco', 'Seattle']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataThreeColumns.columns[1],
                            values: [32.715691, 37.777119, 47.603569],
                            subtotal: 39.36545966666666
                        },
                        {
                            source: dataViewMetadataThreeColumns.columns[2],
                            values: [-117.16172, -122.41964, -122.329453],
                            subtotal: -120.63693766666667
                        }
                    ])
                }
            };
            var actual = Map.hasSizeField(dataViewOneColumn.categorical.values, 0);
            expect(actual).toBe(false);
            actual = Map.hasSizeField(dataViewTwoColumnsWithRoles.categorical.values, 0);
            expect(actual).toBe(true);
            actual = Map.hasSizeField(dataViewTwoColumnsWithoutRoles.categorical.values, 0);
            expect(actual).toBe(true);
            actual = Map.hasSizeField(dataViewThreeColumns.categorical.values, 0);
            expect(actual).toBe(false);
        });
        it('Map.tooltipInfo single series', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }])
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesInfo = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: "col1", value: "Montana" }, { displayName: "col2", value: "-100" }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map.tooltipInfo multi series', function () {
            var dataView = powerbi.data.DataViewTransform.apply({
                prototype: getDataViewMultiSeries(),
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
                dataViewMappings: powerbi.visuals.mapCapabilities.dataViewMappings,
                objectDescriptors: powerbi.visuals.mapCapabilities.objects,
                transforms: {
                    selects: [
                        { queryName: 'select0' },
                        { queryName: 'select1' },
                        { queryName: 'select2' },
                        { queryName: 'select3' }
                    ]
                }
            })[0];
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesInfo = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), groupIndex, sizeIndex, longIndex, latIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: '', value: '2012' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '150.00' }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map.createMapDataLabel bubble', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockBubbleData = [{
                    x: 50,
                    y: 50,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Test Label",
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapBubbles", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            //Should render
            expect(result).toBeDefined();
            expect(result[0][0]).toBeDefined();
            //Data input length
            expect(result.data.length).toBe(2);
            //Color setting properly
            expect(result[0][0].__data__.fill).toBe(mockDatalabelSettings.labelColor);
            //text
            expect(result[0][0].__data__.labeltext).toBe(powerbi.visuals.dataLabelUtils.getLabelFormattedText('Test Label'));
        });
        it('Map.createMapDataLabel slice', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockSliceData = [{
                    x: 50,
                    y: 50,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: 'Test Label',
                    value: 0,
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapBubbles", true);
            var viewPort = {
                height: element.height(),
                width: element.width()
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockBubbleGraphicsContext, mockLayout, viewPort);
            //Should render
            expect(result).toBeDefined();
            expect(result[0][0]).toBeDefined();
            //Data input length
            expect(result.data.length).toBe(2);
            //Color setting properly
            expect(result[0][0].__data__.fill).toBe(mockDatalabelSettings.labelColor);
            //text
            expect(result[0][0].__data__.labeltext).toBe(powerbi.visuals.dataLabelUtils.getLabelFormattedText('Test Label'));
        });
        it('Map.createMapDataLabel hide bubble', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockBubbleData = [{
                    x: 50,
                    y: 50,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Test Label",
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapBubbles1", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            // Simulate the clean function of dataLabelUtils when 'show' is set to false
            DataLabelUtils.cleanDataLabels(mockBubbleGraphicsContext);
            expect(result).toBeDefined();
            expect($('.mapBubbles1 text').length).toBe(0);
        });
        it('Map.createMapDataLabel hide slice', function () {
            var mockDatalabelSettings = {
                show: true,
                displayUnits: null,
                position: 0 /* Above */,
                precision: 2,
                labelColor: "#000000",
                overrideDefaultColor: false,
                formatterOptions: null,
            };
            var mockSliceData = [{
                    x: 50,
                    y: 50,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Test Label",
                    value: 0,
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapSlice1", true);
            var mockViewPort = {
                height: 150,
                width: 300
            };
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            // Simulate the clean function of dataLabelUtils when 'show' is set to false
            DataLabelUtils.cleanDataLabels(mockBubbleGraphicsContext);
            expect(result).toBeDefined();
            expect($('.mapSlice1 text').length).toBe(0);
        });
        it('Map.tooltipInfo no series, no values', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                }
            };
            var groupIndex = 0;
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var categoryValue = dataView.categorical.categories[0].values[0];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var seriesInfo = Map.calculateSeriesInfo(undefined, groupIndex, sizeIndex, latIndex, longIndex, colors);
            var value = seriesInfo.sizeValuesForGroup[0].value;
            var tooltipInfo = powerbi.visuals.TooltipBuilder.createTooltipInfo(powerbi.visuals.mapProps.general.formatString, dataView.categorical.categories, categoryValue, dataView.categorical.values, value, null, 0);
            var tooltipInfoTestData = [{ displayName: "col1", value: "Montana" }];
            expect(tooltipInfo).toEqual(tooltipInfoTestData);
        });
        it('Map shows warning with no Location set', function () {
            var dataView = {
                metadata: {
                    columns: [{ displayName: 'NotLocation', roles: { 'NotCategory': true, }, }],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings[0]).not.toBeNull();
        });
        it('Map shows warning with no columns set', function () {
            var dataView = {
                metadata: {
                    columns: [],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings[0]).not.toBeNull();
        });
        it('Map does not show warning with location set', function () {
            var dataView = {
                metadata: {
                    columns: [{ displayName: 'Location', queryName: 'Location', roles: { 'Category': true, }, }],
                }
            };
            var warnings = Map.showLocationMissingWarningIfNecessary(dataView);
            expect(warnings.length).toEqual(0);
        });
        it('Map legend is hidden:show false', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: false
                        }
                    }
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(true);
        });
        it('Map legend is hidden:show true', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: true
                        }
                    }
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is hidden:no legend object', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {}
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is hidden:no objects', function () {
            var dataView = {
                metadata: {
                    columns: [],
                }
            };
            expect(Map.isLegendHidden(dataView)).toBe(false);
        });
        it('Map legend is bottom', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            position: 'Bottom'
                        }
                    }
                }
            };
            expect(Map.legendPosition(dataView)).toBe(LegendPosition.Bottom);
        });
        it('Map enumerateLegend', function () {
            var dataView = {
                metadata: {
                    columns: [],
                    objects: {
                        legend: {
                            show: true
                        }
                    }
                }
            };
            var legend = {
                changeOrientation: function () { },
                drawLegend: function () { },
                getMargins: function () { return {
                    width: 0,
                    height: 0
                }; },
                getOrientation: function () { return LegendPosition.Top; },
                isVisible: function () { return true; },
                reset: function () { },
            };
            var objects = Map.enumerateLegend(dataView, legend, "");
            expect(objects.length).toBe(1);
            var firstObject = objects[0];
            expect(firstObject.objectName).toBe('legend');
            expect(firstObject.selector).toBeNull();
            expect(firstObject.properties).toBeDefined();
            var properties = firstObject.properties;
            expect(properties['show']).toBe(true);
            expect(properties['position']).toBe('Top');
        });
        it('Map.calculateSeriesInfo - Gradient color', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [75, 50, 0],
                        }])
                }
            };
            var sizeIndex = 0;
            var latIndex = -1;
            var longIndex = -1;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: "#d9f2fb" } } } },
                { dataPoint: { fill: { solid: { color: "#b1eab7" } } } }
            ];
            var result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), 0, sizeIndex, longIndex, latIndex, colors, null, objectDefinitions);
            expect(result.sizeValuesForGroup[0].fill).toBe('rgba(217,242,251,0.6)');
            result = Map.calculateSeriesInfo(dataView.categorical.values.grouped(), 1, sizeIndex, longIndex, latIndex, colors, null, objectDefinitions);
            expect(result.sizeValuesForGroup[0].fill).toBe('rgba(177,234,183,0.6)');
        });
        it('Map.shouldEnumerateDataPoints filledMap', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(false);
        });
        it('Map.shouldEnumerateDataPoints filledMap series overrides size', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', queryName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(true);
        });
        it('Map.shouldEnumerateDataPoints filledMap', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, true)).toBe(true);
        });
        it('Map.shouldEnumerateDataPoints Map', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Gradient": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, false)).toBe(false);
        });
        it('Map.shouldEnumerateDataPoints Map', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(Map.shouldEnumerateDataPoints(dataView, false)).toBe(true);
        });
        it("Map: enumerate data points with dynamic series", function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', queryName: 'col1' },
                    { displayName: 'col2', queryName: 'col2', type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, groupName: 'a', type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: 'col3', queryName: 'col3', isMeasure: true, groupName: 'b' },
                ]
            };
            var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
            var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } } };
            var measureColumnDynamic1 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } }, groupName: 'A' };
            var measureColumnDynamic2 = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } }, groupName: 'B' };
            var measureColumnDynamic1RefExpr = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'sales' });
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("2011"),
                powerbitests.mocks.dataViewScopeIdentity("2012"),
            ];
            var col3Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'col2' });
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, "A"),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(col3Ref, "B"),
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: categoryColumn,
                            values: [2011, 2012],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: measureColumnDynamic1,
                            values: [100, 200],
                            identity: seriesIdentities[0],
                        }, {
                            source: measureColumnDynamic2,
                            values: [62, 55],
                            identity: seriesIdentities[1],
                        }], [measureColumnDynamic1RefExpr])
                }
            };
            dataView.categorical.values.source = measureColumn;
            var groupIndex = 0;
            var sizeIndex = 0;
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var legendDataPoints = Map.calculateSeriesLegend(dataView.categorical.values.grouped(), groupIndex, sizeIndex, colors, undefined, [col3Ref]);
            var enumeratedDataPoints = Map.enumerateDataPoints(legendDataPoints, colors, true, null, false, []);
            expect(enumeratedDataPoints.length).toBe(legendDataPoints.length);
            // ensure first object is 'fill' and not 'defaultColor'
            expect(enumeratedDataPoints[0]['properties']['fill']).toBeDefined();
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var CompiledSubtotalType = powerbi.data.CompiledSubtotalType;
    var DataViewAnalysis = powerbi.DataViewAnalysis;
    var Matrix = powerbi.visuals.Matrix;
    var QueryProjectionCollection = powerbi.data.QueryProjectionCollection;
    var valueFormatter = powerbi.visuals.valueFormatter;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    powerbitests.mocks.setLocale();
    var dataTypeNumber = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
    var dataTypeString = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text);
    var dataTypeBoolean = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Boolean);
    var dataTypeWebUrl = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text, "WebUrl");
    var rowGroupSource1 = { displayName: "RowGroup1", queryName: "RowGroup1", type: dataTypeString, index: 0 };
    var rowGroupSource2 = { displayName: "RowGroup2", queryName: "RowGroup2", type: dataTypeString, index: 1 };
    var rowGroupSource3 = { displayName: "RowGroup3", queryName: "RowGroup3", type: dataTypeString, index: 2 };
    var rowGroupSource3formatted = { displayName: "RowGroup3", queryName: "RowGroup3", type: dataTypeString, index: 2, objects: { general: { formatString: "0.0" } } };
    var rowGroupSource4 = { displayName: "RowGroup4", queryName: "RowGroup4", type: dataTypeBoolean, index: 9 };
    var rowGroupSourceWebUrl = { displayName: "RowGroupWebUrl", queryName: "RowGroupWebUrl", type: dataTypeWebUrl, index: 0 };
    var columnGroupSource1 = { displayName: "ColGroup1", queryName: "ColGroup1", type: dataTypeString, index: 3 };
    var columnGroupSource2 = { displayName: "ColGroup2", queryName: "ColGroup2", type: dataTypeString, index: 4 };
    var columnGroupSource3 = { displayName: "ColGroup3", queryName: "ColGroup3", type: dataTypeString, index: 5 };
    var columnGroupSource3formatted = { displayName: "ColGroup3", queryName: "ColGroup3", type: dataTypeString, index: 5, objects: { general: { formatString: "0.00" } } };
    var columnGroupSource4 = { displayName: "ColGroup4", queryName: "ColGroup4", type: dataTypeBoolean, index: 10 };
    var columnGroupSourceWebUrl = { displayName: "ColGroupWebUrl", queryName: "ColGroupWebUrl", type: dataTypeWebUrl, index: 0 };
    var measureSource1 = { displayName: "Measure1", queryName: "Measure1", type: dataTypeNumber, isMeasure: true, index: 6 };
    var measureSource2 = { displayName: "Measure2", queryName: "Measure2", type: dataTypeNumber, isMeasure: true, index: 7 };
    var measureSource3 = { displayName: "Measure3", queryName: "Measure3", type: dataTypeNumber, isMeasure: true, index: 8 };
    // ------------
    // | Measure1 |
    // +----------|
    // |      100 |
    // ------------
    var matrixOneMeasure = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        values: {
                            0: { value: 100 }
                        }
                    }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{
                    sources: [measureSource1]
                }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureDataView = {
        metadata: { columns: [measureSource1] },
        matrix: matrixOneMeasure
    };
    // -----------
    // | Group A |
    // +---------|
    // |     100 |
    // -----------
    var matrixOneMeasureOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        values: {
                            0: { value: 100 }
                        }
                    }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Group A"
                    }
                ]
            },
            levels: [{
                    sources: [columnGroupSource1]
                }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSource1, measureSource1] },
        matrix: matrixOneMeasureOneColumnGroupOneGroupInstance
    };
    // ---------------------------
    // | http://www.validurl.com |
    // +-------------------------|
    // |     100                 |
    // ---------------------------
    var matrixOneMeasureOneColumnGroupWithUrlOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        values: {
                            0: { value: 100 }
                        }
                    }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "http://www.validurl.com"
                    }
                ]
            },
            levels: [{
                    sources: [columnGroupSourceWebUrl]
                }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneColumnGroupWithUrlOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSourceWebUrl, measureSource1] },
        matrix: matrixOneMeasureOneColumnGroupWithUrlOneGroupInstance
    };
    // ----------------------------------
    // | Measure1 | Measure2 | Measure3 |
    // +--------------------------------|
    // |      100 |      200 |      300 |
    // ----------------------------------
    var matrixThreeMeasures = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        values: {
                            0: { value: 100 },
                            1: { value: 200, valueSourceIndex: 1 },
                            2: { value: 300, valueSourceIndex: 2 }
                        }
                    }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    { level: 0 },
                    { level: 0, levelSourceIndex: 1 },
                    { level: 0, levelSourceIndex: 2 }
                ]
            },
            levels: [{
                    sources: [
                        measureSource1,
                        measureSource2,
                        measureSource3
                    ]
                }]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresDataView = {
        metadata: { columns: [measureSource1, measureSource2, measureSource3] },
        matrix: matrixThreeMeasures
    };
    // ----------------------------------
    // |                        Group A |
    // |--------------------------------|
    // | Measure1 | Measure2 | Measure3 |
    // +--------------------------------|
    // |      100 |      200 |      300 |
    // ----------------------------------
    var matrixThreeMeasuresOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        values: {
                            0: { value: 100 },
                            1: { value: 200, valueSourceIndex: 1 },
                            2: { value: 300, valueSourceIndex: 2 }
                        }
                    }]
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Group A",
                        children: [
                            { level: 1 },
                            { level: 1, levelSourceIndex: 1 },
                            { level: 1, levelSourceIndex: 2 }
                        ]
                    }
                ]
            },
            levels: [
                {
                    sources: [
                        columnGroupSource1
                    ]
                },
                {
                    sources: [
                        measureSource1,
                        measureSource2,
                        measureSource3
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
        matrix: matrixThreeMeasuresOneColumnGroupOneGroupInstance
    };
    // ----------------------------------------------------------------------------
    // |     RowGroup1 | RowGroup2 |   RowGroup3 | Measure1 | Measure2 | Measure3 |
    // |-----------------------------------------+--------------------------------|
    // | North America |    Canada |     Ontario |     1000 |     1001 |     1002 |
    // |               |           |----------------------------------------------|
    // |               |           |      Quebec |     1010 |     1011 |     1012 |
    // |               |----------------------------------------------------------|
    // |               |       USA |  Washington |     1100 |     1101 |     1102 |
    // |               |           |----------------------------------------------|
    // |               |           |      Oregon |     1110 |     1111 |     1112 |
    // |--------------------------------------------------------------------------|
    // | South America |    Brazil |    Amazonas |     2000 |     2001 |     2002 | 
    // |               |           |----------------------------------------------|
    // |               |           | Mato Grosso |     2010 |     2011 |     2012 |
    // |               |----------------------------------------------------------|
    // |               |     Chile |       Arica |     2100 |     2101 |     2102 |
    // |               |           |----------------------------------------------|
    // |               |           |  Parinacota |     2110 |     2111 |     2112 |
    // ----------------------------------------------------------------------------
    var matrixThreeMeasuresThreeRowGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "North America",
                        children: [
                            {
                                level: 1,
                                value: "Canada",
                                children: [
                                    {
                                        level: 2,
                                        value: "Ontario",
                                        values: {
                                            0: { value: 1000 },
                                            1: { value: 1001, valueSourceIndex: 1 },
                                            2: { value: 1002, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: "Quebec",
                                        values: {
                                            0: { value: 1010 },
                                            1: { value: 1011, valueSourceIndex: 1 },
                                            2: { value: 1012, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "USA",
                                children: [
                                    {
                                        level: 2,
                                        value: "Washington",
                                        values: {
                                            0: { value: 1100 },
                                            1: { value: 1101, valueSourceIndex: 1 },
                                            2: { value: 1102, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: "Oregon",
                                        values: {
                                            0: { value: 1110 },
                                            1: { value: 1111, valueSourceIndex: 1 },
                                            2: { value: 1112, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "South America",
                        children: [
                            {
                                level: 1,
                                value: "Brazil",
                                children: [
                                    {
                                        level: 2,
                                        value: "Amazonas",
                                        values: {
                                            0: { value: 2000 },
                                            1: { value: 2001, valueSourceIndex: 1 },
                                            2: { value: 2002, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: "Mato Grosso",
                                        values: {
                                            0: { value: 2010 },
                                            1: { value: 2011, valueSourceIndex: 1 },
                                            2: { value: 2012, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Chile",
                                children: [
                                    {
                                        level: 2,
                                        value: "Arica",
                                        values: {
                                            0: { value: 2100 },
                                            1: { value: 2101, valueSourceIndex: 1 },
                                            2: { value: 2102, valueSourceIndex: 2 }
                                        }
                                    },
                                    {
                                        level: 2,
                                        value: "Parinacota",
                                        values: {
                                            0: { value: 2110 },
                                            1: { value: 2111, valueSourceIndex: 1 },
                                            2: { value: 2112, valueSourceIndex: 2 }
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: [
                    { level: 0 },
                    { level: 0, levelSourceIndex: 1 },
                    { level: 0, levelSourceIndex: 2 }
                ]
            },
            levels: [{
                    sources: [
                        measureSource1,
                        measureSource2,
                        measureSource3
                    ]
                }]
        },
        valueSources: [
            measureSource1,
            measureSource2,
            measureSource3
        ]
    };
    var matrixThreeMeasuresThreeRowGroupsDataView = {
        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
        matrix: matrixThreeMeasuresThreeRowGroups
    };
    // ------------------------
    // | RowGroup1 | Measure1 |
    // |-----------+----------|
    // |   Group 1 |      100 |
    // ------------------------
    var matrixOneMeasureOneRowGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        value: "Group 1",
                        values: { 0: { value: 100 } }
                    }]
            },
            levels: [{ sources: [rowGroupSource1] }]
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{ sources: [measureSource1] }]
        },
        valueSources: [measureSource1]
    };
    // ----------------------------------------
    // | RowGroup1                 | Measure1 |
    // |---------------------------+----------|
    // |   http://www.validurl.com |      100 |
    // ----------------------------------------
    var matrixOneMeasureOneRowGroupUrlOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        value: "http://www.validurl.com",
                        values: { 0: { value: 100 } }
                    }]
            },
            levels: [{ sources: [rowGroupSourceWebUrl] }]
        },
        columns: {
            root: {
                children: [{ level: 0 }]
            },
            levels: [{ sources: [measureSource1] }]
        },
        valueSources: [measureSource1]
    };
    var matrixOneMeasureOneRowGroupUrlOneGroupInstanceDataView = {
        metadata: { columns: [], segment: {} },
        matrix: matrixOneMeasureOneRowGroupUrlOneGroupInstance
    };
    // ----------------------
    // | RowGroup1 |  Group |
    // |-----------+--------|
    // |     Group |        |
    // ----------------------
    var matrixOneRowGroupOneColumnGroupOneGroupInstance = {
        rows: {
            root: {
                children: [{
                        level: 0,
                        value: 10
                    }]
            },
            levels: [{ sources: [rowGroupSource1] }]
        },
        columns: {
            root: {
                children: [{
                        level: 0,
                        value: 10
                    }]
            },
            levels: [{ sources: [columnGroupSource1] }]
        },
        valueSources: []
    };
    var matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView = {
        metadata: { columns: [rowGroupSource1, columnGroupSource1] },
        matrix: matrixOneRowGroupOneColumnGroupOneGroupInstance
    };
    // -------------------------------------
    // | RowGroup1 | RowGroup2 | RowGroup3 |
    // |-----------------------------------+
    // |    Africa |   Algeria |      2008 |
    // -------------------------------------
    var matrixThreeRowGroupsOneGroupInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Africa",
                        children: [
                            {
                                level: 1,
                                value: "Algeria",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008,
                                        identity: powerbitests.mocks.dataViewScopeIdentity("rowGroup3")
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    var matrixThreeRowGroupsOneGroupInstanceDataView = {
        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3] },
        matrix: matrixThreeRowGroupsOneGroupInstance
    };
    // -------------------------
    // | RowGroup1 | RowGroup2 |
    // |-----------------------+
    // |    Africa |           |
    // |           |-----------|
    // |           |    Angola |
    // |-----------|-----------|
    // |      Asia |     China |
    // |           |-----------|
    // |           |           |
    // |-----------|-----------|
    // |           |           |
    // -------------------------
    var matrixTwoRowGroupsWithNullValues = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Africa",
                        children: [
                            {
                                level: 1
                            },
                            {
                                level: 1,
                                value: "Angola"
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "China"
                            },
                            {
                                level: 1
                            }
                        ]
                    },
                    {
                        level: 0,
                        children: [
                            {
                                level: 1
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    // -------------------------------------
    // | RowGroup1 | RowGroup2 | RowGroup3 |
    // |-----------------------------------+
    // |    Africa |   Algeria |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |           |-----------------------|
    // |           |    Angola |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |-----------|-----------|-----------|
    // |      Asia |     China |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // |           |-----------|-----------|
    // |           |     India |      2008 |
    // |           |           |-----------|
    // |           |           |      2012 |
    // -------------------------------------
    var matrixThreeRowGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Africa",
                        children: [
                            {
                                level: 1,
                                value: "Algeria",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Angola",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "China",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "India",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: []
            },
            levels: []
        },
        valueSources: []
    };
    // ---------------------------------------------------------
    // |                    Africa |                      Asia | 
    // |---------------------------|---------------------------|
    // |     Algeria |      Angola |       China |       India |
    // |-------------|-------------|-------------|-------------|
    // | 2008 | 2012 | 2008 | 2012 | 2008 | 2012 | 2008 | 2012 |
    // +--------------------------------------------------------
    var matrixThreeColumnGroups = {
        rows: {
            root: {
                children: []
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Africa",
                        children: [
                            {
                                level: 1,
                                value: "Algeria",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Angola",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "China",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "India",
                                children: [
                                    {
                                        level: 2,
                                        value: 2008
                                    },
                                    {
                                        level: 2,
                                        value: 2012
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        valueSources: []
    };
    var matrixThreeColumnGroupsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                rowGroupSource3
            ]
        },
        matrix: matrixThreeColumnGroups
    };
    // --------------------------------------------
    // |         Africa |           Asia |        |
    // |----------------|----------------|--------|
    // |       | Angola | China |        |        |
    // +-------------------------------------------
    var matrixTwoColumnGroupsWithNullValues = {
        rows: {
            root: {
                children: []
            },
            levels: []
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Africa",
                        children: [
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            },
                            {
                                level: 1,
                                value: "Angola",
                                identity: jasmine.any(Object)
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "China",
                                identity: jasmine.any(Object)
                            },
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            }
                        ]
                    },
                    {
                        level: 0,
                        children: [
                            {
                                level: 1,
                                identity: jasmine.any(Object)
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] }
            ]
        },
        valueSources: []
    };
    // -----------------------------
    // | RowGroup1 | United States |
    // |-----------+---------------|
    // |      2002 |               |
    // -----------------------------
    var matrixOneRowGroupOneColumnGroupOneInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 2002
                    }
                ]
            },
            levels: [
                {
                    sources: [rowGroupSource1]
                }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "United States"
                    }
                ]
            },
            levels: [
                {
                    sources: [columnGroupSource1]
                }
            ]
        },
        valueSources: []
    };
    // -----------------------------------------
    // |           |           | ColGroup1 | B |
    // |-----------|-----------|-----------|---|
    // |           |           | ColGroup2 | b |
    // |-----------|-----------|-----------|---|
    // | RowGroup1 | RowGroup2 | RowGroup3 | 2 |
    // |-----------------------------------+---|
    // |         A |         a |         1 |   |
    // -----------------------------------------
    var matrixThreeRowGroupsThreeColumnGroupsOneInstance = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "A",
                        children: [
                            {
                                level: 1,
                                value: "a",
                                children: [
                                    {
                                        level: 2,
                                        value: 1
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "B",
                        children: [
                            {
                                level: 1,
                                value: "b",
                                children: [
                                    {
                                        level: 2,
                                        value: 2
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                { sources: [columnGroupSource3] }
            ]
        },
        valueSources: []
    };
    // -------------------------------------------------
    // |           |           | ColGroup1 |         C |
    // |-----------|-----------|-----------|-----------|
    // |           |           | ColGroup2 |     c | d |
    // |-----------|-----------|-----------|-----------|
    // | RowGroup1 | RowGroup2 | RowGroup3 | 4 | 5 | 6 |
    // |-----------------------------------+-----------|
    // |         A |         a |         1 |   |   |   |
    // |           |           |-----------|---|---|---|
    // |           |           |         2 |   |   |   |
    // |           |-----------|-----------|---|---|---|
    // |           |         b |         3 |   |   |   |
    // -------------------------------------------------
    var matrixThreeRowGroupsThreeColumnGroups = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "A",
                        children: [
                            {
                                level: 1,
                                value: "a",
                                children: [
                                    {
                                        level: 2,
                                        value: 1
                                    },
                                    {
                                        level: 2,
                                        value: 2
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "b",
                                children: [
                                    {
                                        level: 2,
                                        value: 3
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] },
                { sources: [rowGroupSource3formatted] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "C",
                        children: [
                            {
                                level: 1,
                                value: "c",
                                children: [
                                    {
                                        level: 2,
                                        value: 4
                                    },
                                    {
                                        level: 2,
                                        value: 5
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "d",
                                children: [
                                    {
                                        level: 2,
                                        value: 6
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                { sources: [columnGroupSource3formatted] }
            ]
        },
        valueSources: []
    };
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                                                            1992 |                                                            1996 |
    // |---------------|---------------|-----------------------------------------------------------------|-----------------------------------------------------------------|
    // |               |     ColGroup2 |              Bronze |                Gold |              Silver |              Bronze |                Gold |              Silver |
    // |---------------|---------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|
    // |     RowGroup1 |     RowGroup2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 |
    // |-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------|
    // |          Asia |   South Korea |        0 |        1 |        2 |        3 |        4 |        5 |        6 |        7 |        8 |        9 |       10 |       11 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       12 |       13 |       14 |       15 |       16 |       17 |       18 |       19 |       20 |       21 |       22 |          |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       24 |       25 |       26 |       27 |       28 |       29 |       30 |       31 |       32 |       33 |       34 |       35 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       36 |       37 |       38 |       39 |       40 |       41 |       42 |       43 |       44 |       45 |       46 |       47 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       48 |       49 |       50 |       51 |       52 |       53 |       54 |       55 |       56 |       57 |       58 |       59 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       60 |       61 |       62 |       63 |       64 |       65 |       66 |       67 |       68 |       69 |       70 |       71 |
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasures = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "South Korea",
                                values: {
                                    0: { value: 0 }, 1: { value: 1, valueSourceIndex: 1 },
                                    2: { value: 2 }, 3: { value: 3, valueSourceIndex: 1 },
                                    4: { value: 4 }, 5: { value: 5, valueSourceIndex: 1 },
                                    6: { value: 6 }, 7: { value: 7, valueSourceIndex: 1 },
                                    8: { value: 8 }, 9: { value: 9, valueSourceIndex: 1 },
                                    10: { value: 10 }, 11: { value: 11, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: "Unified Team",
                                values: {
                                    0: { value: 12 }, 1: { value: 13, valueSourceIndex: 1 },
                                    2: { value: 14 }, 3: { value: 15, valueSourceIndex: 1 },
                                    4: { value: 16 }, 5: { value: 17, valueSourceIndex: 1 },
                                    6: { value: 18 }, 7: { value: 19, valueSourceIndex: 1 },
                                    8: { value: 20 }, 9: { value: 21, valueSourceIndex: 1 },
                                    10: { value: 22 }, 11: { value: null, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Europe",
                        children: [
                            {
                                level: 1,
                                value: "France",
                                values: {
                                    0: { value: 24 }, 1: { value: 25, valueSourceIndex: 1 },
                                    2: { value: 26 }, 3: { value: 27, valueSourceIndex: 1 },
                                    4: { value: 28 }, 5: { value: 29, valueSourceIndex: 1 },
                                    6: { value: 30 }, 7: { value: 31, valueSourceIndex: 1 },
                                    8: { value: 32 }, 9: { value: 33, valueSourceIndex: 1 },
                                    10: { value: 34 }, 11: { value: 35, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: "Germany",
                                values: {
                                    0: { value: 36 }, 1: { value: 37, valueSourceIndex: 1 },
                                    2: { value: 38 }, 3: { value: 39, valueSourceIndex: 1 },
                                    4: { value: 40 }, 5: { value: 41, valueSourceIndex: 1 },
                                    6: { value: 42 }, 7: { value: 43, valueSourceIndex: 1 },
                                    8: { value: 44 }, 9: { value: 45, valueSourceIndex: 1 },
                                    10: { value: 46 }, 11: { value: 47, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "North America",
                        children: [
                            {
                                level: 1,
                                value: "United States",
                                values: {
                                    0: { value: 48 }, 1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 }, 3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 52 }, 5: { value: 53, valueSourceIndex: 1 },
                                    6: { value: 54 }, 7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 }, 9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 58 }, 11: { value: 59, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Oceania",
                        children: [
                            {
                                level: 1,
                                value: "Australia",
                                values: {
                                    0: { value: 60 }, 1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 }, 3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 64 }, 5: { value: 65, valueSourceIndex: 1 },
                                    6: { value: 66 }, 7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 }, 9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 70 }, 11: { value: 71, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                name: "Bronze",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Gold",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Silver",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: "Bronze",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Gold",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Silver",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                {
                    sources: [
                        measureSource1,
                        measureSource2
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2
        ]
    };
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1,
                measureSource2
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsTwoMeasures
    };
    // --------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                           1992 |                           1996 |    Total |
    // |---------------|---------------|--------------------------------|--------------------------------|          |
    // |     RowGroup1 |     RowGroup2 |   Silver |     Gold |    Total |   Silver |     Gold |    Total |          |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |          Asia |   South Korea |        1 |        2 |        3 |        4 |        5 |        9 |       12 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       11 |       12 |       23 |       14 |       15 |       29 |       52 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       12 |       14 |       26 |       18 |       20 |       38 |       64 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       21 |       22 |       43 |       24 |       25 |       49 |       92 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       31 |       32 |       63 |       34 |       35 |       69 |      132 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       52 |       54 |      106 |       58 |       60 |      118 |      224 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       41 |       42 |       83 |       44 |       45 |       89 |      172 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       41 |       42 |       83 |       44 |       45 |       89 |      172 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       51 |       52 |      103 |       54 |       55 |      109 |      212 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       51 |       52 |      103 |       54 |       55 |      109 |      212 |
    // |-------------------------------|----------|----------|----------|----------|----------|----------|----------|
    // |         Total                 |      156 |      162 |      318 |      174 |      180 |      354 |      672 |
    // --------------------------------------------------------------------------------------------------------------
    var matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "South Korea",
                                values: {
                                    0: { value: 1 }, 1: { value: 2 }, 2: { value: 3 }, 3: { value: 4 }, 4: { value: 5 }, 5: { value: 9 }, 6: { value: 12 }
                                }
                            },
                            {
                                level: 1,
                                value: "Unified Team",
                                values: {
                                    0: { value: 11 }, 1: { value: 12 }, 2: { value: 23 }, 3: { value: 14 }, 4: { value: 15 }, 5: { value: 29 }, 6: { value: 52 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 12 }, 1: { value: 14 }, 2: { value: 26 }, 3: { value: 18 }, 4: { value: 20 }, 5: { value: 38 }, 6: { value: 64 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Europe",
                        children: [
                            {
                                level: 1,
                                value: "France",
                                values: {
                                    0: { value: 21 }, 1: { value: 22 }, 2: { value: 43 }, 3: { value: 24 }, 4: { value: 25 }, 5: { value: 49 }, 6: { value: 92 }
                                }
                            },
                            {
                                level: 1,
                                value: "Germany",
                                values: {
                                    0: { value: 31 }, 1: { value: 32 }, 2: { value: 63 }, 3: { value: 34 }, 4: { value: 35 }, 5: { value: 69 }, 6: { value: 132 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 52 }, 1: { value: 54 }, 2: { value: 106 }, 3: { value: 58 }, 4: { value: 60 }, 5: { value: 118 }, 6: { value: 224 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "North America",
                        children: [
                            {
                                level: 1,
                                value: "United States",
                                values: {
                                    0: { value: 41 }, 1: { value: 42 }, 2: { value: 83 }, 3: { value: 44 }, 4: { value: 45 }, 5: { value: 89 }, 6: { value: 172 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 41 }, 1: { value: 42 }, 2: { value: 83 }, 3: { value: 44 }, 4: { value: 45 }, 5: { value: 89 }, 6: { value: 172 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Oceania",
                        children: [
                            {
                                level: 1,
                                value: "Australia",
                                values: {
                                    0: { value: 51 }, 1: { value: 52 }, 2: { value: 103 }, 3: { value: 54 }, 4: { value: 55 }, 5: { value: 109 }, 6: { value: 212 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 51 }, 1: { value: 52 }, 2: { value: 103 }, 3: { value: 54 }, 4: { value: 55 }, 5: { value: 109 }, 6: { value: 212 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 156 }, 1: { value: 162 }, 2: { value: 318 }, 3: { value: 174 }, 4: { value: 180 }, 5: { value: 354 }, 6: { value: 672 }
                        }
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                value: "Silver"
                            },
                            {
                                level: 1,
                                value: "Gold"
                            },
                            {
                                level: 1,
                                isSubtotal: true
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: "Silver"
                            },
                            {
                                level: 1,
                                value: "Gold"
                            },
                            {
                                level: 1,
                                isSubtotal: true
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] }
            ]
        },
        valueSources: [measureSource1]
    };
    var matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotalsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals
    };
    // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // |               |     ColGroup1 |                                                            1992 |                                                            1996 |               Total |
    // |---------------|---------------|-----------------------------------------------------------------|-----------------------------------------------------------------|                     |
    // |               |     ColGroup2 |              Silver |                Gold |               Total |              Silver |                Gold |               Total |                     |
    // |---------------|---------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|
    // |     RowGroup1 |     RowGroup2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 | Measure1 | Measure2 |
    // |-------------------------------+-----------------------------------------------------------------------------------------------------------------------------------|----------|----------|
    // |          Asia |   South Korea |        0 |        1 |        2 |        3 |        2 |        4 |        6 |        7 |        8 |        9 |       14 |       16 |       16 |       20 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |  Unified Team |       12 |       13 |       14 |       15 |       26 |       28 |       18 |       19 |       20 |       21 |       38 |       40 |       64 |       68 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       12 |       14 |       16 |       18 |       28 |       32 |       24 |       26 |       28 |       30 |       52 |       56 |       80 |       88 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |        Europe |        France |       24 |       25 |       26 |       27 |       50 |       52 |       30 |       31 |       32 |       33 |       62 |       64 |      112 |      116 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |       Germany |       36 |       37 |       38 |       39 |       74 |       76 |       42 |       43 |       44 |       45 |       86 |       88 |      160 |      164 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       60 |       62 |       64 |       66 |      124 |      128 |       72 |       74 |       76 |       78 |      148 |      152 |      272 |      280 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // | North America | United States |       48 |       49 |       50 |       51 |       98 |      100 |       54 |       55 |       56 |       57 |      110 |      112 |      208 |      212 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       48 |       49 |       50 |       51 |       98 |      100 |       54 |       55 |       56 |       57 |      110 |      112 |      208 |      212 |
    // |---------------|---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |       Oceania |     Australia |       60 |       61 |       62 |       63 |      122 |      124 |       66 |       67 |       68 |       69 |      134 |      136 |      256 |      260 |
    // |               |---------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |               |         Total |       60 |       61 |       62 |       63 |      122 |      124 |       66 |       67 |       68 |       69 |      134 |      136 |      256 |      260 |
    // |-------------------------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|----------|
    // |         Total                 |      180 |      186 |      192 |      198 |      372 |      384 |      216 |      222 |      228 |      234 |      444 |      456 |      816 |      840 |
    // ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: "Asia",
                        children: [
                            {
                                level: 1,
                                value: "South Korea",
                                values: {
                                    0: { value: 0 }, 1: { value: 1, valueSourceIndex: 1 },
                                    2: { value: 2 }, 3: { value: 3, valueSourceIndex: 1 },
                                    4: { value: 2 }, 5: { value: 4, valueSourceIndex: 1 },
                                    6: { value: 6 }, 7: { value: 7, valueSourceIndex: 1 },
                                    8: { value: 8 }, 9: { value: 9, valueSourceIndex: 1 },
                                    10: { value: 14 }, 11: { value: 16, valueSourceIndex: 1 },
                                    12: { value: 16 }, 13: { value: 20, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: "Unified Team",
                                values: {
                                    0: { value: 12 }, 1: { value: 13, valueSourceIndex: 1 },
                                    2: { value: 14 }, 3: { value: 15, valueSourceIndex: 1 },
                                    4: { value: 26 }, 5: { value: 28, valueSourceIndex: 1 },
                                    6: { value: 18 }, 7: { value: 19, valueSourceIndex: 1 },
                                    8: { value: 20 }, 9: { value: 21, valueSourceIndex: 1 },
                                    10: { value: 38 }, 11: { value: 40, valueSourceIndex: 1 },
                                    12: { value: 64 }, 13: { value: 68, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 12 }, 1: { value: 14, valueSourceIndex: 1 },
                                    2: { value: 16 }, 3: { value: 18, valueSourceIndex: 1 },
                                    4: { value: 28 }, 5: { value: 32, valueSourceIndex: 1 },
                                    6: { value: 24 }, 7: { value: 26, valueSourceIndex: 1 },
                                    8: { value: 28 }, 9: { value: 30, valueSourceIndex: 1 },
                                    10: { value: 52 }, 11: { value: 56, valueSourceIndex: 1 },
                                    12: { value: 80 }, 13: { value: 88, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Europe",
                        children: [
                            {
                                level: 1,
                                value: "France",
                                values: {
                                    0: { value: 24 }, 1: { value: 25, valueSourceIndex: 1 },
                                    2: { value: 26 }, 3: { value: 27, valueSourceIndex: 1 },
                                    4: { value: 50 }, 5: { value: 52, valueSourceIndex: 1 },
                                    6: { value: 30 }, 7: { value: 31, valueSourceIndex: 1 },
                                    8: { value: 32 }, 9: { value: 33, valueSourceIndex: 1 },
                                    10: { value: 62 }, 11: { value: 64, valueSourceIndex: 1 },
                                    12: { value: 112 }, 13: { value: 116, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                value: "Germany",
                                values: {
                                    0: { value: 36 }, 1: { value: 37, valueSourceIndex: 1 },
                                    2: { value: 38 }, 3: { value: 39, valueSourceIndex: 1 },
                                    4: { value: 74 }, 5: { value: 74, valueSourceIndex: 1 },
                                    6: { value: 42 }, 7: { value: 43, valueSourceIndex: 1 },
                                    8: { value: 44 }, 9: { value: 45, valueSourceIndex: 1 },
                                    10: { value: 86 }, 11: { value: 88, valueSourceIndex: 1 },
                                    12: { value: 160 }, 13: { value: 164, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 60 }, 1: { value: 62, valueSourceIndex: 1 },
                                    2: { value: 64 }, 3: { value: 66, valueSourceIndex: 1 },
                                    4: { value: 124 }, 5: { value: 128, valueSourceIndex: 1 },
                                    6: { value: 72 }, 7: { value: 74, valueSourceIndex: 1 },
                                    8: { value: 76 }, 9: { value: 78, valueSourceIndex: 1 },
                                    10: { value: 148 }, 11: { value: 152, valueSourceIndex: 1 },
                                    12: { value: 272 }, 13: { value: 280, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "North America",
                        children: [
                            {
                                level: 1,
                                value: "United States",
                                values: {
                                    0: { value: 48 }, 1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 }, 3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 98 }, 5: { value: 100, valueSourceIndex: 1 },
                                    6: { value: 54 }, 7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 }, 9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 110 }, 11: { value: 112, valueSourceIndex: 1 },
                                    12: { value: 208 }, 13: { value: 212, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 48 }, 1: { value: 49, valueSourceIndex: 1 },
                                    2: { value: 50 }, 3: { value: 51, valueSourceIndex: 1 },
                                    4: { value: 98 }, 5: { value: 100, valueSourceIndex: 1 },
                                    6: { value: 54 }, 7: { value: 55, valueSourceIndex: 1 },
                                    8: { value: 56 }, 9: { value: 57, valueSourceIndex: 1 },
                                    10: { value: 110 }, 11: { value: 112, valueSourceIndex: 1 },
                                    12: { value: 208 }, 13: { value: 212, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: "Oceania",
                        children: [
                            {
                                level: 1,
                                value: "Australia",
                                values: {
                                    0: { value: 60 }, 1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 }, 3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 122 }, 5: { value: 124, valueSourceIndex: 1 },
                                    6: { value: 66 }, 7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 }, 9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 134 }, 11: { value: 136, valueSourceIndex: 1 },
                                    12: { value: 256 }, 13: { value: 260, valueSourceIndex: 1 }
                                }
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                values: {
                                    0: { value: 60 }, 1: { value: 61, valueSourceIndex: 1 },
                                    2: { value: 62 }, 3: { value: 63, valueSourceIndex: 1 },
                                    4: { value: 122 }, 5: { value: 124, valueSourceIndex: 1 },
                                    6: { value: 66 }, 7: { value: 67, valueSourceIndex: 1 },
                                    8: { value: 68 }, 9: { value: 69, valueSourceIndex: 1 },
                                    10: { value: 134 }, 11: { value: 136, valueSourceIndex: 1 },
                                    12: { value: 256 }, 13: { value: 260, valueSourceIndex: 1 }
                                }
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 180 }, 1: { value: 186, valueSourceIndex: 1 },
                            2: { value: 192 }, 3: { value: 198, valueSourceIndex: 1 },
                            4: { value: 372 }, 5: { value: 384, valueSourceIndex: 1 },
                            6: { value: 216 }, 7: { value: 222, valueSourceIndex: 1 },
                            8: { value: 228 }, 9: { value: 234, valueSourceIndex: 1 },
                            10: { value: 444 }, 11: { value: 456, valueSourceIndex: 1 },
                            12: { value: 816 }, 13: { value: 840, valueSourceIndex: 1 }
                        }
                    }
                ]
            },
            levels: [
                { sources: [rowGroupSource1] },
                { sources: [rowGroupSource2] }
            ]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: 1992,
                        children: [
                            {
                                level: 1,
                                value: "Silver",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Gold",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                children: [
                                    {
                                        level: 2,
                                        isSubtotal: true
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1,
                                        isSubtotal: true
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        value: 1996,
                        children: [
                            {
                                level: 1,
                                value: "Silver",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                value: "Gold",
                                children: [
                                    {
                                        level: 2
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1
                                    }
                                ]
                            },
                            {
                                level: 1,
                                isSubtotal: true,
                                children: [
                                    {
                                        level: 2,
                                        isSubtotal: true
                                    },
                                    {
                                        level: 2,
                                        levelSourceIndex: 1,
                                        isSubtotal: true
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        children: [
                            {
                                level: 2,
                                isSubtotal: true
                            },
                            {
                                level: 2,
                                levelSourceIndex: 1,
                                isSubtotal: true
                            }
                        ]
                    }
                ]
            },
            levels: [
                { sources: [columnGroupSource1] },
                { sources: [columnGroupSource2] },
                {
                    sources: [
                        measureSource1,
                        measureSource2
                    ]
                }
            ]
        },
        valueSources: [
            measureSource1,
            measureSource2
        ]
    };
    var matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotalsDataView = {
        metadata: {
            columns: [
                rowGroupSource1,
                rowGroupSource2,
                columnGroupSource1,
                columnGroupSource2,
                measureSource1,
                measureSource2
            ]
        },
        matrix: matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals
    };
    // ----------------------------
    // | RowGroup4 | true | false |
    // |-----------+--------------|
    // |      true |    1 |     2 |
    // |-----------|------|-------|
    // |     false |    3 |     4 |
    // |-----------|------|-------|
    // |           |    5 |     6 |
    // ----------------------------
    var matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true,
                        values: {
                            0: { value: 1 },
                            1: { value: 2 }
                        }
                    },
                    {
                        level: 0,
                        value: false,
                        values: {
                            0: { value: 3 },
                            1: { value: 4 }
                        }
                    },
                    {
                        level: 0,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 }
                        }
                    }
                ]
            },
            levels: [{ sources: [rowGroupSource4] }]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true
                    },
                    {
                        level: 0,
                        value: false
                    }
                ]
            },
            levels: [{ sources: [columnGroupSource4] }]
        },
        valueSources: [measureSource1]
    };
    // ------------------------------------
    // | RowGroup4 | true | false | Total |
    // |-----------+----------------------|
    // |      true |    1 |     2 |   3   |
    // |-----------|------|-------|-------|
    // |     false |    3 |     4 |   7   |
    // |-----------|------|-------|-------|
    // |           |    5 |     6 |   11  |
    // |-----------|------|-------|-------|
    // |    Total  |    9 |    12 |   21  |
    // |----------------------------------|
    var matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals = {
        rows: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true,
                        values: {
                            0: { value: 1 },
                            1: { value: 2 },
                            2: { value: 3 }
                        }
                    },
                    {
                        level: 0,
                        value: false,
                        values: {
                            0: { value: 3 },
                            1: { value: 4 },
                            2: { value: 7 }
                        }
                    },
                    {
                        level: 0,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 },
                            2: { value: 11 }
                        }
                    },
                    {
                        level: 0,
                        isSubtotal: true,
                        values: {
                            0: { value: 5 },
                            1: { value: 6 },
                            2: { value: 21 }
                        }
                    }
                ]
            },
            levels: [{ sources: [rowGroupSource4] }]
        },
        columns: {
            root: {
                children: [
                    {
                        level: 0,
                        value: true
                    },
                    {
                        level: 0,
                        value: false
                    },
                    {
                        level: 0,
                        isSubtotal: true
                    }
                ]
            },
            levels: [{ sources: [columnGroupSource4] }]
        },
        valueSources: [measureSource1]
    };
    describe("Matrix", function () {
        it("Matrix registered capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("matrix").capabilities).toBe(Matrix.capabilities);
        });
        it("Capabilities should include dataViewMappings", function () { return expect(Matrix.capabilities.dataViewMappings).toBeDefined(); });
        it("Capabilities should include dataRoles", function () { return expect(Matrix.capabilities.dataRoles).toBeDefined(); });
        it("Capabilities should include row windowing", function () {
            expect(Matrix.capabilities.dataViewMappings[0].matrix.rows.dataReductionAlgorithm).toBeDefined();
        });
        it("Capabilities should allow measure only matrices", function () {
            var allowedProjections1 = {
                'Values': new QueryProjectionCollection([{ queryRef: "0" }])
            };
            var allowedProjections2 = {
                'Values': new QueryProjectionCollection([
                    { queryRef: "0" },
                    { queryRef: "1" },
                    { queryRef: "2" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should allow matrices with row groups only", function () {
            var allowedProjections1 = {
                'Rows': new QueryProjectionCollection([{ queryRef: "0" }])
            };
            var allowedProjections2 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "2" },
                    { queryRef: "0" },
                    { queryRef: "1" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should allow matrices with row groups and arbitrary number of measures", function () {
            var allowedProjections1 = {
                'Rows': new QueryProjectionCollection([{ queryRef: "0" }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "1" },
                    { queryRef: "2" },
                    { queryRef: "3" }
                ])
            };
            var allowedProjections2 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "3" },
                    { queryRef: "2" },
                    { queryRef: "1" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "0" }
                ])
            };
            var allowedProjections3 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "1" },
                    { queryRef: "0" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "2" },
                    { queryRef: "3" }
                ])
            };
            var allowedProjections4 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "0" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "1" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should allow matrices with column groups only", function () {
            var allowedProjections1 = {
                'Columns': new QueryProjectionCollection([{ queryRef: "0" }])
            };
            var allowedProjections2 = {
                'Columns': new QueryProjectionCollection([
                    { queryRef: "2" },
                    { queryRef: "0" },
                    { queryRef: "1" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should allow matrices with column groups and measures", function () {
            var allowedProjections1 = {
                'Columns': new QueryProjectionCollection([{ queryRef: "1" }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "2" },
                    { queryRef: "3" },
                    { queryRef: "0" }
                ])
            };
            var allowedProjections2 = {
                'Columns': new QueryProjectionCollection([
                    { queryRef: "0" },
                    { queryRef: "2" },
                    { queryRef: "1" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "3" }
                ])
            };
            var allowedProjections3 = {
                'Columns': new QueryProjectionCollection([
                    { queryRef: "3" },
                    { queryRef: "2" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "0" },
                    { queryRef: "1" }
                ])
            };
            var allowedProjections4 = {
                'Columns': new QueryProjectionCollection([
                    { queryRef: "1" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "0" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should allow matrices with row groups and arbitrary number of column groups and measures", function () {
            var allowedProjections1 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "0" }
                ]),
                'Columns': new QueryProjectionCollection([
                    { queryRef: "1" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "2" }
                ])
            };
            var allowedProjections2 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "0" },
                    { queryRef: "1" }
                ]),
                'Columns': new QueryProjectionCollection([
                    { queryRef: "2" },
                    { queryRef: "3" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "4" }
                ])
            };
            var allowedProjections3 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "0" },
                    { queryRef: "1" }
                ]),
                'Columns': new QueryProjectionCollection([
                    { queryRef: "2" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "3" },
                    { queryRef: "4" }
                ])
            };
            var allowedProjections4 = {
                'Rows': new QueryProjectionCollection([
                    { queryRef: "0" }
                ]),
                'Columns': new QueryProjectionCollection([
                    { queryRef: "1" },
                    { queryRef: "2" }
                ]),
                'Values': new QueryProjectionCollection([
                    { queryRef: "3" },
                    { queryRef: "4" }
                ])
            };
            var dataViewMappings = Matrix.capabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it("Capabilities should suppressDefaultTitle", function () {
            expect(Matrix.capabilities.suppressDefaultTitle).toBe(true);
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Matrix.capabilities.objects)).toEqual(Matrix.formatStringProp);
        });
        it("CustomizeQuery picks up enabled row subtotals", function () {
            var objects = {
                general: {
                    rowSubtotals: true,
                    columnSubtotals: false
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(CompiledSubtotalType.None);
        });
        it("CustomizeQuery picks up enabled column subtotals", function () {
            var objects = {
                general: {
                    rowSubtotals: false,
                    columnSubtotals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(CompiledSubtotalType.None);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
        });
        it("CustomizeQuery picks up enabled row and column subtotals", function () {
            var objects = {
                general: {
                    rowSubtotals: true,
                    columnSubtotals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
        });
        it("CustomizeQuery handles missing settings", function () {
            var dataViewMapping = createCompiledDataViewMapping();
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Totals default to Enabled (After)
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
        });
        it("CustomizeQuery handles missing subtotal settings", function () {
            var objects = {
                general: {
                    rowSubtotals: undefined,
                    columnSubtotals: undefined
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Matrix.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Totals default to Enabled (After)
            expect(dataViewMapping.matrix.rows.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
            expect(dataViewMapping.matrix.columns.for.in.subtotalType).toEqual(CompiledSubtotalType.After);
        });
        function createCompiledDataViewMapping(objects) {
            return {
                metadata: {
                    objects: objects
                },
                matrix: {
                    rows: {
                        for: {
                            in: { role: "Rows", items: [] }
                        }
                    },
                    columns: {
                        for: {
                            in: { role: "Columns", items: [] }
                        }
                    }
                }
            };
        }
    });
    describe("Tablix control tests", function () {
        it("touch disabled", function () {
            var layoutKind = powerbi.visuals.controls.TablixLayoutKind.Canvas;
            var matrix = matrixOneMeasure;
            var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
            var binder = new powerbi.visuals.MatrixBinder(navigator, { layoutKind: layoutKind });
            var layoutManager = powerbi.visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(binder);
            var parent = document.createElement("div");
            var tablixControl = new powerbi.visuals.controls.TablixControl(navigator, layoutManager, binder, parent, { interactive: true, enableTouchSupport: false });
            expect(tablixControl["_touchManager"]).toBeUndefined();
        });
    });
    describe("Matrix hierarchy navigator tests", function () {
        describe("getDepth", function () {
            it("returns the correct depth for an empty hierarchy", function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(1);
            });
            it("returns the correct depth for a measure only hierarchy", function () {
                var matrix = matrixOneMeasure;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(1);
            });
            it("returns the correct depth for group only hierarchy", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(rowHierarchy)).toBe(3);
            });
            it("returns the correct depth for group and measure hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getDepth(columnHierarchy)).toBe(3);
            });
        });
        describe("getLeafCount", function () {
            it("returns the right leaf count for a placeholder hierarchy", function () {
                var matrix = matrixOneMeasure;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(rowHierarchy)).toBe(1);
            });
            it("returns the right leaf count for an empty hierarchy", function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(columnHierarchy)).toBe(0);
            });
            it("returns the right leaf count for a one level deep hierarchy", function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(rowHierarchy)).toBe(1);
            });
            it("returns the right leaf count for a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafCount(columnHierarchy)).toBe(12);
            });
        });
        describe("getLeafAt", function () {
            it("returns the correct leaf from a placeholder hierarchy", function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(rowHierarchy, 0)).toBe(rowHierarchyItem);
            });
            it("returns the correct leaf from a one level deep hierarchy", function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(columnHierarchy, 0)).toBe(columnHierarchyItem);
            });
            it("returns the correct leaf from a three level deep hierarchy", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem = rowHierarchy[1].children[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLeafAt(rowHierarchy, 7)).toBe(rowHierarchyItem);
            });
        });
        describe("getParent", function () {
            it("returns null for outermost node in a one level deep hierarchy", function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var node = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBeNull();
            });
            it("returns null for outermost node in a three level deep hierarchy", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var node = matrix.rows.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBeNull();
            });
            it("returns the correct parent for an innermost node in a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var parentNode = matrix.columns.root.children[1].children[1];
                var node = parentNode.children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBe(parentNode);
            });
            it("returns the correct parent for a non-innermost node in a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var parentNode = matrix.columns.root.children[0];
                var node = parentNode.children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getParent(node)).toBe(parentNode);
            });
        });
        describe("getIndex", function () {
            it("returns the correct index for outermost nodes", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchy[0])).toBe(0);
                expect(navigator.getIndex(rowHierarchy[1])).toBe(1);
                expect(navigator.getIndex(rowHierarchy[2])).toBe(2);
                expect(navigator.getIndex(rowHierarchy[3])).toBe(3);
            });
            it("returns the correct index for innermost nodes", function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem0 = rowHierarchy[0].children[0].children[0];
                var rowHierarchyItem1 = rowHierarchy[0].children[0].children[1];
                var rowHierarchyItemAgain0 = rowHierarchy[1].children[1].children[0];
                var rowHierarchyItemAgain1 = rowHierarchy[1].children[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchyItem0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItem1)).toBe(1);
                expect(navigator.getIndex(rowHierarchyItemAgain0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItemAgain1)).toBe(1);
            });
            it("returns the correct index for non-innermost nodes", function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowHierarchyItem0 = rowHierarchy[0].children[0];
                var rowHierarchyItem1 = rowHierarchy[0].children[1];
                var rowHierarchyItemAgain0 = rowHierarchy[1].children[0];
                var rowHierarchyItemAgain1 = rowHierarchy[1].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getIndex(rowHierarchyItem0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItem1)).toBe(1);
                expect(navigator.getIndex(rowHierarchyItemAgain0)).toBe(0);
                expect(navigator.getIndex(rowHierarchyItemAgain1)).toBe(1);
            });
        });
        describe("isLeaf", function () {
            it("returns true for nodes in a one level deep placeholder hierarchy", function () {
                var matrix = matrixThreeMeasures;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(rowHierarchy[0])).toBeTruthy();
            });
            it("returns true for nodes in a one level deep hierarchy", function () {
                var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(rowHierarchy[0])).toBeTruthy();
            });
            it("returns true for innermost nodes in a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[1].children[2].children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchyItem)).toBeTruthy();
            });
            it("returns false for outermost nodes in a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchy[0])).toBeFalsy();
            });
            it("returns false for non-innermost nodes in a three level deep hierarchy", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var columnHierarchy = matrix.columns.root.children;
                var columnHierarchyItem = columnHierarchy[0].children[1];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLeaf(columnHierarchyItem)).toBeFalsy();
            });
        });
        describe("isRowHierarchyLeaf", function () {
            // TODO
        });
        describe("isColumnHierarchyLeaf", function () {
            // TODO
        });
        describe("isLastItem", function () {
            it("returns true if the last item is the only item in the collection", function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneInstance;
                var items = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(items[0], items)).toBeTruthy();
            });
            it("returns true if the last item is the last item in its parents collection, but not on the level", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var items = matrix.rows.root.children[0].children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(items[1], items)).toBeTruthy();
            });
            it("returns false if the item is not the last item in its parents collection", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var items = matrix.rows.root.children[1].children[1].children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.isLastItem(items[0], items)).toBeFalsy();
            });
        });
        describe("getChildren", function () {
            it("returns undefined for leaf node", function () {
                var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
                var node = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getChildren(node)).toBeUndefined();
            });
            it("returns the correct collection of children", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var node = matrix.rows.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getChildren(node)).toBe(node.children);
            });
        });
        describe("getCount", function () {
            it("returns zero if there are no children", function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCount(columnHierarchy)).toBe(0);
            });
            it("returns the length of the children array", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCount(columnHierarchy)).toBe(3);
            });
        });
        describe("getAt", function () {
            it("returns undefined if index is out of bounds", function () {
                var matrix = matrixThreeRowGroupsOneGroupInstance;
                var columnHierarchy = matrix.columns.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(columnHierarchy, 0)).toBeUndefined();
            });
            it("returns the right node from the hierarchy", function () {
                var matrix = matrixThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(rowHierarchy, 1)).toBe(rowHierarchy[1]);
            });
            it("returns the right node from the children collection", function () {
                var matrix = matrixThreeRowGroups;
                var children = matrix.rows.root.children[0].children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getAt(children, 1)).toBe(children[1]);
            });
        });
        describe("getLevel", function () {
            it("returns undefined for root node", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var rootNode = matrix.columns.root;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(rootNode)).toBeUndefined();
            });
            it("returns zero for outermost nodes", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroupsOneInstance;
                var node = matrix.rows.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(node)).toBe(0);
            });
            it("returns one for nodes on the second level", function () {
                var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
                var nodes = matrix.rows.root.children[1].children;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getLevel(nodes[0])).toBe(1);
                expect(navigator.getLevel(nodes[1])).toBe(1);
            });
        });
        describe("getIntersection", function () {
            it("returns values in the intersection", function () {
                var matrix = matrixThreeMeasuresThreeRowGroups;
                var rowHierarchy = matrix.rows.root.children;
                var columnHierarchy = matrix.columns.root.children;
                var level2RowItems = [
                    rowHierarchy[0].children[0],
                    rowHierarchy[0].children[1],
                    rowHierarchy[1].children[0],
                    rowHierarchy[1].children[1]
                ];
                var level3RowItems = [
                    level2RowItems[0].children[0],
                    level2RowItems[0].children[1],
                    level2RowItems[1].children[0],
                    level2RowItems[1].children[1],
                    level2RowItems[2].children[0],
                    level2RowItems[2].children[1],
                    level2RowItems[3].children[0],
                    level2RowItems[3].children[1]
                ];
                var level1ColumnItems = [
                    columnHierarchy[0],
                    columnHierarchy[1],
                    columnHierarchy[2]
                ];
                var expectedValues = [
                    ["1,000.00", "1,001.00", "1,002.00"],
                    ["1,010.00", "1,011.00", "1,012.00"],
                    ["1,100.00", "1,101.00", "1,102.00"],
                    ["1,110.00", "1,111.00", "1,112.00"],
                    ["2,000.00", "2,001.00", "2,002.00"],
                    ["2,010.00", "2,011.00", "2,012.00"],
                    ["2,100.00", "2,101.00", "2,102.00"],
                    ["2,110.00", "2,111.00", "2,112.00"]
                ];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                validateIntersections(navigator, level3RowItems, level1ColumnItems, expectedValues);
            });
            it("returns empty string if there are no measures", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var rowHierarchy = matrix.rows.root.children;
                var rowLeaves = rowHierarchy[0].children[0].children.concat(rowHierarchy[0].children[1].children);
                var columnHierarchy = matrix.columns.root.children;
                var columnLeaves = columnHierarchy[0].children[0].children.concat(columnHierarchy[0].children[1]);
                var expectedValues = [
                    ["", "", ""],
                    ["", "", ""],
                    ["", "", ""]
                ];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                validateIntersections(navigator, rowLeaves, columnLeaves, expectedValues);
            });
            function validateIntersections(navigator, rowLeaves, columnLeaves, expectedValues) {
                var result = [];
                for (var i = 0, ilen = rowLeaves.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columnLeaves.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rowLeaves[i], columnLeaves[j]).content;
                }
                expect(result).toEqual(expectedValues);
            }
        });
        describe("getCorer", function () {
            it("returns empty value for the upper left cell of a 3x3 corner", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(0, 0).metadata).toBeNull();
                expect(navigator.getCorner(0, 0).isColumnHeaderLeaf).toBeFalsy();
            });
            it("returns row header for the lower left cell of a 3x3 corner", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(0, 2).metadata.displayName).toBe("RowGroup1");
                expect(navigator.getCorner(0, 2).isColumnHeaderLeaf).toBeTruthy();
            });
            it("returns column header for the upper right cell of a 3x3 corner", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(2, 0).metadata.displayName).toBe("ColGroup1");
                expect(navigator.getCorner(2, 0).isColumnHeaderLeaf).toBeFalsy();
            });
            it("returns row header for the lower right cell of a 3x3 corner", function () {
                var matrix = matrixThreeRowGroupsThreeColumnGroups;
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.getCorner(2, 2).metadata.displayName).toBe("RowGroup3");
                expect(navigator.getCorner(2, 2).isColumnHeaderLeaf).toBeTruthy();
            });
        });
        describe("headerItemEquals", function () {
            it("returns true if the two items are the same", function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
                var rowNode = matrix.rows.root.children[0];
                var columnNode = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.headerItemEquals(rowNode, rowNode)).toBeTruthy();
                expect(navigator.headerItemEquals(columnNode, columnNode)).toBeTruthy();
            });
            it("returns false if the two items are not same even if they have the same content", function () {
                var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
                var rowNode = matrix.rows.root.children[0];
                var columnNode = matrix.columns.root.children[0];
                var navigator = powerbi.visuals.createMatrixHierarchyNavigator(matrix, valueFormatter.formatRaw);
                expect(navigator.headerItemEquals(rowNode, columnNode)).toBeFalsy();
                expect(navigator.headerItemEquals(columnNode, rowNode)).toBeFalsy();
            });
        });
    });
    describe("Matrix logic", function () {
        var v;
        beforeEach(function () {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("matrix").create();
            var element = powerbitests.helpers.testDom("500", "500");
            element["visible"] = function () { return true; };
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: 500,
                    width: 500
                },
                animation: { transitionImmediate: true }
            });
        });
        it("loadMoreData calls control refresh", function () {
            var nav = { updateRows: function () { } };
            var control = { refresh: function () { } };
            var navSpy = spyOn(nav, "updateRows");
            var controlSpy = spyOn(control, "refresh");
            v["hierarchyNavigator"] = nav;
            v["tablixControl"] = control;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView],
                operationKind: 1 /* Append */
            });
            expect(navSpy).toHaveBeenCalled();
            expect(controlSpy).toHaveBeenCalled();
        });
        it("needsMoreData waitingForData", function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
                        matrix: matrix
                    }]
            });
            v["waitingForData"] = true;
            var matrixVisual = v;
            var lastLeaf = matrix.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(lastLeaf);
            expect(result).toBe(false);
        });
        it("needsMoreData notLeaf", function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3], segment: {} },
                        matrix: matrix
                    }]
            });
            var matrixVisual = v;
            var item = matrix.rows.root.children[1].children[1];
            var result = matrixVisual.needsMoreData(item);
            expect(result).toBe(false);
        });
        it("needsMoreData segmentComplete", function () {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [rowGroupSource1, rowGroupSource2, rowGroupSource3] },
                        matrix: matrix
                    }]
            });
            var matrixVisual = v;
            var lastLeaf = matrix.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(lastLeaf);
            expect(result).toBe(false);
        });
        it("needsMoreData belowThreshold", function () {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasures;
            v.onDataChanged({
                dataViews: [matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView]
            });
            var matrixVisual = v;
            var leaf = matrix.rows.root.children[0].children[0];
            var result = matrixVisual.needsMoreData(leaf);
            expect(result).toBe(false);
        });
        it("needsMoreData aboveThreshold", function () {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrixVisual = v;
            var leaf = matrixThreeMeasuresThreeRowGroups.rows.root.children[1].children[1].children[1];
            var result = matrixVisual.needsMoreData(leaf);
            expect(result).toBe(true);
        });
        it("bindRowHeader callback", function () {
            var callBackCalled = false;
            var binderOptions = {
                onBindRowHeader: function () { callBackCalled = true; },
                layoutKind: powerbi.visuals.controls.TablixLayoutKind.Canvas
            };
            var binder = new powerbi.visuals.MatrixBinder(null, binderOptions);
            binder.bindRowHeader({ displayName: null }, {
                type: null, item: null, colSpan: 0, rowSpan: 0, textAlign: "",
                extension: { contentHost: { textContent: null }, setContainerStyle: function () { } }
            });
            expect(callBackCalled).toBe(true);
        });
        it("unbindColumnHeader multimeasure not sortable", function () {
            var binderOptions = {
                onBindRowHeader: function () { },
                onColumnHeaderClick: function () { },
                layoutKind: powerbi.visuals.controls.TablixLayoutKind.Canvas
            };
            var hierarchyNavigator = powerbi.visuals.createMatrixHierarchyNavigator(matrixTwoRowGroupsTwoColumnGroupsTwoMeasures, powerbi.visuals.valueFormatter.formatRaw);
            var binder = new powerbi.visuals.MatrixBinder(hierarchyNavigator, binderOptions);
            var unregisterCalled = false;
            binder.unbindColumnHeader({ displayName: null, isSubtotal: true }, {
                type: null, item: null, colSpan: 0, rowSpan: 0, textAlign: "",
                extension: {
                    contentHost: { textContent: null },
                    setContainerStyle: function () { },
                    clearContainerStyle: function () { },
                    unregisterClickHandler: function () { unregisterCalled = true; }
                }
            });
            expect(unregisterCalled).toBe(false);
        });
        it("enumerateObjectInstances general both totals off", function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: false,
                                    columnSubtotals: false
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            var objects = v.enumerateObjectInstances({ objectName: "general" });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: "general",
                    properties: {
                        rowSubtotals: false,
                        columnSubtotals: false
                    }
                }]);
        });
        it("enumerateObjectInstances general both totals on", function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            var objects = v.enumerateObjectInstances({ objectName: "general" });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: "general",
                    properties: {
                        rowSubtotals: true,
                        columnSubtotals: true
                    }
                }]);
        });
        it("enumerateObjectInstances general no objects", function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ]
                        },
                        matrix: matrix
                    }]
            });
            var objects = v.enumerateObjectInstances({ objectName: "general" });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: "general",
                    properties: {
                        rowSubtotals: true,
                        columnSubtotals: true
                    }
                }]);
        });
        it("enumerateObjectInstances general no properties", function () {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ],
                            objects: {
                                general: {}
                            }
                        },
                        matrix: matrix
                    }]
            });
            var objects = v.enumerateObjectInstances({ objectName: "general" });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: "general",
                    properties: {
                        rowSubtotals: true,
                        columnSubtotals: true
                    }
                }]);
            it("RefreshControl invisible parent", function () {
                var control = { refresh: function () { } };
                var controlSpy = spyOn(control, "refresh");
                v["shouldAllowHeaderResize"] = function () { return true; };
                v["hierarchyNavigator"] = { update: function () { } };
                v["tablixControl"] = control;
                v["element"]["visible"] = function () { return false; };
                v.onResizing({ width: 100, height: 100 });
                expect(controlSpy).not.toHaveBeenCalled();
            });
            it("RefreshControl invisible parent but dashboard layout", function () {
                var control = { refresh: function () { } };
                var controlSpy = spyOn(control, "refresh");
                v["shouldAllowHeaderResize"] = function () { return true; };
                v["hierarchyNavigator"] = { update: function () { } };
                v["tablixControl"] = control;
                v["element"]["visible"] = function () { return false; };
                v["isInteractive"] = false;
                v.onResizing({ width: 100, height: 100 });
                expect(controlSpy).toHaveBeenCalled();
            });
            it("ShouldClearControl noSort", function (done) {
                v.onDataChanged({ dataViews: [matrixOneMeasureDataView] });
                var refreshSpy = spyOn(v, "refreshControl").and.callFake(function () { });
                v.onDataChanged({ dataViews: [matrixOneMeasureDataView] });
                setTimeout(function () {
                    expect(refreshSpy).toHaveBeenCalledWith(false);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("ShouldClearControl sort", function (done) {
                v.onDataChanged({ dataViews: [matrixOneMeasureDataView] });
                var refreshSpy = spyOn(v, "refreshControl").and.callFake(function () { });
                v["waitingForSort"] = true;
                v.onDataChanged({ dataViews: [matrixOneMeasureDataView] });
                setTimeout(function () {
                    expect(refreshSpy).toHaveBeenCalledWith(true);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        });
    });
    describe("Matrix DOM validation", function () {
        var v, element, EmptyHeaderCell = "\xa0", NoMarginClass = "bi-tablix-cellNoMarginStyle", HeaderClass = "bi-tablix-header", ColumnHeaderLeafClass = "bi-tablix-column-header-leaf", RowHeaderLeafClass = "bi-tablix-row-header-leaf", RowHeaderTopLevelStaticLeafClass = "bi-tablix-row-header-toplevel-static-leaf", RowHeaderStaticLeafClass = "bi-tablix-row-header-static-leaf", BodyCellClass = "bi-matrix-body-cell", TotalClass = "total", NumericCellClassName = " bi-table-cell-numeric", TableTotalLabel = "Total";
        beforeEach(function () {
            element = powerbitests.helpers.testDom("1500", "1500");
            element["visible"] = function () { return true; };
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("matrix").create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true
                },
                interactivity: {
                    selection: true
                }
            });
        });
        function validateMatrix(expectedValues) {
            powerbitests.tablixHelper.validateMatrix(expectedValues, ".bi-tablix tr");
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, ".bi-tablix tr", NoMarginClass);
        }
        it("1x2 matrix (value and static column header)", function (done) {
            var matrix = matrixOneMeasure;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            setTimeout(function () {
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ["", measureSource1.displayName, ""],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ""],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("1x2 matrix (value and column header value) update", function (done) {
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            // Call onDataChanged again to trigger an update on the hierarchy navigator
            var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneMeasureOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ["", headerValue, ""],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ""],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x2 matrix (values and static column headers)", function (done) {
            var matrix = matrixThreeMeasures;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [measureSource1, measureSource2, measureSource3] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ["", measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ""],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ""],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x3 matrix (values, static and value column headers)", function (done) {
            var matrix = matrixThreeMeasuresOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ["", headerValue, ""],
                    ["", measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass + NumericCellClassName, ""],
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("6x9 matrix (values, static column headers and row value headers)", function (done) {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrix = matrixThreeMeasuresThreeRowGroups;
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var cellValue1 = formatter(header_1_1_1.values[0].value, measureSource1);
                var cellValue2 = formatter(header_1_1_1.values[1].value, measureSource2);
                var cellValue3 = formatter(header_1_1_1.values[2].value, measureSource3);
                var cellValue4 = formatter(header_1_1_2.values[0].value, measureSource1);
                var cellValue5 = formatter(header_1_1_2.values[1].value, measureSource2);
                var cellValue6 = formatter(header_1_1_2.values[2].value, measureSource3);
                var cellValue7 = formatter(header_1_2_1.values[0].value, measureSource1);
                var cellValue8 = formatter(header_1_2_1.values[1].value, measureSource2);
                var cellValue9 = formatter(header_1_2_1.values[2].value, measureSource3);
                var cellValue10 = formatter(header_1_2_2.values[0].value, measureSource1);
                var cellValue11 = formatter(header_1_2_2.values[1].value, measureSource2);
                var cellValue12 = formatter(header_1_2_2.values[2].value, measureSource3);
                var cellValue13 = formatter(header_2_1_1.values[0].value, measureSource1);
                var cellValue14 = formatter(header_2_1_1.values[1].value, measureSource2);
                var cellValue15 = formatter(header_2_1_1.values[2].value, measureSource3);
                var cellValue16 = formatter(header_2_1_2.values[0].value, measureSource1);
                var cellValue17 = formatter(header_2_1_2.values[1].value, measureSource2);
                var cellValue18 = formatter(header_2_1_2.values[2].value, measureSource3);
                var cellValue19 = formatter(header_2_2_1.values[0].value, measureSource1);
                var cellValue20 = formatter(header_2_2_1.values[1].value, measureSource2);
                var cellValue21 = formatter(header_2_2_1.values[2].value, measureSource3);
                var cellValue22 = formatter(header_2_2_2.values[0].value, measureSource1);
                var cellValue23 = formatter(header_2_2_2.values[1].value, measureSource2);
                var cellValue24 = formatter(header_2_2_2.values[2].value, measureSource3);
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ""],
                    [header_1.value, header_1_1.value, header_1_1_1.value, cellValue1, cellValue2, cellValue3],
                    [header_1_1_2.value, cellValue4, cellValue5, cellValue6],
                    [header_1_2.value, header_1_2_1.value, cellValue7, cellValue8, cellValue9],
                    [header_1_2_2.value, cellValue10, cellValue11, cellValue12],
                    [header_2.value, header_2_1.value, header_2_1_1.value, cellValue13, cellValue14, cellValue15],
                    [header_2_1_2.value, cellValue16, cellValue17, cellValue18],
                    [header_2_2.value, header_2_2_1.value, cellValue19, cellValue20, cellValue21],
                    [header_2_2_2.value, cellValue22, cellValue23, cellValue24]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ""],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x2 matrix (value, static column header and row value header)", function (done) {
            var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [rowGroupSource1, measureSource1] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header = matrix.rows.root.children[0];
                var cellValue = formatter(header.values[0].value, measureSource1);
                var expectedCells = [
                    [rowGroupSource1.displayName, measureSource1.displayName, ""],
                    [header.value, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ""],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x2 matrix (value, column value header and row value header, empty cell)", function (done) {
            var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var columnHeader = matrix.columns.root.children[0];
                var rowHeader = matrix.rows.root.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, columnHeader.value.toString(), ""],
                    [rowHeader.value.toString(), ""]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x2 matrix (static column headers and row value headers)", function (done) {
            var matrix = matrixThreeRowGroupsOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixThreeRowGroupsOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeader_1_1_1 = rowHeader_1_1.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, ""],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeader_1_1_1.value.toString()]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ""],
                    [HeaderClass, HeaderClass, RowHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x6 matrix (static column headers and row value headers including empty ones)", function (done) {
            var matrix = matrixTwoRowGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, ""],
                    [header_1.value, EmptyHeaderCell],
                    [header_1_2.value],
                    [header_2.value, header_2_1.value],
                    [EmptyHeaderCell],
                    [EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ""],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("5x2 matrix (column value headers including empty ones)", function (done) {
            var matrix = matrixTwoColumnGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                columnGroupSource1,
                                columnGroupSource2
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    ["", header_1.value, header_2.value, EmptyHeaderCell, ""],
                    ["", EmptyHeaderCell, header_1_2.value, header_2_1.value, EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, ""],
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x9 matrix (static column headers and row value headers)", function (done) {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                rowGroupSource3
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, ""],
                    [header_1.value, header_1_1.value, header_1_1_1.value.toString()],
                    [header_1_1_2.value.toString()],
                    [header_1_2.value, header_1_2_1.value.toString()],
                    [header_1_2_2.value.toString()],
                    [header_2.value, header_2_1.value, header_2_1_1.value.toString()],
                    [header_2_1_2.value.toString()],
                    [header_2_2.value, header_2_2_1.value.toString()],
                    [header_2_2_2.value.toString()]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("1x1 matrix loadMoreData", function () {
            var matrix = {
                rows: {
                    root: {
                        children: [{
                                level: 0,
                                value: "1"
                            }]
                    },
                    levels: [{ sources: [rowGroupSource1] }]
                },
                columns: {
                    root: {
                        children: []
                    },
                    levels: []
                },
                valueSources: []
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1
                            ]
                        },
                        matrix: matrix
                    }]
            });
            var segment2 = {
                rows: {
                    root: {
                        children: [{
                                level: 0,
                                value: "2"
                            }]
                    },
                    levels: [{ sources: [rowGroupSource1] }]
                },
                columns: {
                    root: {
                        children: []
                    },
                    levels: []
                },
                valueSources: []
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTreeNodes(matrix.rows.root, segment2.rows.root, false);
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1
                            ]
                        },
                        matrix: matrix
                    }],
                operationKind: 1 /* Append */
            });
            var header1 = matrix.rows.root.children[0];
            var header2 = matrix.rows.root.children[1];
            var expectedCells = [
                [rowGroupSource1.displayName, ""],
                [header1.value],
                [header2.value]
            ];
            validateMatrix(expectedCells);
        });
        it("8x3 matrix (column value headers)", function (done) {
            var matrix = matrixThreeColumnGroups;
            v.onDataChanged({
                dataViews: [matrixThreeColumnGroupsDataView]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0].value.toString();
                var header_1_1_2 = header_1_1.children[1].value.toString();
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0].value.toString();
                var header_1_2_2 = header_1_2.children[1].value.toString();
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0].value.toString();
                var header_2_1_2 = header_2_1.children[1].value.toString();
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0].value.toString();
                var header_2_2_2 = header_2_2.children[1].value.toString();
                var expectedCells = [
                    ["", header_1.value, header_2.value, ""],
                    ["", header_1_1.value, header_1_2.value, header_2_1.value, header_2_2.value],
                    ["", header_1_1_1, header_1_1_2, header_1_2_1, header_1_2_2, header_2_1_1, header_2_1_2, header_2_2_1, header_2_2_2]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("6x5 matrix (column value headers and row value headers, multiple group instances, empty cells)", function (done) {
            var matrix = matrixThreeRowGroupsThreeColumnGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                rowGroupSource3formatted,
                                columnGroupSource1,
                                columnGroupSource2,
                                columnGroupSource3formatted
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeaderValue_1_1_1 = formatter(rowHeader_1_1.children[0].value, rowGroupSource3formatted);
                var rowHeaderValue_1_1_2 = formatter(rowHeader_1_1.children[1].value, rowGroupSource3formatted);
                var rowHeader_1_2 = rowHeader_1.children[1];
                var rowHeaderValue_1_2_1 = formatter(rowHeader_1_2.children[0].value, rowGroupSource3formatted);
                var colHeader_1 = matrix.columns.root.children[0];
                var colHeader_1_1 = colHeader_1.children[0];
                var colHeaderValue_1_1_1 = formatter(colHeader_1_1.children[0].value, columnGroupSource3formatted);
                var colHeaderValue_1_1_2 = formatter(colHeader_1_1.children[1].value, columnGroupSource3formatted);
                var colHeader_1_2 = colHeader_1.children[1];
                var colHeaderValue_1_2_1 = formatter(colHeader_1_2.children[0].value, columnGroupSource3formatted);
                var expectedCells = [
                    ["", "", columnGroupSource1.displayName, colHeader_1.value, ""],
                    ["", "", columnGroupSource2.displayName, colHeader_1_1.value, colHeader_1_2.value],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, colHeaderValue_1_1_1, colHeaderValue_1_1_2, colHeaderValue_1_2_1],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeaderValue_1_1_1, "", "", ""],
                    [rowHeaderValue_1_1_2, "", "", ""],
                    [rowHeader_1_2.value, rowHeaderValue_1_2_1, "", "", ""]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x4 matrix (boolean and null group instances)", function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), ""],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with row and column subtotals", function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ""],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1), formatter(rowHeader1.values[2].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1), formatter(rowHeader2.values[2].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1), formatter(rowHeader3.values[2].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4.values[0].value, measureSource1), formatter(rowHeader4.values[1].value, measureSource1), formatter(rowHeader4.values[2].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ""],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with multiple row and column group hierarchy levels, one measure with subtotals", function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                columnGroupSource1,
                                columnGroupSource2,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ["", columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ""],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1)]
                ];
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ""],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with multiple row and column group hierarchy levels, two measures with subtotals", function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                columnGroupSource1,
                                columnGroupSource2,
                                measureSource1,
                                measureSource2
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ["", columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel, ""],
                    ["", columnGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1), formatter(rowHeader1_1.values[7].value, measureSource1), formatter(rowHeader1_1.values[8].value, measureSource1), formatter(rowHeader1_1.values[9].value, measureSource1), formatter(rowHeader1_1.values[10].value, measureSource1), formatter(rowHeader1_1.values[11].value, measureSource1), formatter(rowHeader1_1.values[12].value, measureSource1), formatter(rowHeader1_1.values[13].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1), formatter(rowHeader1_2.values[7].value, measureSource1), formatter(rowHeader1_2.values[8].value, measureSource1), formatter(rowHeader1_2.values[9].value, measureSource1), formatter(rowHeader1_2.values[10].value, measureSource1), formatter(rowHeader1_2.values[11].value, measureSource1), formatter(rowHeader1_2.values[12].value, measureSource1), formatter(rowHeader1_2.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1), formatter(rowHeader1_t.values[7].value, measureSource1), formatter(rowHeader1_t.values[8].value, measureSource1), formatter(rowHeader1_t.values[9].value, measureSource1), formatter(rowHeader1_t.values[10].value, measureSource1), formatter(rowHeader1_t.values[11].value, measureSource1), formatter(rowHeader1_t.values[12].value, measureSource1), formatter(rowHeader1_t.values[13].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1), formatter(rowHeader2_1.values[7].value, measureSource1), formatter(rowHeader2_1.values[8].value, measureSource1), formatter(rowHeader2_1.values[9].value, measureSource1), formatter(rowHeader2_1.values[10].value, measureSource1), formatter(rowHeader2_1.values[11].value, measureSource1), formatter(rowHeader2_1.values[12].value, measureSource1), formatter(rowHeader2_1.values[13].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1), formatter(rowHeader2_2.values[7].value, measureSource1), formatter(rowHeader2_2.values[8].value, measureSource1), formatter(rowHeader2_2.values[9].value, measureSource1), formatter(rowHeader2_2.values[10].value, measureSource1), formatter(rowHeader2_2.values[11].value, measureSource1), formatter(rowHeader2_2.values[12].value, measureSource1), formatter(rowHeader2_2.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1), formatter(rowHeader2_t.values[7].value, measureSource1), formatter(rowHeader2_t.values[8].value, measureSource1), formatter(rowHeader2_t.values[9].value, measureSource1), formatter(rowHeader2_t.values[10].value, measureSource1), formatter(rowHeader2_t.values[11].value, measureSource1), formatter(rowHeader2_t.values[12].value, measureSource1), formatter(rowHeader2_t.values[13].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1), formatter(rowHeader3_1.values[7].value, measureSource1), formatter(rowHeader3_1.values[8].value, measureSource1), formatter(rowHeader3_1.values[9].value, measureSource1), formatter(rowHeader3_1.values[10].value, measureSource1), formatter(rowHeader3_1.values[11].value, measureSource1), formatter(rowHeader3_1.values[12].value, measureSource1), formatter(rowHeader3_1.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1), formatter(rowHeader3_t.values[7].value, measureSource1), formatter(rowHeader3_t.values[8].value, measureSource1), formatter(rowHeader3_t.values[9].value, measureSource1), formatter(rowHeader3_t.values[10].value, measureSource1), formatter(rowHeader3_t.values[11].value, measureSource1), formatter(rowHeader3_t.values[12].value, measureSource1), formatter(rowHeader3_t.values[13].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1), formatter(rowHeader4_1.values[7].value, measureSource1), formatter(rowHeader4_1.values[8].value, measureSource1), formatter(rowHeader4_1.values[9].value, measureSource1), formatter(rowHeader4_1.values[10].value, measureSource1), formatter(rowHeader4_1.values[11].value, measureSource1), formatter(rowHeader4_1.values[12].value, measureSource1), formatter(rowHeader4_1.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1), formatter(rowHeader4_t.values[7].value, measureSource1), formatter(rowHeader4_t.values[8].value, measureSource1), formatter(rowHeader4_t.values[9].value, measureSource1), formatter(rowHeader4_t.values[10].value, measureSource1), formatter(rowHeader4_t.values[11].value, measureSource1), formatter(rowHeader4_t.values[12].value, measureSource1), formatter(rowHeader4_t.values[13].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1), formatter(rowHeadert.values[7].value, measureSource1), formatter(rowHeadert.values[8].value, measureSource1), formatter(rowHeadert.values[9].value, measureSource1), formatter(rowHeadert.values[10].value, measureSource1), formatter(rowHeadert.values[11].value, measureSource1), formatter(rowHeadert.values[12].value, measureSource1), formatter(rowHeadert.values[13].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + " " + TotalClass + NumericCellClassName, ""],
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + " " + TotalClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + " " + TotalClass + NumericCellClassName],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify Interactivity modes", function (done) {
            // Pick a matrix that exceeds the viewport
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: {
                    isInteractiveLegend: false,
                    selection: true
                }
            });
            v.onDataChanged({
                dataViews: [matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView]
            });
            setTimeout(function () {
                var scrollbars = $(".bi-tablix .scroll-bar-div");
                var verticalScrollbar = scrollbars.eq(0);
                var horizontalScrollbar = scrollbars.eq(1);
                // Check Style
                expect(verticalScrollbar.css("width")).toBe("0px");
                expect(horizontalScrollbar.css("height")).toBe("0px");
                // Check Values
                expect(verticalScrollbar.width()).toBe(0);
                expect(horizontalScrollbar.height()).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Matrix.formatStringProp));
        }
    });
    describe("Dashboard matrix DOM validation", function () {
        var v, element, EmptyHeaderCell = "\xa0", NoMarginClass = "bi-tablix-cellNoMarginStyle", HeaderClass = "bi-tablix-header", ColumnHeaderLeafClass = "bi-tablix-column-header-leaf", RowHeaderLeafClass = "bi-tablix-row-header-leaf", RowHeaderStaticLeafClass = "bi-tablix-row-header-static-leaf", RowHeaderTopLevelStaticLeafClass = "bi-tablix-row-header-toplevel-static-leaf", BodyCellClass = "bi-matrix-body-cell", TotalClass = "total", NumericCellClassName = " bi-table-cell-numeric", TableTotalLabel = "Total";
        beforeEach(function () {
            element = powerbitests.helpers.testDom("700", "700");
            element["visible"] = function () { return true; };
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("matrix").create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: {
                    transitionImmediate: true
                },
                interactivity: {
                    selection: null
                }
            });
        });
        function validateMatrix(expectedValues) {
            powerbitests.tablixHelper.validateMatrix(expectedValues, ".bi-dashboard-tablix tr");
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, ".bi-dashboard-tablix tr", NoMarginClass);
        }
        it("1x2 matrix (value and static column header)", function (done) {
            var matrix = matrixOneMeasure;
            v.onDataChanged({
                dataViews: [matrixOneMeasureDataView]
            });
            setTimeout(function () {
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ["", measureSource1.displayName],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("1x2 matrix (value and column header value)", function (done) {
            var matrix = matrixOneMeasureOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneMeasureOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var expectedCells = [
                    ["", headerValue],
                    [EmptyHeaderCell, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x2 matrix (values and static column headers)", function (done) {
            var matrix = matrixThreeMeasures;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [measureSource1, measureSource2, measureSource3] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ["", measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x3 matrix (values, static and value column headers)", function (done) {
            var matrix = matrixThreeMeasuresOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [columnGroupSource1, measureSource1, measureSource2, measureSource3] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var headerValue = matrix.columns.root.children[0].value;
                var cellValue1 = formatter(matrix.rows.root.children[0].values[0].value, measureSource1);
                var cellValue2 = formatter(matrix.rows.root.children[0].values[1].value, measureSource2);
                var cellValue3 = formatter(matrix.rows.root.children[0].values[2].value, measureSource3);
                var expectedCells = [
                    ["", headerValue],
                    ["", measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [EmptyHeaderCell, cellValue1, cellValue2, cellValue3]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass + NumericCellClassName],
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("6x9 matrix (values, static column headers and row value headers)", function (done) {
            v.onDataChanged({
                dataViews: [matrixThreeMeasuresThreeRowGroupsDataView]
            });
            var matrix = matrixThreeMeasuresThreeRowGroups;
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var cellValue1 = formatter(header_1_1_1.values[0].value, measureSource1);
                var cellValue2 = formatter(header_1_1_1.values[1].value, measureSource2);
                var cellValue3 = formatter(header_1_1_1.values[2].value, measureSource3);
                var cellValue4 = formatter(header_1_1_2.values[0].value, measureSource1);
                var cellValue5 = formatter(header_1_1_2.values[1].value, measureSource2);
                var cellValue6 = formatter(header_1_1_2.values[2].value, measureSource3);
                var cellValue7 = formatter(header_1_2_1.values[0].value, measureSource1);
                var cellValue8 = formatter(header_1_2_1.values[1].value, measureSource2);
                var cellValue9 = formatter(header_1_2_1.values[2].value, measureSource3);
                var cellValue10 = formatter(header_1_2_2.values[0].value, measureSource1);
                var cellValue11 = formatter(header_1_2_2.values[1].value, measureSource2);
                var cellValue12 = formatter(header_1_2_2.values[2].value, measureSource3);
                var cellValue13 = formatter(header_2_1_1.values[0].value, measureSource1);
                var cellValue14 = formatter(header_2_1_1.values[1].value, measureSource2);
                var cellValue15 = formatter(header_2_1_1.values[2].value, measureSource3);
                var cellValue16 = formatter(header_2_1_2.values[0].value, measureSource1);
                var cellValue17 = formatter(header_2_1_2.values[1].value, measureSource2);
                var cellValue18 = formatter(header_2_1_2.values[2].value, measureSource3);
                var cellValue19 = formatter(header_2_2_1.values[0].value, measureSource1);
                var cellValue20 = formatter(header_2_2_1.values[1].value, measureSource2);
                var cellValue21 = formatter(header_2_2_1.values[2].value, measureSource3);
                var cellValue22 = formatter(header_2_2_2.values[0].value, measureSource1);
                var cellValue23 = formatter(header_2_2_2.values[1].value, measureSource2);
                var cellValue24 = formatter(header_2_2_2.values[2].value, measureSource3);
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    [header_1.value, header_1_1.value, header_1_1_1.value, cellValue1, cellValue2, cellValue3],
                    [header_1_1_2.value, cellValue4, cellValue5, cellValue6],
                    [header_1_2.value, header_1_2_1.value, cellValue7, cellValue8, cellValue9],
                    [header_1_2_2.value, cellValue10, cellValue11, cellValue12],
                    [header_2.value, header_2_1.value, header_2_1_1.value, cellValue13, cellValue14, cellValue15],
                    [header_2_1_2.value, cellValue16, cellValue17, cellValue18],
                    [header_2_2.value, header_2_2_1.value, cellValue19, cellValue20, cellValue21],
                    [header_2_2_2.value, cellValue22, cellValue23, cellValue24]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x2 matrix (value, static column header and row value header)", function (done) {
            var matrix = matrixOneMeasureOneRowGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [rowGroupSource1, measureSource1] },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header = matrix.rows.root.children[0];
                var cellValue = formatter(header.values[0].value, measureSource1);
                var expectedCells = [
                    [rowGroupSource1.displayName, measureSource1.displayName],
                    [header.value, cellValue]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x2 matrix (value, column value header and row value header, empty cell)", function (done) {
            var matrix = matrixOneRowGroupOneColumnGroupOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var columnHeader = matrix.columns.root.children[0];
                var rowHeader = matrix.rows.root.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, columnHeader.value.toString()],
                    [rowHeader.value.toString(), ""]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x2 matrix (static column headers and row value headers)", function (done) {
            var matrix = matrixThreeRowGroupsOneGroupInstance;
            v.onDataChanged({
                dataViews: [matrixThreeRowGroupsOneGroupInstanceDataView]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeader_1_1_1 = rowHeader_1_1.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeader_1_1_1.value.toString()]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass],
                    [HeaderClass, HeaderClass, RowHeaderLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("2x6 matrix (static column headers and row value headers including empty ones)", function (done) {
            var matrix = matrixTwoRowGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName],
                    [header_1.value, EmptyHeaderCell],
                    [header_1_2.value],
                    [header_2.value, header_2_1.value],
                    [EmptyHeaderCell],
                    [EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass],
                    [RowHeaderStaticLeafClass],
                    [HeaderClass, RowHeaderStaticLeafClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("5x2 matrix (column value headers including empty ones)", function (done) {
            var matrix = matrixTwoColumnGroupsWithNullValues;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                columnGroupSource1,
                                columnGroupSource2
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_2 = header_1.children[1];
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var expectedCells = [
                    ["", header_1.value, header_2.value, EmptyHeaderCell],
                    ["", EmptyHeaderCell, header_1_2.value, header_2_1.value, EmptyHeaderCell, EmptyHeaderCell]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName],
                    [HeaderClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x9 matrix (static column headers and row value headers)", function (done) {
            var matrix = matrixThreeRowGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                rowGroupSource3
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var header_1 = matrix.rows.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0];
                var header_1_1_2 = header_1_1.children[1];
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0];
                var header_1_2_2 = header_1_2.children[1];
                var header_2 = matrix.rows.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0];
                var header_2_1_2 = header_2_1.children[1];
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0];
                var header_2_2_2 = header_2_2.children[1];
                var expectedCells = [
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName],
                    [header_1.value, header_1_1.value, header_1_1_1.value.toString()],
                    [header_1_1_2.value.toString()],
                    [header_1_2.value, header_1_2_1.value.toString()],
                    [header_1_2_2.value.toString()],
                    [header_2.value, header_2_1.value, header_2_1_1.value.toString()],
                    [header_2_1_2.value.toString()],
                    [header_2_2.value, header_2_2_1.value.toString()],
                    [header_2_2_2.value.toString()]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("8x3 matrix (column value headers)", function (done) {
            var matrix = matrixThreeColumnGroups;
            v.onDataChanged({
                dataViews: [matrixThreeColumnGroupsDataView]
            });
            setTimeout(function () {
                var header_1 = matrix.columns.root.children[0];
                var header_1_1 = header_1.children[0];
                var header_1_1_1 = header_1_1.children[0].value.toString();
                var header_1_1_2 = header_1_1.children[1].value.toString();
                var header_1_2 = header_1.children[1];
                var header_1_2_1 = header_1_2.children[0].value.toString();
                var header_1_2_2 = header_1_2.children[1].value.toString();
                var header_2 = matrix.columns.root.children[1];
                var header_2_1 = header_2.children[0];
                var header_2_1_1 = header_2_1.children[0].value.toString();
                var header_2_1_2 = header_2_1.children[1].value.toString();
                var header_2_2 = header_2.children[1];
                var header_2_2_1 = header_2_2.children[0].value.toString();
                var header_2_2_2 = header_2_2.children[1].value.toString();
                var expectedCells = [
                    ["", header_1.value, header_2.value],
                    ["", header_1_1.value, header_1_2.value, header_2_1.value, header_2_2.value],
                    ["", header_1_1_1, header_1_1_2, header_1_2_1, header_1_2_2, header_2_1_1, header_2_1_2, header_2_2_1, header_2_2_2]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("6x5 matrix (column value headers and row value headers, multiple group instances, empty cells)", function (done) {
            var matrix = matrixThreeRowGroupsThreeColumnGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                rowGroupSource3formatted,
                                columnGroupSource1,
                                columnGroupSource2,
                                columnGroupSource3formatted
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var rowHeader_1 = matrix.rows.root.children[0];
                var rowHeader_1_1 = rowHeader_1.children[0];
                var rowHeaderValue_1_1_1 = formatter(rowHeader_1_1.children[0].value, rowGroupSource3formatted);
                var rowHeaderValue_1_1_2 = formatter(rowHeader_1_1.children[1].value, rowGroupSource3formatted);
                var rowHeader_1_2 = rowHeader_1.children[1];
                var rowHeaderValue_1_2_1 = formatter(rowHeader_1_2.children[0].value, rowGroupSource3formatted);
                var colHeader_1 = matrix.columns.root.children[0];
                var colHeader_1_1 = colHeader_1.children[0];
                var colHeaderValue_1_1_1 = formatter(colHeader_1_1.children[0].value, columnGroupSource3formatted);
                var colHeaderValue_1_1_2 = formatter(colHeader_1_1.children[1].value, columnGroupSource3formatted);
                var colHeader_1_2 = colHeader_1.children[1];
                var colHeaderValue_1_2_1 = formatter(colHeader_1_2.children[0].value, columnGroupSource3formatted);
                var expectedCells = [
                    ["", "", columnGroupSource1.displayName, colHeader_1.value],
                    ["", "", columnGroupSource2.displayName, colHeader_1_1.value, colHeader_1_2.value],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, rowGroupSource3.displayName, colHeaderValue_1_1_1, colHeaderValue_1_1_2, colHeaderValue_1_2_1],
                    [rowHeader_1.value, rowHeader_1_1.value, rowHeaderValue_1_1_1, "", "", ""],
                    [rowHeaderValue_1_1_2, "", "", ""],
                    [rowHeader_1_2.value, rowHeaderValue_1_2_1, "", "", ""]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("3x4 matrix (boolean and null group instances)", function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasure;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ]
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString()],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with row and column subtotals", function (done) {
            var matrix = matrixRowGroupColumnGroupWithBooleanAndNullOneMeasureBothTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource4,
                                columnGroupSource4,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var expectedCells = [
                    [rowGroupSource4.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), formatter(rowHeader1.values[0].value, measureSource1), formatter(rowHeader1.values[1].value, measureSource1), formatter(rowHeader1.values[2].value, measureSource1)],
                    [rowHeader2.value.toString(), formatter(rowHeader2.values[0].value, measureSource1), formatter(rowHeader2.values[1].value, measureSource1), formatter(rowHeader2.values[2].value, measureSource1)],
                    [EmptyHeaderCell, formatter(rowHeader3.values[0].value, measureSource1), formatter(rowHeader3.values[1].value, measureSource1), formatter(rowHeader3.values[2].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4.values[0].value, measureSource1), formatter(rowHeader4.values[1].value, measureSource1), formatter(rowHeader4.values[2].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with multiple row and column group hierarchy levels, one measure with subtotals", function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                columnGroupSource1,
                                columnGroupSource2,
                                measureSource1
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var colHeader2_2 = matrix.columns.root.children[1].children[1];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ["", columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString(), TableTotalLabel],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString(), colHeader2_2.value.toString(), TableTotalLabel],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1)]
                ];
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                validateMatrix(expectedCells);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Matrix with multiple row and column group hierarchy levels, two measures with subtotals", function (done) {
            var matrix = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotals;
            v.onDataChanged({
                dataViews: [{
                        metadata: {
                            columns: [
                                rowGroupSource1,
                                rowGroupSource2,
                                columnGroupSource1,
                                columnGroupSource2,
                                measureSource1,
                                measureSource2
                            ],
                            objects: {
                                general: {
                                    rowSubtotals: true,
                                    columnSubtotals: true
                                }
                            }
                        },
                        matrix: matrix
                    }]
            });
            setTimeout(function () {
                var colHeader1 = matrix.columns.root.children[0];
                var colHeader1_1 = matrix.columns.root.children[0].children[0];
                var colHeader1_2 = matrix.columns.root.children[0].children[1];
                var colHeader2 = matrix.columns.root.children[1];
                var colHeader2_1 = matrix.columns.root.children[1].children[0];
                var rowHeader1 = matrix.rows.root.children[0];
                var rowHeader2 = matrix.rows.root.children[1];
                var rowHeader3 = matrix.rows.root.children[2];
                var rowHeader4 = matrix.rows.root.children[3];
                var rowHeadert = matrix.rows.root.children[4];
                var rowHeader1_1 = matrix.rows.root.children[0].children[0];
                var rowHeader1_2 = matrix.rows.root.children[0].children[1];
                var rowHeader1_t = matrix.rows.root.children[0].children[2];
                var rowHeader2_1 = matrix.rows.root.children[1].children[0];
                var rowHeader2_2 = matrix.rows.root.children[1].children[1];
                var rowHeader2_t = matrix.rows.root.children[1].children[2];
                var rowHeader3_1 = matrix.rows.root.children[2].children[0];
                var rowHeader3_t = matrix.rows.root.children[2].children[1];
                var rowHeader4_1 = matrix.rows.root.children[3].children[0];
                var rowHeader4_t = matrix.rows.root.children[3].children[1];
                var expectedCells = [
                    ["", columnGroupSource1.displayName, colHeader1.value.toString(), colHeader2.value.toString()],
                    ["", columnGroupSource2.displayName, colHeader1_1.value.toString(), colHeader1_2.value.toString(), TableTotalLabel, colHeader2_1.value.toString()],
                    [rowGroupSource1.displayName, rowGroupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource1.displayName, measureSource2.displayName],
                    [rowHeader1.value.toString(), rowHeader1_1.value.toString(), formatter(rowHeader1_1.values[0].value, measureSource1), formatter(rowHeader1_1.values[1].value, measureSource1), formatter(rowHeader1_1.values[2].value, measureSource1), formatter(rowHeader1_1.values[3].value, measureSource1), formatter(rowHeader1_1.values[4].value, measureSource1), formatter(rowHeader1_1.values[5].value, measureSource1), formatter(rowHeader1_1.values[6].value, measureSource1), formatter(rowHeader1_1.values[7].value, measureSource1)],
                    [rowHeader1_2.value.toString(), formatter(rowHeader1_2.values[0].value, measureSource1), formatter(rowHeader1_2.values[1].value, measureSource1), formatter(rowHeader1_2.values[2].value, measureSource1), formatter(rowHeader1_2.values[3].value, measureSource1), formatter(rowHeader1_2.values[4].value, measureSource1), formatter(rowHeader1_2.values[5].value, measureSource1), formatter(rowHeader1_2.values[6].value, measureSource1), formatter(rowHeader1_2.values[7].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader1_t.values[0].value, measureSource1), formatter(rowHeader1_t.values[1].value, measureSource1), formatter(rowHeader1_t.values[2].value, measureSource1), formatter(rowHeader1_t.values[3].value, measureSource1), formatter(rowHeader1_t.values[4].value, measureSource1), formatter(rowHeader1_t.values[5].value, measureSource1), formatter(rowHeader1_t.values[6].value, measureSource1), formatter(rowHeader1_t.values[7].value, measureSource1)],
                    [rowHeader2.value.toString(), rowHeader2_1.value.toString(), formatter(rowHeader2_1.values[0].value, measureSource1), formatter(rowHeader2_1.values[1].value, measureSource1), formatter(rowHeader2_1.values[2].value, measureSource1), formatter(rowHeader2_1.values[3].value, measureSource1), formatter(rowHeader2_1.values[4].value, measureSource1), formatter(rowHeader2_1.values[5].value, measureSource1), formatter(rowHeader2_1.values[6].value, measureSource1), formatter(rowHeader2_1.values[7].value, measureSource1)],
                    [rowHeader2_2.value.toString(), formatter(rowHeader2_2.values[0].value, measureSource1), formatter(rowHeader2_2.values[1].value, measureSource1), formatter(rowHeader2_2.values[2].value, measureSource1), formatter(rowHeader2_2.values[3].value, measureSource1), formatter(rowHeader2_2.values[4].value, measureSource1), formatter(rowHeader2_2.values[5].value, measureSource1), formatter(rowHeader2_2.values[6].value, measureSource1), formatter(rowHeader2_2.values[7].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader2_t.values[0].value, measureSource1), formatter(rowHeader2_t.values[1].value, measureSource1), formatter(rowHeader2_t.values[2].value, measureSource1), formatter(rowHeader2_t.values[3].value, measureSource1), formatter(rowHeader2_t.values[4].value, measureSource1), formatter(rowHeader2_t.values[5].value, measureSource1), formatter(rowHeader2_t.values[6].value, measureSource1), formatter(rowHeader2_t.values[7].value, measureSource1)],
                    [rowHeader3.value.toString(), rowHeader3_1.value.toString(), formatter(rowHeader3_1.values[0].value, measureSource1), formatter(rowHeader3_1.values[1].value, measureSource1), formatter(rowHeader3_1.values[2].value, measureSource1), formatter(rowHeader3_1.values[3].value, measureSource1), formatter(rowHeader3_1.values[4].value, measureSource1), formatter(rowHeader3_1.values[5].value, measureSource1), formatter(rowHeader3_1.values[6].value, measureSource1), formatter(rowHeader3_1.values[7].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader3_t.values[0].value, measureSource1), formatter(rowHeader3_t.values[1].value, measureSource1), formatter(rowHeader3_t.values[2].value, measureSource1), formatter(rowHeader3_t.values[3].value, measureSource1), formatter(rowHeader3_t.values[4].value, measureSource1), formatter(rowHeader3_t.values[5].value, measureSource1), formatter(rowHeader3_t.values[6].value, measureSource1), formatter(rowHeader3_t.values[7].value, measureSource1)],
                    [rowHeader4.value.toString(), rowHeader4_1.value.toString(), formatter(rowHeader4_1.values[0].value, measureSource1), formatter(rowHeader4_1.values[1].value, measureSource1), formatter(rowHeader4_1.values[2].value, measureSource1), formatter(rowHeader4_1.values[3].value, measureSource1), formatter(rowHeader4_1.values[4].value, measureSource1), formatter(rowHeader4_1.values[5].value, measureSource1), formatter(rowHeader4_1.values[6].value, measureSource1), formatter(rowHeader4_1.values[7].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeader4_t.values[0].value, measureSource1), formatter(rowHeader4_t.values[1].value, measureSource1), formatter(rowHeader4_t.values[2].value, measureSource1), formatter(rowHeader4_t.values[3].value, measureSource1), formatter(rowHeader4_t.values[4].value, measureSource1), formatter(rowHeader4_t.values[5].value, measureSource1), formatter(rowHeader4_t.values[6].value, measureSource1), formatter(rowHeader4_t.values[7].value, measureSource1)],
                    [TableTotalLabel, formatter(rowHeadert.values[0].value, measureSource1), formatter(rowHeadert.values[1].value, measureSource1), formatter(rowHeadert.values[2].value, measureSource1), formatter(rowHeadert.values[3].value, measureSource1), formatter(rowHeadert.values[4].value, measureSource1), formatter(rowHeadert.values[5].value, measureSource1), formatter(rowHeadert.values[6].value, measureSource1), formatter(rowHeadert.values[7].value, measureSource1)]
                ];
                validateMatrix(expectedCells);
                var expectedClassNames = [
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName],
                    [HeaderClass, RowHeaderLeafClass, HeaderClass + NumericCellClassName, HeaderClass + NumericCellClassName, HeaderClass + " " + TotalClass + NumericCellClassName, HeaderClass + NumericCellClassName],
                    [ColumnHeaderLeafClass, ColumnHeaderLeafClass + " " + RowHeaderLeafClass, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + " " + TotalClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName, ColumnHeaderLeafClass + NumericCellClassName],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [HeaderClass, RowHeaderStaticLeafClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass, BodyCellClass],
                    [RowHeaderStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass],
                    [RowHeaderTopLevelStaticLeafClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass, BodyCellClass + " " + TotalClass]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Matrix.formatStringProp));
        }
    });
    describe("Matrix sort validation", function () {
        var element;
        beforeEach(function (done) {
            element = powerbitests.helpers.testDom("1800", "1800");
            element["visible"] = function () { return true; };
            done();
        });
        it("matrix with single measure", function (done) {
            // Clicking on the measure will result in a sort event
            var data = matrixOneMeasureDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Measure1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with one measure and one column group", function (done) {
            // Clicking on a column group (even if there is only a single instance) will not result in a sort event
            var data = matrixOneMeasureOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Group A" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 0, col: 1 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with three measures", function (done) {
            // Clicking on any measure will result in a sort event
            var data = matrixThreeMeasuresDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Measure1" }, { row: 0, col: 2, expectedText: "Measure2" }, { row: 0, col: 3, expectedText: "Measure3" }];
            var clicks = [{ row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with three measures under one column group", function (done) {
            // Clicking on any column group or any measure underneath it will not result in a sort event
            var data = matrixThreeMeasuresOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "Group A" }, { row: 1, col: 1, expectedText: "Measure1" }, { row: 1, col: 2, expectedText: "Measure2" }, { row: 1, col: 3, expectedText: "Measure3" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with three measures and three row groups", function (done) {
            // Clicking on any row group or any measure will result in a sort event
            var data = matrixThreeMeasuresThreeRowGroupsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "RowGroup2" },
                { row: 0, col: 2, expectedText: "RowGroup3" },
                { row: 0, col: 3, expectedText: "Measure1" },
                { row: 0, col: 4, expectedText: "Measure2" },
                { row: 0, col: 5, expectedText: "Measure3" }];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }, { row: 0, col: 4 }, { row: 0, col: 5 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }],
                [{ queryName: "RowGroup2" }],
                [{ queryName: "RowGroup3" }],
                [{ queryName: "Measure1" }],
                [{ queryName: "Measure2" }],
                [{ queryName: "Measure3" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with one row group and one column group", function (done) {
            // Clicking on the row group will result in a sort event; clicking on the column group will not
            var data = matrixOneRowGroupOneColumnGroupOneGroupInstanceDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "10" }];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 1, col: 0 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with one row group and one column group", function (done) {
            // Clicking on any row group will result in a sort event
            var data = matrixThreeRowGroupsOneGroupInstanceDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 0, expectedText: "RowGroup1" },
                { row: 0, col: 1, expectedText: "RowGroup2" },
                { row: 0, col: 2, expectedText: "RowGroup3" }];
            var clicks = [{ row: 0, col: 0 }, { row: 0, col: 1 }, { row: 0, col: 2 }];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }], [{ queryName: "RowGroup2" }], [{ queryName: "RowGroup3" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with three column groups", function (done) {
            // Clicking on any column group will not result in a sort event
            var data = matrixThreeColumnGroupsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "Africa" }, { row: 0, col: 2, expectedText: "Asia" },
                { row: 1, col: 1, expectedText: "Algeria" }, { row: 1, col: 2, expectedText: "Angola" }, { row: 1, col: 3, expectedText: "China" }, { row: 1, col: 4, expectedText: "India" },
                { row: 2, col: 1, expectedText: "2008" }, { row: 2, col: 2, expectedText: "2012" }, { row: 2, col: 3, expectedText: "2008" }, { row: 2, col: 4, expectedText: "2012" }, { row: 2, col: 5, expectedText: "2008" }, { row: 2, col: 6, expectedText: "2012" }, { row: 2, col: 7, expectedText: "2008" }, { row: 2, col: 8, expectedText: "2012" }
            ];
            var clicks = [
                { row: 0, col: 1 }, { row: 0, col: 2 },
                { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }, { row: 1, col: 4 },
                { row: 2, col: 1 }, { row: 2, col: 2 }, { row: 2, col: 3 }, { row: 2, col: 4 }, { row: 2, col: 5 }, { row: 2, col: 6 }, { row: 2, col: 7 }, { row: 2, col: 8 }
            ];
            var expectedSorts = [];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with two row groups, two column groups and two measures", function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event
            var data = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" }, { row: 0, col: 2, expectedText: "1992" }, { row: 0, col: 3, expectedText: "1996" },
                { row: 1, col: 1, expectedText: "ColGroup2" }, { row: 1, col: 2, expectedText: "Bronze" }, { row: 1, col: 3, expectedText: "Gold" }, { row: 1, col: 4, expectedText: "Silver" }, { row: 1, col: 5, expectedText: "Bronze" }, { row: 1, col: 6, expectedText: "Gold" }, { row: 1, col: 7, expectedText: "Silver" },
                { row: 2, col: 0, expectedText: "RowGroup1" }, { row: 2, col: 1, expectedText: "RowGroup2" }, { row: 2, col: 2, expectedText: "Measure1" }, { row: 2, col: 3, expectedText: "Measure2" }, { row: 2, col: 4, expectedText: "Measure1" }, { row: 2, col: 5, expectedText: "Measure2" }, { row: 2, col: 6, expectedText: "Measure1" }, { row: 2, col: 7, expectedText: "Measure2" }, { row: 2, col: 8, expectedText: "Measure1" }, { row: 2, col: 9, expectedText: "Measure2" }, { row: 2, col: 10, expectedText: "Measure1" }, { row: 2, col: 11, expectedText: "Measure2" }, { row: 2, col: 12, expectedText: "Measure1" }
            ];
            var clicks = [
                { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 },
                { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }, { row: 1, col: 4 }, { row: 1, col: 5 }, { row: 1, col: 6 }, { row: 1, col: 7 },
                { row: 2, col: 0 }, { row: 2, col: 1 }, { row: 2, col: 2 }, { row: 2, col: 3 }, { row: 2, col: 4 }, { row: 2, col: 5 }, { row: 2, col: 6 }, { row: 2, col: 7 }, { row: 2, col: 8 }, { row: 2, col: 9 }, { row: 2, col: 10 }, { row: 2, col: 11 }, { row: 2, col: 12 }
            ];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }], [{ queryName: "RowGroup2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with two row groups, two column groups and one measure with totals", function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event; clicking on the column grand total will result in a sort (by measure)
            var data = matrixTwoRowGroupsTwoColumnGroupsOneMeasureAndTotalsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" }, { row: 0, col: 2, expectedText: "1992" }, { row: 0, col: 3, expectedText: "1996" }, { row: 0, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 0, expectedText: "RowGroup1" }, { row: 1, col: 1, expectedText: "RowGroup2" }, { row: 1, col: 2, expectedText: "Silver" }, { row: 1, col: 3, expectedText: "Gold" }, { row: 1, col: 4, expectedText: Matrix.TotalLabel }, { row: 1, col: 5, expectedText: "Silver" }, { row: 1, col: 6, expectedText: "Gold" }, { row: 1, col: 7, expectedText: Matrix.TotalLabel }
            ];
            var clicks = [
                { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }, { row: 0, col: 4 },
                { row: 1, col: 0 }, { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }, { row: 1, col: 4 }, { row: 1, col: 5 }, { row: 1, col: 6 }, { row: 1, col: 7 }
            ];
            var expectedSorts = [
                [{ queryName: "Measure1" }], [{ queryName: "RowGroup1" }], [{ queryName: "RowGroup2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with two row groups, two column groups and two measures with totals", function (done) {
            // Clicking on any row group will result in a sort event, clicking on any column group or measure column will not result in a sort event; clicking on the column grand total will result in a sort (by measure)
            var data = matrixTwoRowGroupsTwoColumnGroupsTwoMeasuresAndTotalsDataView;
            var expectedColumnHeaders = [
                { row: 0, col: 1, expectedText: "ColGroup1" }, { row: 0, col: 2, expectedText: "1992" }, { row: 0, col: 3, expectedText: "1996" }, { row: 0, col: 4, expectedText: Matrix.TotalLabel },
                { row: 1, col: 1, expectedText: "ColGroup2" }, { row: 1, col: 2, expectedText: "Silver" }, { row: 1, col: 3, expectedText: "Gold" }, { row: 1, col: 4, expectedText: Matrix.TotalLabel }, { row: 1, col: 5, expectedText: "Silver" }, { row: 1, col: 6, expectedText: "Gold" }, { row: 1, col: 7, expectedText: Matrix.TotalLabel },
                { row: 2, col: 0, expectedText: "RowGroup1" }, { row: 2, col: 1, expectedText: "RowGroup2" }, { row: 2, col: 2, expectedText: "Measure1" }, { row: 2, col: 3, expectedText: "Measure2" }, { row: 2, col: 4, expectedText: "Measure1" }, { row: 2, col: 5, expectedText: "Measure2" }, { row: 2, col: 6, expectedText: "Measure1" }, { row: 2, col: 7, expectedText: "Measure2" }, { row: 2, col: 8, expectedText: "Measure1" }, { row: 2, col: 9, expectedText: "Measure2" }, { row: 2, col: 10, expectedText: "Measure1" }, { row: 2, col: 11, expectedText: "Measure2" }, { row: 2, col: 12, expectedText: "Measure1" }, { row: 2, col: 13, expectedText: "Measure2" }, { row: 2, col: 14, expectedText: "Measure1" }, { row: 2, col: 15, expectedText: "Measure2" }
            ];
            var clicks = [
                { row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 3 }, { row: 0, col: 4 },
                { row: 1, col: 1 }, { row: 1, col: 2 }, { row: 1, col: 3 }, { row: 1, col: 4 }, { row: 1, col: 5 }, { row: 1, col: 6 }, { row: 1, col: 7 },
                { row: 2, col: 0 }, { row: 2, col: 1 }, { row: 2, col: 2 }, { row: 2, col: 3 }, { row: 2, col: 4 }, { row: 2, col: 5 }, { row: 2, col: 6 }, { row: 2, col: 7 }, { row: 2, col: 8 }, { row: 2, col: 9 }, { row: 2, col: 10 }, { row: 2, col: 11 }, { row: 2, col: 12 }, { row: 2, col: 13 }, { row: 2, col: 14 }, { row: 2, col: 15 }
            ];
            var expectedSorts = [
                [{ queryName: "RowGroup1" }], [{ queryName: "RowGroup2" }], [{ queryName: "Measure1" }], [{ queryName: "Measure2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, "matrix", data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it("matrix with columnGroup url", function (done) {
            var data = matrixOneMeasureOneColumnGroupWithUrlOneGroupInstanceDataView;
            var renderTablixPromise = powerbitests.tablixHelper.renderNewTablix(element, {
                visualType: "matrix",
                data: data
            });
            renderTablixPromise.then(function () {
                var tableBody = $(".tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody");
                expect(tableBody).toBeInDOM();
                var cellInfo = powerbitests.tablixHelper.getTableCell(tableBody, { row: 0, col: 1 });
                var aTag = $("> div > a", cellInfo.clickTarget);
                expect(aTag.length).toBe(1);
                expect(aTag.text()).toBe("http://www.validurl.com");
                expect(aTag.attr("href")).toBe("http://www.validurl.com");
                expect(aTag.attr("title")).toBe("http://www.validurl.com");
                done();
            });
        });
        it("matrix with rowGroup url", function (done) {
            var data = matrixOneMeasureOneRowGroupUrlOneGroupInstanceDataView;
            var renderTablixPromise = powerbitests.tablixHelper.renderNewTablix(element, {
                visualType: "matrix",
                data: data
            });
            renderTablixPromise.then(function () {
                var tableBody = $(".tablixContainer > div.bi-tablix > div:nth-child(1) > table.unselectable > tbody");
                expect(tableBody).toBeInDOM();
                var cellInfo = powerbitests.tablixHelper.getTableCell(tableBody, { row: 1, col: 0 });
                var aTag = $("> div > a", cellInfo.clickTarget);
                expect(aTag.length).toBe(1);
                expect(aTag.text()).toBe("http://www.validurl.com");
                expect(aTag.attr("href")).toBe("http://www.validurl.com");
                expect(aTag.attr("title")).toBe("http://www.validurl.com");
                done();
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var MultiRowCard = powerbi.visuals.MultiRowCard;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    describe("MultiRowCard", function () {
        it("MultiRowCard_registered_capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("multiRowCard").capabilities).toBe(MultiRowCard.capabilities);
        });
        it("Capabilities should include dataViewMappings", function () {
            expect(MultiRowCard.capabilities.dataViewMappings).toBeDefined();
        });
        it("Capabilities should include dataRoles", function () {
            expect(MultiRowCard.capabilities.dataRoles).toBeDefined();
        });
        it("Capabilities should suppressDefaultTitle", function () {
            expect(MultiRowCard.capabilities.suppressDefaultTitle).toBe(true);
        });
        it("FormatString property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(MultiRowCard.capabilities.objects)).toEqual(MultiRowCard.formatStringProp);
        });
    });
    describe("MultiRowCard DOM tests", function () {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataTypeWebUrl = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text, "WebUrl");
        var dataViewMetadata = {
            columns: [
                { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }) },
                { displayName: "date", type: ValueType.fromDescriptor({ dateTime: true }) },
                { displayName: "category", type: ValueType.fromDescriptor({ text: true }) }
            ]
        };
        var dataViewMetadataWithURL = {
            columns: [
                { displayName: "category", type: ValueType.fromDescriptor({ text: true }) },
                { displayName: "URL", type: dataTypeWebUrl }
            ]
        };
        var dataViewMetadataWithURLTitle = {
            columns: [
                { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }) },
                { displayName: "URL", type: dataTypeWebUrl }
            ]
        };
        var data = {
            metadata: dataViewMetadata,
            table: {
                rows: [
                    [123456.789, new Date(1999, 7, 31, 6, 15), "category1"],
                    [12345, new Date(2014, 7, 1), "category2"]
                ],
                columns: dataViewMetadata.columns
            }
        };
        var dataViewMetadataWithTitle = {
            columns: [
                { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }), isMeasure: true },
                { displayName: "genre", type: ValueType.fromDescriptor({ text: true }) }
            ]
        };
        var dataWithTitle = {
            metadata: dataViewMetadataWithTitle,
            table: {
                rows: [
                    [123456.789, "Action"],
                    [12345, "Adventure"]
                ],
                columns: dataViewMetadataWithTitle.columns
            }
        };
        var dataWithNullValue = {
            metadata: dataViewMetadataWithTitle,
            table: {
                rows: [
                    [null, "Action"],
                    [null, "Adventure"]
                ],
                columns: dataViewMetadataWithTitle.columns
            }
        };
        var dataWithURLTitle = {
            metadata: dataViewMetadataWithURLTitle,
            table: {
                rows: [
                    [123456.789, "http://bing.com"],
                    [12345, "http://microsoft.com"]
                ],
                columns: dataViewMetadataWithURLTitle.columns
            }
        };
        var dataWithURLValues = {
            metadata: dataViewMetadataWithURL,
            table: {
                rows: [
                    ["category1", "http://bing.com"],
                    ["category2", "http://microsoft.com"]
                ],
                columns: dataViewMetadataWithURL.columns
            }
        };
        var dataViewPlainNumericMetadata = {
            columns: [
                { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }) }
            ]
        };
        var singleRowdata = {
            metadata: dataViewPlainNumericMetadata,
            table: {
                rows: [
                    [123456.789]
                ],
                columns: dataViewPlainNumericMetadata.columns
            }
        };
        var simpleDataView = {
            metadata: { columns: [], segment: {} },
            table: {
                rows: [[1]],
                columns: []
            }
        };
        beforeEach(function () {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("multiRowCard").create();
            v.init(getVisualInitOptions(element = powerbitests.helpers.testDom("200", "300")));
        });
        it("Validate multiRowCard DOM without Title", function (done) {
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .title")).not.toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect($(".card .cardItemContainer .caption")).toBeInDOM();
                expect($(".card .cardItemContainer .details")).toBeInDOM();
                expect($(".card").length).toBe(2);
                expect($(".card")[0].childElementCount).toBe(3);
                expect($(".cardItemContainer")[0].childElementCount).toBe(2);
                expect($(".caption").last().text()).toBe("category2");
                expect($(".details").last().text()).toBe("category");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard DOM with Title", function (done) {
            v.onDataChanged({ dataViews: [dataWithTitle] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect($(".card .cardItemContainer .caption")).toBeInDOM();
                expect($(".card .cardItemContainer .details")).toBeInDOM();
                expect($(".card .title")).toBeInDOM();
                expect($(".card").length).toBe(2);
                expect($(".card")[0].childElementCount).toBe(2);
                expect($(".cardItemContainer")[0].childElementCount).toBe(2);
                expect($(".title").last().height()).toBe(24);
                expect($(".title").last().text()).toBe("Adventure");
                expect($(".caption").last().text()).toBe("12,345.00");
                expect($(".details").last().text()).toBe("value");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate that multiRowCard item long caption should be truncated", function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: "Label", type: ValueType.fromDescriptor({ text: true }) },
                    { displayName: "Category", type: ValueType.fromDescriptor({ text: true }) }
                ]
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        ["this is the label that never ends, it just goes on and on my friends.Some axis started rendering it not knowing what it was, and now it keeps on rendering forever just because this the label that never ends...", "Category1"]
                    ],
                    columns: dataViewMetadata.columns
                }
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                // Note: the exact text will be different depending on the environment in which the test is run, so we can't do an exact match.
                // Just check that the text is truncated with ellipses.
                var labelText = $(".caption").first().text();
                expect(labelText.substr(labelText.length - 3)).toBe("...");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard converter without Title", function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(data, data.metadata.columns.length, data.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: undefined, showTitleAsURL: false, cardItemsData: [{ caption: "123,456.79", details: "value", showURL: false }, { caption: "8/31/1999", details: "date", showURL: false }, { caption: "category1", details: "category", showURL: false }] },
                    { title: undefined, showTitleAsURL: false, cardItemsData: [{ caption: "12,345.00", details: "value", showURL: false }, { caption: "8/1/2014", details: "date", showURL: false }, { caption: "category2", details: "category", showURL: false }] }
                ]);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard converter With Title", function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(dataWithTitle, dataWithTitle.metadata.columns.length, dataWithTitle.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: "Action", showTitleAsURL: false, cardItemsData: [{ caption: "123,456.79", details: "value", showURL: false }] },
                    { title: "Adventure", showTitleAsURL: false, cardItemsData: [{ caption: "12,345.00", details: "value", showURL: false }] }
                ]);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard converter null value", function (done) {
            setTimeout(function () {
                var cardData = MultiRowCard.converter(dataWithNullValue, dataWithNullValue.metadata.columns.length, dataWithNullValue.table.rows.length);
                expect(cardData.length).toBe(2);
                expect(cardData).toEqual([
                    { title: "Action", showTitleAsURL: false, cardItemsData: [{ caption: "(Blank)", details: "value", showURL: false }] },
                    { title: "Adventure", showTitleAsURL: false, cardItemsData: [{ caption: "(Blank)", details: "value", showURL: false }] }
                ]);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate that multiRowCard displays title with Empty values", function (done) {
            var dataWithEmptyTitle = {
                metadata: dataViewMetadataWithTitle,
                table: {
                    rows: [
                        [null, ""],
                        [null, "Adventure"]
                    ],
                    columns: dataViewMetadataWithTitle.columns
                }
            };
            v.onDataChanged({ dataViews: [dataWithEmptyTitle] });
            setTimeout(function () {
                expect($(".card .title")).toBeInDOM();
                expect($(".title").first().text()).toBe("");
                expect($(".title").last().text()).toBe("Adventure");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate that multiRowCard displays title with Web URL values", function (done) {
            v.onDataChanged({ dataViews: [dataWithURLTitle] });
            setTimeout(function () {
                expect($(".card .title a")).toBeInDOM();
                expect($(".title a").last().text()).toBe("http://microsoft.com");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate that multiRowCard displays card items with Web URL values", function (done) {
            v.onDataChanged({ dataViews: [dataWithURLValues] });
            setTimeout(function () {
                expect($(".card .caption a")).toBeInDOM();
                expect($(".caption a").last().text()).toBe("http://microsoft.com");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard last card styling on dashboard", function (done) {
            var options = getVisualInitOptions(element = powerbitests.helpers.testDom("400", "400"));
            options.interactivity = { overflow: "hidden" };
            v.init(options);
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find(".card").last().css("border-bottom-width"), 10);
                var cardItemBottomPadding = parseInt(element.find(".card").last().css("padding-bottom"), 10);
                var cardItemTopPadding = parseInt(element.find(".card").last().css("padding-top"), 10);
                expect(cardItemBottomBorderWidth).toEqual(0);
                expect(cardItemBottomPadding).toEqual(0);
                expect(cardItemTopPadding).toEqual(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard first card styling on canvas", function (done) {
            v.init(getVisualInitOptions(element = powerbitests.helpers.testDom("100", "100")));
            v.onDataChanged({ dataViews: [singleRowdata] });
            setTimeout(function () {
                var cardBottomMargin = parseInt(element.find(".card").last().css("margin-bottom"), 10);
                expect(cardBottomMargin).toEqual(0);
                v.onDataChanged({ dataViews: [dataWithTitle] });
                cardBottomMargin = parseInt(element.find(".card").last().css("margin-bottom"), 10);
                expect(cardBottomMargin).toEqual(20);
                v.onDataChanged({ dataViews: [data] });
                cardBottomMargin = parseInt(element.find(".card").last().css("margin-bottom"), 10);
                expect(cardBottomMargin).toEqual(20);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard card styling on dashboard", function (done) {
            var options = getVisualInitOptions(element = powerbitests.helpers.testDom("400", "400"));
            options.interactivity = { overflow: "hidden" };
            v.init(options);
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find(".card").first().css("border-bottom-width"), 10);
                var cardItemBottomPadding = parseInt(element.find(".card").first().css("padding-bottom"), 10);
                var cardItemTopPadding = parseInt(element.find(".card").first().css("padding-top"), 10);
                expect($(".card .title")).not.toBeInDOM();
                expect(cardItemBottomBorderWidth).toEqual(1);
                expect(cardItemBottomPadding).toEqual(5);
                expect(cardItemTopPadding).toEqual(5);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard card styling", function (done) {
            v.init(getVisualInitOptions(element = powerbitests.helpers.testDom("400", "400")));
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemBottomBorderWidth = parseInt(element.find(".card").first().css("border-bottom-width"), 10);
                var cardItemBottomPadding = parseInt(element.find(".card").first().css("padding-bottom"), 10);
                var cardItemTopPadding = parseInt(element.find(".card").first().css("padding-top"), 10);
                expect(cardItemBottomBorderWidth).toEqual(0);
                expect(cardItemBottomPadding).toEqual(0);
                expect(cardItemTopPadding).toEqual(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard styling when there is a single card item", function (done) {
            v.onDataChanged({ dataViews: [singleRowdata] });
            setTimeout(function () {
                var cardItemRightMargin = parseInt(element.find(".cardItemContainer").first().css("margin-right"), 10);
                expect(cardItemRightMargin).toEqual(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify number of cards and card items in smallTile ", function (done) {
            var options = getVisualInitOptions(powerbitests.helpers.testDom("150", "230"));
            options.interactivity = { overflow: "hidden" };
            v.init(options);
            v.onDataChanged({ dataViews: [powerbitests.tableDataViewHelper.getDataWithColumns(10, 10)] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect($(".card").length).toBe(1);
                expect($(".card")[0].childElementCount).toBe(4);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify number of cards and card items in MediumTile ", function (done) {
            var options = getVisualInitOptions(powerbitests.helpers.testDom("300", "470"));
            options.interactivity = { overflow: "hidden" };
            v.init(options);
            v.onDataChanged({ dataViews: [powerbitests.tableDataViewHelper.getDataWithColumns(10, 10)] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect($(".card").length).toBe(3);
                expect($(".card")[0].childElementCount).toBe(6);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Verify number of cards and card items in LargeTile ", function (done) {
            var options = getVisualInitOptions(powerbitests.helpers.testDom("450", "750"));
            options.interactivity = { overflow: "hidden" };
            v.init(options);
            v.onDataChanged({ dataViews: [powerbitests.tableDataViewHelper.getDataWithColumns(10, 10)] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect($(".card").length).toBe(9);
                expect($(".card")[0].childElementCount).toBe(6);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard cardrow column width for default width", function (done) {
            v.init(getVisualInitOptions(element = powerbitests.helpers.testDom("100", "760")));
            v.onDataChanged({ dataViews: [powerbitests.tableDataViewHelper.getDataWithColumns(15, 15)] });
            setTimeout(function () {
                expect($(".card")).toBeInDOM();
                expect($(".card .cardItemContainer")).toBeInDOM();
                expect(element.find(".cardItemContainer").last().innerWidth()).toEqual(86);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate multiRowCard card height", function (done) {
            v.init(getVisualInitOptions(element = powerbitests.helpers.testDom("400", "400")));
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                var cardItemHeight = element.find(".cardItemContainer").height();
                var cardItemBottompadding = parseInt(element.find(".card").css("padding-bottom"), 10);
                var cardItemTopPadding = parseInt(element.find(".card").css("padding-bottom"), 10);
                expect(element.find(".card").first().innerHeight()).toEqual(cardItemHeight + cardItemBottompadding + cardItemTopPadding);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Card should be cleared when there is a empty dataview ", function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }) }
                ]
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [123456.789]
                    ],
                    columns: dataViewMetadata.columns
                }
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($(".card").length).toBe(1);
                dataViewMetadata = {
                    columns: []
                };
                data = {
                    metadata: dataViewMetadata,
                    table: {
                        rows: [],
                        columns: dataViewMetadata.columns
                    }
                };
                v.onDataChanged({ dataViews: [data] });
                expect($(".card").length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Card should format values", function (done) {
            var dataViewMetadata = {
                columns: [
                    { displayName: "value", type: ValueType.fromDescriptor({ numeric: true }), objects: { general: { formatString: "0%" } } }
                ]
            };
            var data = {
                metadata: dataViewMetadata,
                table: {
                    rows: [
                        [.22]
                    ],
                    columns: dataViewMetadata.columns
                }
            };
            v.onDataChanged({ dataViews: [data] });
            setTimeout(function () {
                expect($(".card").length).toBe(1);
                expect($(".card .caption").last().text()).toBe("22%");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Card should not call loadMoreData ", function () {
            var data = {
                metadata: { columns: [] },
                table: { rows: [[1]], columns: [] }
            };
            v.onDataChanged({ dataViews: [data] });
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).not.toHaveBeenCalled();
        });
        it("Card should call loadMoreData ", function () {
            v.onDataChanged({ dataViews: [simpleDataView] });
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).toHaveBeenCalled();
        });
        it("Card already called loadMoreData", function () {
            v.onDataChanged({ dataViews: [simpleDataView] });
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            listViewOptions.loadMoreData();
            expect(loadMoreSpy.calls.all().length).toBe(1);
        });
        function getVisualInitOptions(element) {
            return {
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            };
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var RichTextbox = powerbi.visuals.RichTextbox;
    describe('Rich Textbox', function () {
        var viewport = {
            height: 500,
            width: 500,
        };
        var style = powerbi.visuals.visualStyles.create();
        describe('capabilities', function () {
            it('should suppress title', function () {
                expect(RichTextbox.capabilities.suppressDefaultTitle).toBeTruthy();
            });
            it('should register capabilities', function () {
                var pluginFactory = powerbi.visuals.visualPluginFactory.create();
                var plugin = pluginFactory.getPlugin('textbox');
                expect(plugin).toBeDefined();
                expect(plugin.capabilities).toBe(RichTextbox.capabilities);
            });
        });
        // Chutzpah is configured to load the quill resources for these tests.
        powerbi.visuals.RichText.QuillWrapper.loadQuillResources = false;
        // ---- Sample data ----
        // 2 paragraphs, no formatting.
        var paragraphs1 = [
            {
                textRuns: [
                    { value: 'foo' },
                    { value: 'bar' },
                ]
            },
            {
                textRuns: [
                    { value: 'baz' }
                ]
            }
        ];
        // 2 paragraphs, with formatting
        var paragraphs2 = [
            {
                textRuns: [
                    { value: 'foo', textStyle: { fontWeight: 'bold' } },
                    { value: 'bar', textStyle: { fontStyle: 'italic' } },
                    { value: 'baz', textStyle: { textDecoration: 'underline' } },
                ]
            },
            {
                textRuns: [
                    { value: 'http://www.powerbi.com', url: 'http://www.powerbi.com' }
                ],
                horizontalTextAlignment: 'center'
            }
        ];
        // 1 paragraph with an unformatted url.
        var paragraphs3 = [
            {
                textRuns: [
                    { value: 'http://www.powerbi.com' },
                ]
            }
        ];
        describe('', function () {
            var host;
            var $element;
            var $toolbar;
            var initOptions;
            var textbox;
            var getViewModeSpy;
            var setToolbarSpy;
            beforeEach(function () {
                host = powerbitests.mocks.createVisualHostServices();
                $element = powerbitests.helpers.testDom('500', '500');
                initOptions = {
                    element: $element,
                    host: host,
                    viewport: viewport,
                    style: style,
                };
                getViewModeSpy = spyOn(host, 'getViewMode');
                setToolbarSpy = spyOn(host, 'setToolbar');
                setToolbarSpy.and.callFake(function (t) { return $toolbar = t; });
            });
            describe('init in view mode', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(0 /* View */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('should not show editor', function () {
                    verifyEditor($element, false);
                });
                it('change to edit-mode should show editor', function () {
                    switchToViewMode(1 /* Edit */);
                    verifyEditor($element, true);
                });
                describe('on data changed', function () {
                    it('with non-empty dataview should set content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        expect($paragraph1.text()).toEqual('foobar');
                        var $paragraph2 = $divs.eq(1);
                        expect($paragraph2.text()).toEqual('baz');
                    });
                    it('with empty dataview should clear content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        // Clear the content.
                        textbox.onDataChanged({ dataViews: [] });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.text()).toEqual('');
                    });
                    it('with formatted text should render correctly', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                        var $divs = getViewModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        var $paragraph1Spans = $paragraph1.children();
                        expect($paragraph1Spans.length).toBe(3);
                        var $fooRun = $paragraph1Spans.eq(0);
                        expect(hasBold($fooRun)).toBeTruthy();
                        var $barRun = $paragraph1Spans.eq(1);
                        expect(hasItalic($barRun)).toBeTruthy();
                        var $bazRun = $paragraph1Spans.eq(2);
                        expect(hasUnderline($bazRun)).toBeTruthy();
                        var $paragraph2 = $divs.eq(1);
                        var $paragraph2Spans = $paragraph2.children();
                        expect($paragraph2Spans.length).toBe(1);
                        var $urlRun = $paragraph2Spans.eq(0);
                        expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                    });
                    describe('theme font', function () {
                        it('"Heading" should render correctly', function () {
                            var paragraphsWithHeading = [
                                {
                                    textRuns: [
                                        { value: 'Some text', textStyle: { fontFamily: 'Heading' } },
                                    ]
                                }
                            ];
                            textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphsWithHeading) });
                            var $divs = getViewModeParagraphDivs($element);
                            var $span = $divs.children('span').eq(0);
                            expect(getFont($span)).toEqual('wf_segoe-ui_light');
                        });
                        it('"Body" should render correctly', function () {
                            var paragraphsWithBody = [
                                {
                                    textRuns: [
                                        { value: 'Some text', textStyle: { fontFamily: 'Body' } },
                                    ]
                                }
                            ];
                            textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphsWithBody) });
                            var $divs = getViewModeParagraphDivs($element);
                            var $span = $divs.children('span').eq(0);
                            expect(getFont($span)).toEqual('wf_segoe-ui_normal');
                        });
                    });
                });
            });
            describe('init in edit mode', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(1 /* Edit */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('should show editor', function () {
                    verifyEditor($element, true);
                });
                it('should register the toolbar', function () {
                    expect($toolbar).toBeDefined();
                });
                it('change to view-mode should unregister the toolbar', function () {
                    switchToViewMode(0 /* View */);
                    expect($toolbar).toBeNull();
                });
                it('focus should be in the editor', function () {
                    var editor = $element.find('.ql-editor');
                    expect(document.activeElement).toBe(editor.get(0));
                });
                it('editor should be full size', function () {
                    var container = $element.find('.ql-container').parent();
                    expect(container.outerWidth()).toBe(500);
                    expect(container.outerHeight()).toBe(500);
                });
                it('change to view-mode should not show editor', function () {
                    switchToViewMode(0 /* View */);
                    verifyEditor($element, false);
                });
                it('change to view-mode should format any urls', function () {
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs3) });
                    switchToViewMode(0 /* View */);
                    var $divs = getViewModeParagraphDivs($element);
                    var $urlRun = $divs.children('span').eq(0);
                    expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                });
                it('change to view-mode should save content', function () {
                    var changes = [];
                    spyOn(host, 'persistProperties').and.callFake(function (c) { return changes = c; });
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                    switchToViewMode(0 /* View */);
                    expect(changes).toHaveLength(1);
                    var change = changes[0];
                    expect(change.objectName).toEqual('general');
                    var paragraphs = change.properties.paragraphs;
                    expect(paragraphs.length).toBe(2);
                    expect(paragraphs[0].horizontalTextAlignment).toBeFalsy();
                    expect(paragraphs[0].textRuns.length).toBe(3);
                    expect(paragraphs[0].textRuns[0].value).toBe('foo');
                    expect(paragraphs[0].textRuns[0].textStyle).toEqual({ fontWeight: 'bold' });
                    expect(paragraphs[0].textRuns[0].url).toBeFalsy();
                    expect(paragraphs[0].textRuns[1].value).toBe('bar');
                    expect(paragraphs[0].textRuns[1].textStyle).toEqual({ fontStyle: 'italic' });
                    expect(paragraphs[0].textRuns[1].url).toBeFalsy();
                    expect(paragraphs[0].textRuns[2].value).toBe('baz');
                    expect(paragraphs[0].textRuns[2].textStyle).toEqual({ textDecoration: 'underline' });
                    expect(paragraphs[0].textRuns[2].url).toBeFalsy();
                    expect(paragraphs[1].horizontalTextAlignment).toEqual('center');
                    expect(paragraphs[1].textRuns[0].value).toBe('http://www.powerbi.com');
                    expect(paragraphs[1].textRuns[0].textStyle).toEqual({});
                    expect(paragraphs[1].textRuns[0].url).toEqual('http://www.powerbi.com');
                });
                it('change to view-mode should preserve empty lines', function () {
                    var paragraphs = [
                        {
                            textRuns: [
                                { value: 'line 1' },
                            ]
                        }, {
                            textRuns: [
                                { value: '' },
                            ]
                        }, {
                            textRuns: [
                                { value: 'line 2' },
                            ]
                        }
                    ];
                    textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs) });
                    switchToViewMode(0 /* View */);
                    var $divs = getViewModeParagraphDivs($element);
                    expect($divs.length).toBe(3);
                    expect($divs.eq(0).text()).toEqual('line 1');
                    expect($divs.eq(1).text()).toEqual('');
                    expect($divs.eq(2).text()).toEqual('line 2');
                });
                it('keyboard shortcuts are prevented from bubbling', function () {
                    var $editor = getEditor($element);
                    var keydown = false;
                    $element.on('keydown', function (e) {
                        keydown = true;
                    });
                    // verify that some keys do bubble.
                    var event = $.Event('keydown');
                    event.ctrlKey = true;
                    event.which = 83; // S
                    $editor.trigger(event);
                    expect(keydown).toBeTruthy();
                    // verify that prevented keys do not bubble.
                    keydown = false;
                    for (var _i = 0, _a = powerbi.visuals.RichText.QuillWrapper.preventDefaultKeys; _i < _a.length; _i++) {
                        var key = _a[_i];
                        var event_1 = $.Event('keydown');
                        event_1.ctrlKey = true;
                        event_1.which = key;
                        $editor.trigger(event_1);
                        expect(keydown).toBeFalsy();
                    }
                });
                describe('on data changed', function () {
                    it('with non-empty dataview should set content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        var $divs = getEditModeParagraphDivs($element);
                        var $paragraph1 = $divs.eq(0);
                        expect($paragraph1.text()).toEqual('foobar');
                        var $paragraph2 = $divs.eq(1);
                        expect($paragraph2.text()).toBe('baz');
                    });
                    it('with empty dataview should clear content', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        // Clear the content.
                        textbox.onDataChanged({ dataViews: [] });
                        var $divs = getEditModeParagraphDivs($element);
                        expect($divs.text()).toEqual('');
                    });
                    it('with formatted text should render correctly', function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs2) });
                        var $divs = getEditModeParagraphDivs($element);
                        expect($divs.length).toBe(2);
                        var $paragraph1 = $divs.eq(0);
                        var $paragraph1Spans = $paragraph1.children();
                        expect($paragraph1Spans.length).toBe(3);
                        var $fooRun = $paragraph1Spans.eq(0);
                        expect(hasBold($fooRun)).toBeTruthy();
                        var $barRun = $paragraph1Spans.eq(1);
                        expect(hasItalic($barRun)).toBeTruthy();
                        var $bazRun = $paragraph1Spans.eq(2);
                        expect(hasUnderline($bazRun)).toBeTruthy();
                        var $paragraph2 = $divs.eq(1);
                        var $urlRun = $paragraph2;
                        expect(getUrl($urlRun)).toEqual('http://www.powerbi.com');
                    });
                });
            });
            describe('', function () {
                beforeEach(function () {
                    getViewModeSpy.and.returnValue(1 /* Edit */);
                    textbox = new RichTextbox();
                    textbox.init(initOptions);
                });
                it('toolbar should exist with formatting options', function () {
                    var $toolbar = getToolbar();
                    expect($toolbar).toBeDefined();
                    expect(boldButton($toolbar)).toBeDefined();
                    expect(italicButton($toolbar)).toBeDefined();
                    expect(underlineButton($toolbar)).toBeDefined();
                    expect(fontSelect($toolbar)).toBeDefined();
                    expect(fontSizeSelect($toolbar)).toBeDefined();
                    expect(textAlignmentSelect($toolbar)).toBeDefined();
                });
                describe('with selected text', function () {
                    beforeEach(function () {
                        textbox.onDataChanged({ dataViews: buildParagraphsDataView(paragraphs1) });
                        textbox.setSelection(0, 5);
                    });
                    describe('clicking bold', function () {
                        beforeEach(function () {
                            boldButton(getToolbar()).click();
                        });
                        it('should bold selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasBold($spans.eq(0))).toBeTruthy();
                        });
                        it('should bold text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasBold($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('clicking italic', function () {
                        beforeEach(function () {
                            italicButton(getToolbar()).click();
                        });
                        it('should italicize selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasItalic($spans.eq(0))).toBeTruthy();
                        });
                        it('should italicize text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasItalic($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('clicking underline', function () {
                        beforeEach(function () {
                            underlineButton(getToolbar()).click();
                        });
                        it('should underline selection in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasUnderline($spans.eq(0))).toBeTruthy();
                        });
                        it('should underline text in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(hasUnderline($spans.eq(0))).toBeTruthy();
                        });
                    });
                    describe('changing font', function () {
                        var fontFace = 'Symbol';
                        beforeEach(function () {
                            setSelectValue(fontSelect(getToolbar()), fontFace);
                        });
                        it('should change font in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                            expect(getSelectText(fontSelect(getToolbar()))).toEqual(fontFace);
                        });
                        it('should change font in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                        });
                    });
                    describe('changing font (embedded)', function () {
                        var fontFace = 'wf_segoe-ui_normal';
                        beforeEach(function () {
                            setSelectValue(fontSelect(getToolbar()), fontFace);
                        });
                        it('should change font in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                            expect(getSelectText(fontSelect(getToolbar()))).toEqual('Segoe UI');
                        });
                        it('should change font in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFont($spans.eq(0))).toEqual(fontFace);
                        });
                    });
                    describe('changing font size', function () {
                        var fontSize = '24px';
                        beforeEach(function () {
                            setSelectValue(fontSizeSelect(getToolbar()), fontSize);
                        });
                        it('should change font size in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFontSize($spans.eq(0))).toEqual(fontSize);
                            expect(getSelectText(fontSizeSelect(getToolbar()))).toEqual('24');
                        });
                        it('should change font size in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            expect($paragraph1.text()).toBe('foobar');
                            var $spans = $paragraph1.children();
                            expect($spans.length).toBeGreaterThan(0);
                            expect($spans.eq(0).text()).toEqual('fooba');
                            expect(getFontSize($spans.eq(0))).toEqual(fontSize);
                        });
                    });
                    describe('changing text alignment', function () {
                        var alignment = 'center';
                        beforeEach(function () {
                            setSelectValue(textAlignmentSelect(getToolbar()), alignment);
                        });
                        it('should change text alignment in editor', function () {
                            var $divs = getEditModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            // NOTE: Changes alignment for the entire paragraph.
                            expect($paragraph1.text()).toEqual('foobar');
                            expect(getTextAlignment($paragraph1)).toEqual(alignment);
                            expect(getSelectText(textAlignmentSelect(getToolbar()))).toEqual('Center');
                        });
                        it('should change text alignment in view-mode', function () {
                            switchToViewMode(0 /* View */);
                            var $divs = getViewModeParagraphDivs($element);
                            var $paragraph1 = $divs.eq(0);
                            // NOTE: Changes alignment for the entire paragraph.
                            expect($paragraph1.text()).toEqual('foobar');
                            expect(getTextAlignment($paragraph1)).toEqual(alignment);
                        });
                    });
                });
                function getToolbar() {
                    return $toolbar;
                }
                function boldButton($toolbar) {
                    return $toolbar.find('.ql-bold');
                }
                function italicButton($toolbar) {
                    return $toolbar.find('.ql-italic');
                }
                function underlineButton($toolbar) {
                    return $toolbar.find('.ql-underline');
                }
                function fontSelect($toolbar) {
                    return $toolbar.find('.ql-font');
                }
                function fontSizeSelect($toolbar) {
                    return $toolbar.find('.ql-size');
                }
                function textAlignmentSelect($toolbar) {
                    return $toolbar.find('.ql-align');
                }
                function setSelectValue($select, value) {
                    // See powerbi.visuals.RichText.Toolbar.setSelectValue() for description.
                    // NOTE: For unit tests case we have to use document.createEvent() because PhantomJS does
                    // not appear to support new UIEvent (https://github.com/ariya/phantomjs/issues/11289).
                    $select.val(value);
                    var evt = document.createEvent('UIEvent');
                    evt.initUIEvent('change', false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                function getSelectText($select) {
                    return $select.children('option:selected').text();
                }
            });
            function switchToViewMode(viewMode) {
                getViewModeSpy.and.returnValue(viewMode);
                textbox.onViewModeChanged(viewMode);
            }
            function getEditor($element) {
                return $element.find('.ql-editor');
            }
            function verifyEditor($element, present) {
                expect($element).toHaveClass('richtextbox');
                if (present) {
                    var $container = $element.children('div').eq(0);
                    expect($container).toBeDefined();
                    expect(setToolbarSpy).toHaveBeenCalled();
                    expect($toolbar).toBeDefined();
                    expect($toolbar.hasClass('ql-toolbar')).toBeTruthy();
                    var $editorContainer = $container.find('.ql-container');
                    expect($editorContainer.length).toBe(1);
                    var $editor = getEditor($editorContainer);
                    expect($editor.length).toBe(1);
                }
                else {
                    expect(getEditor($element).length).toBe(0);
                }
            }
        });
        function getTagName($element) {
            return $element.get(0).tagName.toLowerCase();
        }
        function hasBold($element) {
            return getTagName($element) === 'b' || $element.css('font-weight') === 'bold';
        }
        function hasItalic($element) {
            return getTagName($element) === 'i' || $element.css('font-style') === 'italic';
        }
        function hasUnderline($element) {
            return getTagName($element) === 'u' || $element.css('text-decoration') === 'underline';
        }
        function getUrl($element) {
            var $anchor = (getTagName($element) === 'a') ? $element : $element.find('a');
            return $anchor.attr('href');
        }
        function getFont($element) {
            return $element.css('font-family');
        }
        function getFontSize($element) {
            return $element.css('font-size');
        }
        function getTextAlignment($element) {
            return $element.css('text-align');
        }
        function buildParagraphsDataView(paragraphs) {
            return [{ metadata: { columns: [], objects: { general: { paragraphs: paragraphs } } } }];
        }
        function getViewModeParagraphDivs($element) {
            return $element.children('div');
        }
        function getEditModeParagraphDivs($element) {
            var $editor = $element.find('.ql-editor');
            expect($editor.length).toBe(1);
            return $editor.children('div');
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ScatterChart = powerbi.visuals.ScatterChart;
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var DataViewPivotCategorical = powerbi.data.DataViewPivotCategorical;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ColorUtility = powerbitests.utils.ColorUtility;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var AxisType = powerbi.axisType;
    powerbitests.mocks.setLocale();
    var axisLabelVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightAxesVisible;
    var axisLabelVisibleGreaterThanMinHeight = axisLabelVisibleMinHeight + 1;
    var axisLabelVisibleSmallerThanMinHeight = axisLabelVisibleMinHeight - 1;
    var axisLabelVisibleGreaterThanMinHeightString = axisLabelVisibleGreaterThanMinHeight.toString();
    var axisLabelVisibleSmallerThanMinHeightString = axisLabelVisibleSmallerThanMinHeight.toString();
    var legendVisibleMinHeight = powerbi.visuals.visualPluginFactory.MobileVisualPluginService.MinHeightLegendVisible;
    var legendVisibleGreaterThanMinHeight = legendVisibleMinHeight + 1;
    var legendVisibleSmallerThanMinHeight = legendVisibleMinHeight - 1;
    var legendVisibleGreaterThanMinHeightString = legendVisibleGreaterThanMinHeight.toString();
    var legendVisibleSmallerThanMinHeightString = legendVisibleSmallerThanMinHeight.toString();
    var labelColor = powerbi.visuals.dataLabelUtils.defaultLabelColor;
    describe("ScatterChart", function () {
        var categoryColumn = { displayName: 'year', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
        var measureColumn = { displayName: 'sales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        it('ScatterChart registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').capabilities).toBe(powerbi.visuals.scatterChartCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.scatterChartCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.scatterChartCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should not suppressDefaultTitle', function () {
            expect(powerbi.visuals.scatterChartCapabilities.suppressDefaultTitle).toBeUndefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.scatterChartCapabilities.objects)).toEqual(powerbi.visuals.scatterChartProps.general.formatString);
        });
        it('preferred capability does not support zero rows', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: categoryColumn,
                            values: []
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            values: []
                        }]),
                }
            };
            expect(powerbi.DataViewAnalysis.supports(dataView, powerbi.visuals.scatterChartCapabilities.dataViewMappings[0], true))
                .toBe(false);
        });
        it('preferred capability does not support one row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: categoryColumn,
                            values: [2012, 2013]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            values: [200]
                        }]),
                }
            };
            expect(powerbi.DataViewAnalysis.supports(dataView, powerbi.visuals.scatterChartCapabilities.dataViewMappings[0], true))
                .toBe(false);
        });
    });
    function scatterChartDomValidation(interactiveChart) {
        var v, element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
            ]
        };
        var dataViewMetadata = {
            columns: [
                { displayName: 'col1', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'col2', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }],
        };
        var hostServices;
        beforeEach(function () {
            hostServices = powerbitests.mocks.createVisualHostServices();
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: interactiveChart },
            });
        });
        function getOptionsForValueWarnings(values) {
            var options = {
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: values,
                                    subtotal: 2465000
                                }])
                        }
                    }]
            };
            return options;
        }
        it('NaN in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, NaN, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Negative Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, Number.NEGATIVE_INFINITY, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Positive Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, Number.POSITIVE_INFINITY, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Out of range value in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, 1e301, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('ValuesOutOfRange');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('All okay in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var options = getOptionsForValueWarnings([500000, 495000, 490000, 480000, 500000]);
            v.onDataChanged(options);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart single measure dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 2465000
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('480K');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart two measure dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, objects: { general: { formatString: '0%' } } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120, 130, 140, 150]
                                }, {
                                    source: metadata.columns[2],
                                    values: [.21, .22, .23, .24, .25]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('110');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('21%');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
                expect($('.scatterChart .mainGraphicsContext .dot')[0].style.fillOpacity).toBe("0");
                expect($('.scatterChart .mainGraphicsContext .dot')[0].style.strokeOpacity).toBe("0.85");
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe('6');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart series dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, objects: { general: { formatString: '0%' } } },
                    { displayName: 'col4', isMeasure: true },
                ]
            };
            v.onDataChanged({
                dataViews: [DataViewPivotCategorical.apply({
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ]
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210, 220]
                                }, {
                                    source: metadata.columns[3],
                                    values: [310, 320]
                                }])
                        }
                    })]
            });
            var legendClassSelector = interactiveChart ? ".interactive-legend" : '.legend';
            var itemsNumber = interactiveChart ? 3 : 2;
            setTimeout(function () {
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(2);
                var length = $(legendClassSelector + (interactiveChart ? ' .item' : 'Text')).length;
                expect($(legendClassSelector).length).toBe(1);
                expect(length).toBe(itemsNumber);
                if (!interactiveChart)
                    expect($('.legendTitle').text()).toBe('col1');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart measure and size dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120, 130, 140, 150]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210, 220, 230, 240, 250]
                                }, {
                                    source: metadata.columns[3],
                                    values: [310, 320, 330, 340, 350]
                                }])
                        }
                    }]
            });
            var r = interactiveChart ? 45 : 51.5; // interactive legend is bigger
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('110');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('210');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r, -0.31);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart gridline dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [50000, 49500, 49000, 48000, 50000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis.showLinesOnAxis').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis.showLinesOnAxis').length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart single category value dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a'],
                                    identity: [powerbitests.mocks.dataViewScopeIdentity('a')],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210]
                                }, {
                                    source: metadata.columns[3],
                                    values: [310]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('80');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('140');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('200');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('400');
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(1);
                var r = (interactiveChart ? 45 : 51.5).toString();
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe(r);
                expect($('.legendItem').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart no category dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: null,
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[0],
                                    values: [110]
                                }, {
                                    source: metadata.columns[1],
                                    values: [210]
                                }, {
                                    source: metadata.columns[2],
                                    values: [310]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBe(3);
                expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(1);
                var r = (interactiveChart ? 45 : 51.5).toString(); // interactive legend is bigger
                expect($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r')).toBe(r);
                expect($('.scatterChart .mainGraphicsContext .dot').find('title').first().text()).toBe('');
                expect($('.legendItem').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('empty scatter chart dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: []
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: []
                                }
                            ])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('ensure scatter chart is cleared when an empty dataview is applied', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [50000, 49500, 49000, 48000, 50000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var scatterCount = $('.scatterChart').find('.dot').length;
                expect(scatterCount).toBe(5);
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadata,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: []
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadata.columns[1],
                                        values: [],
                                        subtotal: 0
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    var scatterCount = $('.scatterChart').find('.dot').length;
                    expect(scatterCount).toBe(0);
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart with small interval dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1.2, 2.3, 1.8, 3.7, 2.6]
                                }
                            ])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('2.50');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('2.50');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart nested svg dom validation', function () {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [5, 20, 15, 10, 25]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.5, 2.0, 1.5, 1.0, 2.5]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1.2, 2.3, 1.8, 3.7, 2.6]
                                }
                            ])
                        }
                    }]
            });
            expect($('.scatterChart .mainGraphicsContext .dot').length).toBe(5);
            expect($('.scatterChart .mainGraphicsContext').find('svg')).toBeDefined();
        });
        it('scatter chart does not show less ticks dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [32, 45]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [26.125, 26.125]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [3, 5]
                                }
                            ])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('30');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels dom validation', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'X-Axis', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'Size', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'Y-Axis', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120, 130, 140, 150]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210, 220, 230, 240, 250]
                                }, {
                                    source: metadata.columns[3],
                                    values: [310, 320, 330, 340, 350]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').text()).toBe('X-Axis');
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').text()).toBe('Y-Axis');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart on small tile shows at least two tick lines dom validation', function (done) {
            v.onResizing({
                height: 101,
                width: 226
            });
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [3, 5, 7]
                                }
                            ])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').first().text()).toBe('0.15');
                expect($('.scatterChart .axisGraphicsContext .y.axis .tick').find('text').last().text()).toBe('0.16');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').length).toBeGreaterThan(1);
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').first().text()).toBe('0.15');
                expect($('.scatterChart .axisGraphicsContext .x.axis .tick').find('text').last().text()).toBe('0.16');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart onResize big tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [3, 15, 27],
                                    min: 0,
                                    max: 30
                                }
                            ])
                        }
                    }]
            });
            v.onResizing({
                height: 500,
                width: 500
            });
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 42.5;
                r1 = 32.5;
                r2 = 18;
            }
            else {
                r0 = 49;
                r1 = 37.5;
                r2 = 20.5;
            }
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart onResize medium tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [3, 15, 27],
                                    min: 0,
                                    max: 30
                                }
                            ])
                        }
                    }]
            });
            v.onResizing({
                height: 300,
                width: 300
            });
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 23;
                r1 = 17.5;
                r2 = 9.5;
            }
            else {
                r0 = 29.5;
                r1 = 22.5;
                r2 = 12.5;
            }
            ;
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart onResize small tile radius dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [0.1495, 0.15, 0.1633]
                                },
                                {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [3, 15, 27],
                                    min: 0,
                                    max: 30
                                }
                            ])
                        }
                    }]
            });
            v.onResizing({
                height: 100,
                width: 200
            });
            var r0, r1, r2;
            if (interactiveChart) {
                r0 = 3.5;
                r1 = 2.5;
                r2 = 1.5;
            }
            else {
                r0 = 10;
                r1 = 7.5;
                r2 = 4;
            }
            setTimeout(function () {
                var expectedR0 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[0].getAttribute('r'));
                expect(expectedR0).toBeCloseTo(r0, -0.31);
                var expectedR1 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[1].getAttribute('r'));
                expect(expectedR1).toBeCloseTo(r1, -0.31);
                var expectedR2 = parseFloat($('.scatterChart .mainGraphicsContext .dot')[2].getAttribute('r'));
                expect(expectedR2).toBeCloseTo(r2, -0.31);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart zero axis line is darkened', function (done) {
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'X-Axis', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'Size', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'Y-Axis', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120, -130, 140, 150]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210, -220, -230, 240, -250]
                                }, {
                                    source: metadata.columns[3],
                                    values: [-310, 320, 330, -340, 350]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var zeroTicks = $('g.tick:has(line.zero-line)');
                expect(zeroTicks.length).toBe(2);
                zeroTicks.each(function (i, item) {
                    expect(d3.select(item).datum() === 0).toBe(true);
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("scatterChart DOM validation", function () { return scatterChartDomValidation(false); });
    describe("interactive scatterChart DOM validation", function () { return scatterChartDomValidation(true); });
    //Data Labels
    function scatterChartDataLabelsValidation(interactiveChart) {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    isMeasure: false,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),
                    format: 'd'
                }],
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        var dataViewMetadataWithLabelsOnObject = powerbi.Prototype.inherit(dataViewMetadata);
        dataViewMetadataWithLabelsOnObject.objects = { categoryLabels: { show: true }, labels: { show: true, labelPrecision: 0 } };
        var dataViewMetadataWithLabelsOffObject = powerbi.Prototype.inherit(dataViewMetadata);
        dataViewMetadataWithLabelsOffObject.objects = { categoryLabels: { show: false } };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: interactiveChart },
            });
        });
        it('scatter chart show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsOnObject.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsOnObject.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBeGreaterThan(0);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('a');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart labels style validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsOnObject.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsOnObject.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var labelFill = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().css('fill');
                expect(ColorUtility.convertFromRGBorHexToHex(labelFill)).toBe(labelColor);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart labels custom style validation', function (done) {
            var color = { solid: { color: "rgb(255, 0, 0)" } }; // Red
            var dataViewMetadataWithLabelsFillObject = powerbi.Prototype.inherit(dataViewMetadata);
            dataViewMetadataWithLabelsFillObject.objects = { categoryLabels: { show: true, color: color }, labels: { show: true, labelPrecision: 0 } };
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsFillObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataWithLabelsFillObject.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsFillObject.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var fill = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().css('fill');
                expect(ColorUtility.convertFromRGBorHexToHex(fill).toUpperCase()).toBe('#FF0000');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart hide labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOffObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsOffObject.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 246500
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart data labels multi-series', function (done) {
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: {
                    categoryLabels: { show: true },
                    // Force axis ranges to ensure data labels are visible
                    valueAxis: { start: 0, end: 100 },
                    categoryAxis: { start: -100, end: 300 },
                },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: seriesValues,
                                    identity: seriesIdentities,
                                    identityFields: [seriesIdentityField],
                                }],
                            values: valueColumns
                        }
                    }]
            });
            setTimeout(function () {
                var labels = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels');
                var dots = $('.scatterChart .axisGraphicsContext .mainGraphicsContext .dot');
                expect(dots.length).toBe(labels.length);
                for (var i = 0; i < dots.length; i++) {
                    var labelFill = labels.eq(i).css('fill');
                    expect(labelColor).toBe(ColorUtility.convertFromRGBorHexToHex(labelFill));
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart interactiveLenged of data labels multi-series without categories should not be null', function (done) {
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: {
                    categoryLabels: { show: true },
                    // Force axis ranges to ensure data labels are visible
                    valueAxis: { start: 0, end: 100 },
                    categoryAxis: { start: -100, end: 300 },
                },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            values: valueColumns
                        }
                    }]
            });
            setTimeout(function () {
                var interactiveLenged = $('.scatterChart .interactive-legend');
                var title = interactiveLenged.children('.title').children('span').last().text();
                if (interactiveChart) {
                    expect(title).toBe('a');
                }
                else {
                    expect(interactiveLenged.length).toBe(0);
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart with nulls dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [null, 10, null, 15, null],
                                    subtotal: 20
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(2);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('change scatter chart dom data label validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadataWithLabelsOnObject.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('a');
                v.onDataChanged({
                    dataViews: [{
                            metadata: dataViewMetadataWithLabelsOnObject,
                            categorical: {
                                categories: [{
                                        source: dataViewMetadata.columns[0],
                                        values: ['q', 'w', 'r', 't']
                                    }],
                                values: DataViewTransform.createValueColumns([{
                                        source: dataViewMetadataWithLabelsOnObject.columns[1],
                                        values: [400, 500, 300, 200],
                                    }])
                            }
                        }]
                });
                setTimeout(function () {
                    expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                    expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('q');
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        //empty dom
        it('empty scatter chart dom data labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: []
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: []
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        //One point
        it('scatter chart with single point dom data label validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataWithLabelsOnObject,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [4]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').text()).toBe('a');
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    }
    describe("scatterChart Data Labels validation", function () { return scatterChartDataLabelsValidation(false); });
    describe("interactive scatterChart Data Labels validation", function () { return scatterChartDataLabelsValidation(true); });
    describe("scatterChart bubble radius validation", function () {
        it('scatter chart getBubblePixelAreaSizeRange validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var bubblePixelArea = ScatterChart.getBubblePixelAreaSizeRange(viewport, 100, 200);
            expect(bubblePixelArea.minRange).toBe(278);
            expect(bubblePixelArea.maxRange).toBe(556);
            expect(bubblePixelArea.delta).toBe(278);
        });
        it('scatter chart projectSizeToPixel validation', function () {
            var element = powerbitests.helpers.testDom('500', '500');
            var v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: metadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: metadata.columns[1],
                                    values: [110, 120, 130, 140, 150]
                                }, {
                                    source: metadata.columns[2],
                                    values: [210, 220, 230, 240, 250]
                                }, {
                                    source: metadata.columns[3],
                                    values: [310, 320, 330, 340, 350]
                                }])
                        }
                    }]
            });
            var actualSizeDataRange = {
                minRange: 310,
                maxRange: 350,
                delta: 40
            };
            var bubblePixelAreaSizeRange = {
                minRange: 278,
                maxRange: 556,
                delta: 278
            };
            var projectedSize = ScatterChart.projectSizeToPixels(310, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(19);
            projectedSize = ScatterChart.projectSizeToPixels(320, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(21);
            projectedSize = ScatterChart.projectSizeToPixels(330, actualSizeDataRange, bubblePixelAreaSizeRange);
            expect(projectedSize).toBe(23);
        });
    });
    describe("scatterChart converter validation", function () {
        it('scatter chart dataView with role validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: seriesValues,
                            identity: seriesIdentities,
                        }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(0);
            expect(dataPoints[0].y).toBe(10);
            expect(dataPoints[0].fill).toBeDefined();
            expect(dataPoints[0].fill).not.toBe(dataPoints[1].fill);
            expect(scatterChartData.xCol).toBe(metadata.columns[1]);
            expect(scatterChartData.size).toBe(metadata.columns[2]);
            expect(scatterChartData.yCol).toBe(metadata.columns[3]);
            // No legend if we don't have a field in legend
            expect(scatterChartData.legendData.dataPoints.map(function (l) { return l.label; })).toEqual(['a', 'b', 'c']);
            var legendColors = scatterChartData.legendData.dataPoints.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            expect(scatterChartData.legendData.title).toBe('series');
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: 'a' }, { displayName: 'value1', value: '0' }, { displayName: 'value3', value: '10' }, { displayName: 'value2', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value3', value: '20' }, { displayName: 'value2', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value3', value: '30' }, { displayName: 'value2', value: '3' }]);
        });
        it('scatter chart null legend', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: null, isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: null, isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: null, isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = [null, 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var groupedValues = valueColumns.grouped();
            groupedValues[0].objects = { dataPoint: { fill: { solid: { color: '#41BEE1' } } } };
            valueColumns.grouped = function () { return groupedValues; };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: seriesValues,
                            identity: seriesIdentities,
                        }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var legendItems = scatterChartData.legendData.dataPoints;
            expect(legendItems[0].label).toBe(powerbi.visuals.valueFormatter.format(null));
            expect(legendItems[0].color).toBe('#41BEE1');
            var legendColors = legendItems.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            //Tooltips
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: '(Blank)' }, { displayName: 'value1', value: '0' }, { displayName: 'value3', value: '10' }, { displayName: 'value2', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value3', value: '20' }, { displayName: 'value2', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value3', value: '30' }, { displayName: 'value2', value: '3' }]);
        });
        it('scatter chart empty categories should return not-null category', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = [null, 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var groupedValues = valueColumns.grouped();
            groupedValues[0].objects = { dataPoint: { fill: { solid: { color: '#41BEE1' } } } };
            valueColumns.grouped = function () { return groupedValues; };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            expect(scatterChartData.dataPoints[0].category).not.toBe(null);
        });
        it('scatter chart dataView without role validation', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            // Category and series are the same field
            var metadata = {
                columns: [
                    { displayName: 'series', isMeasure: false, queryName: 'series', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "y", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "size", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "y", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "size", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "y", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "size", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                ],
                objects: { categoryLabels: { show: true } },
            };
            var seriesValues = ['a', 'b', 'c'];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
            var valueColumns = DataViewTransform.createValueColumns([
                {
                    source: metadata.columns[1],
                    values: [0, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[2],
                    values: [10, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[3],
                    values: [1, null, null],
                    identity: seriesIdentities[0],
                }, {
                    source: metadata.columns[4],
                    values: [null, 100, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[5],
                    values: [null, 20, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[6],
                    values: [null, 2, null],
                    identity: seriesIdentities[1],
                }, {
                    source: metadata.columns[7],
                    values: [null, null, 200],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[8],
                    values: [null, null, 30],
                    identity: seriesIdentities[2],
                }, {
                    source: metadata.columns[9],
                    values: [null, null, 3],
                    identity: seriesIdentities[2],
                }], [seriesIdentityField]);
            valueColumns.source = metadata.columns[0];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: seriesValues,
                            identity: seriesIdentities,
                        }],
                    values: valueColumns,
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(0);
            expect(dataPoints[0].y).toBe(10);
            expect(dataPoints[0].fill).toBeDefined();
            expect(dataPoints[0].fill).not.toBe(dataPoints[1].fill);
            var legendItems = scatterChartData.legendData.dataPoints;
            expect(legendItems.map(function (l) { return l.label; })).toEqual(['a', 'b', 'c']);
            var legendColors = legendItems.map(function (l) { return l.color; });
            expect(legendColors).toEqual(ArrayExtensions.distinct(legendColors));
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'series', value: 'a' }, { displayName: 'value1', value: '0' }, { displayName: 'value2', value: '10' }, { displayName: 'value3', value: '1' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'series', value: 'b' }, { displayName: 'value1', value: '100' }, { displayName: 'value2', value: '20' }, { displayName: 'value3', value: '2' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'series', value: 'c' }, { displayName: 'value1', value: '200' }, { displayName: 'value2', value: '30' }, { displayName: 'value3', value: '3' }]);
        });
        it('scatter chart dataView with min/max', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                            min: 310,
                            max: 350
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
        });
        it('scatter chart dataView with minLocal/maxLocal', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                            minLocal: 310,
                            maxLocal: 350
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
            expect(dataPoints[0].fill).toBeDefined();
        });
        it('scatter chart dataView without min/minLocal/max/maxLocal', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].category).toBe("a");
            expect(dataPoints[0].x).toBe(110);
            expect(dataPoints[0].y).toBe(210);
            expect(ScatterChart.getBubbleRadius(dataPoints[0].radius, scatterChartData.sizeRange, viewport)).toBe(48.5);
            expect(dataPoints[0].fill).toBeDefined();
        });
        function getDataViewMultiSeries(firstGroupName, secondGroupName) {
            if (firstGroupName === void 0) { firstGroupName = 'Canada'; }
            if (secondGroupName === void 0) { secondGroupName = 'United States'; }
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: '',
                        format: 'yyyy',
                        type: ValueType.fromDescriptor({ dateTime: true })
                    }, {
                        displayName: ''
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                        groupName: firstGroupName,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                        groupName: firstGroupName,
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                        groupName: secondGroupName,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                        groupName: secondGroupName,
                    }, {
                        displayName: '',
                        format: '#,0.00',
                        isMeasure: true,
                    }, {
                        displayName: '',
                        format: '#,0',
                        isMeasure: true,
                    }
                ]
            };
            var colP1Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p1' });
            var colP2Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p2' });
            var seriesValues = [null, firstGroupName, secondGroupName];
            var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var dataViewValueColumns = [
                {
                    source: dataViewMetadata.columns[2],
                    values: [150, 177, 157],
                    identity: seriesIdentities[1],
                }, {
                    source: dataViewMetadata.columns[3],
                    values: [30, 25, 28],
                    identity: seriesIdentities[1],
                }, {
                    source: dataViewMetadata.columns[4],
                    values: [100, 149, 144],
                    identity: seriesIdentities[2],
                }, {
                    source: dataViewMetadata.columns[5],
                    values: [300, 250, 280],
                    identity: seriesIdentities[2],
                }
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: [
                                powerbitests.helpers.parseDateString("2012-01-01T00:00:00"),
                                powerbitests.helpers.parseDateString("2011-01-01T00:00:00"),
                                powerbitests.helpers.parseDateString("2010-01-01T00:00:00")
                            ],
                            identity: [seriesIdentities[0]],
                            identityFields: [
                                colP1Ref
                            ]
                        }],
                    values: DataViewTransform.createValueColumns(dataViewValueColumns, [colP2Ref])
                },
            };
            dataView.categorical.values.source = dataViewMetadata.columns[1];
            return dataView;
        }
        it('scatterChart multi-series', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var dataView = getDataViewMultiSeries();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe('1/1/2012');
            expect(scatterChartData[0].x).toBe(150);
            expect(scatterChartData[0].y).toBe(30);
            expect(scatterChartData[0].fill).toBeDefined();
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[3].fill);
            //Tooltips
            expect(scatterChartData[0].tooltipInfo).toEqual([{ displayName: '', value: '2012' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '150.00' }, { displayName: '', value: '30' }]);
            expect(scatterChartData[1].tooltipInfo).toEqual([{ displayName: '', value: '2012' }, { displayName: '', value: 'United States' }, { displayName: '', value: '100.00' }, { displayName: '', value: '300' }]);
            expect(scatterChartData[2].tooltipInfo).toEqual([{ displayName: '', value: '2011' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '177.00' }, { displayName: '', value: '25' }]);
            expect(scatterChartData[3].tooltipInfo).toEqual([{ displayName: '', value: '2011' }, { displayName: '', value: 'United States' }, { displayName: '', value: '149.00' }, { displayName: '', value: '250' }]);
            expect(scatterChartData[4].tooltipInfo).toEqual([{ displayName: '', value: '2010' }, { displayName: '', value: 'Canada' }, { displayName: '', value: '157.00' }, { displayName: '', value: '28' }]);
            expect(scatterChartData[5].tooltipInfo).toEqual([{ displayName: '', value: '2010' }, { displayName: '', value: 'United States' }, { displayName: '', value: '144.00' }, { displayName: '', value: '280' }]);
        });
        it('scatterChart multi-series with default color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var dataView = getDataViewMultiSeries();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var hexDefaultColorRed = "#FF0000";
            dataView.metadata = {
                columns: null,
                objects: { dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } } }
            };
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].category).toBe('1/1/2012');
            expect(scatterChartData[0].x).toBe(150);
            expect(scatterChartData[0].y).toBe(30);
            expect(scatterChartData[0].fill).toBe(hexDefaultColorRed);
            expect(scatterChartData[0].fill).toBe(scatterChartData[2].fill);
            expect(scatterChartData[0].fill).toBe(scatterChartData[3].fill);
        });
        it('scatterChart multi-series with explicit colors', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var dataView = getDataViewMultiSeries();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var groupedValues = dataView.categorical.values.grouped();
            groupedValues[0].objects = { dataPoint: { fill: { solid: { color: 'red' } } } };
            groupedValues[1].objects = { dataPoint: { fill: { solid: { color: 'green' } } } };
            dataView.categorical.values.grouped = function () { return groupedValues; };
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].fill).toBe('red');
            expect(scatterChartData[1].fill).toBe('green');
        });
        it('scatterChart categorical with explicit colors', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var categoryIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'category' });
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: categoryValues,
                            identity: categoryIdentities,
                            identityFields: [categoryIdentityField],
                            objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE1' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE2' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE3' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }]
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [310, 320, 330, 340, 350],
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null).dataPoints;
            expect(scatterChartData[0].fill).toBe('#41BEE0');
            expect(scatterChartData[1].fill).toBe('#41BEE1');
            expect(scatterChartData[2].fill).toBe('#41BEE2');
            expect(scatterChartData[3].fill).toBe('#41BEE3');
            expect(scatterChartData[4].fill).toBe('#41BEE4');
        });
        it('scatterChart multi-series with min/max', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var groupNames = [
                'Equipment Failure',
                'Scheduled Outage',
                'Trees/Vegetation',
                'Under Investigation',
                ''
            ];
            var columns = [
                {
                    format: '#,0.00',
                    index: 1
                }, {
                    format: '#,0',
                    index: 2
                }, {
                    format: '#,0',
                    index: 3
                }
            ];
            var dataViewMetadata = {
                columns: [
                    {
                        displayName: '',
                        format: '0',
                        index: 0
                    }, {
                        displayName: '',
                        index: 4
                    }
                ]
            };
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                for (var j = 0; j < columns.length; j++) {
                    var column = {
                        displayName: groupName,
                        format: columns[j].format,
                        isMeasure: true,
                        index: columns[j].index
                    };
                    dataViewMetadata.columns.push(column);
                }
            }
            var colP1Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p1' });
            var colP2Ref = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 't', column: 'p2' });
            var seriesNames = [
                'Bellevue, WA',
                'Deming, WA'
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP1Ref, seriesNames[0]),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP1Ref, seriesNames[1])
            ];
            var seriesIdentiesForGroupNames = [
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP2Ref, groupNames[0]),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP2Ref, groupNames[1]),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP2Ref, groupNames[2]),
                powerbitests.mocks.dataViewScopeIdentityWithEquality(colP2Ref, groupNames[3])
            ];
            var dataViewValueColumns = [
                {
                    source: dataViewMetadata.columns[2],
                    values: [null, null],
                    identity: seriesIdentiesForGroupNames[0],
                }, {
                    source: dataViewMetadata.columns[3],
                    values: [null, null],
                    identity: seriesIdentiesForGroupNames[0],
                }, {
                    source: dataViewMetadata.columns[4],
                    values: [null, null],
                    max: 404,
                    min: 1,
                    identity: seriesIdentiesForGroupNames[0],
                }, {
                    source: dataViewMetadata.columns[5],
                    values: [null, 353],
                    identity: seriesIdentiesForGroupNames[1],
                }, {
                    source: dataViewMetadata.columns[6],
                    values: [null, 8078.00000000163],
                    identity: seriesIdentiesForGroupNames[1],
                }, {
                    source: dataViewMetadata.columns[7],
                    values: [null, 4],
                    max: 404,
                    min: 1,
                    identity: seriesIdentiesForGroupNames[1],
                }, {
                    source: dataViewMetadata.columns[8],
                    values: [126439, null],
                    identity: seriesIdentiesForGroupNames[2],
                }, {
                    source: dataViewMetadata.columns[9],
                    values: [4244.000000003725, null],
                    identity: seriesIdentiesForGroupNames[2],
                }, {
                    source: dataViewMetadata.columns[10],
                    values: [1, null],
                    max: 404,
                    min: 1,
                    identity: seriesIdentiesForGroupNames[2],
                }, {
                    source: dataViewMetadata.columns[11],
                    values: [126439, null],
                    identity: seriesIdentiesForGroupNames[3],
                }, {
                    source: dataViewMetadata.columns[12],
                    values: [239.99999999650754, null],
                    identity: seriesIdentiesForGroupNames[3],
                }, {
                    source: dataViewMetadata.columns[13],
                    values: [1, null],
                    max: 404,
                    min: 1,
                    identity: seriesIdentiesForGroupNames[3],
                }
            ];
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: seriesNames,
                            identity: seriesIdentities,
                            identityFields: [
                                colP1Ref
                            ]
                        }],
                    values: DataViewTransform.createValueColumns(dataViewValueColumns, [colP2Ref])
                },
            };
            dataView.categorical.values.source = dataViewMetadata.columns[1];
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe('Bellevue, WA');
            expect(scatterChartData[0].x).toBe(126439);
            expect(scatterChartData[0].y).toBe(4244.000000003725);
            expect(scatterChartData[0].fill).toBeDefined();
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[2].fill);
        });
        it('scatter chart dataView that should pivot categories', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: '', queryName: '$s1', index: 0 },
                    { displayName: '', queryName: '$s2', isMeasure: true, index: 1 },
                    { displayName: '', queryName: '$s3', isMeasure: true, index: 2 },
                    { displayName: '', queryName: '$s4', isMeasure: true, index: 3 }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('a'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ]
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220]
                        }, {
                            source: metadata.columns[3],
                            values: [310, 320]
                        }])
                }
            };
            var pivotedDataView = DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: powerbi.visuals.plugins.scatterChart.capabilities.objects,
                dataViewMappings: powerbi.visuals.plugins.scatterChart.capabilities.dataViewMappings,
                transforms: {
                    selects: [
                        { displayName: 'col1', queryName: '$s1', roles: { 'Series': true } },
                        { displayName: 'col2', queryName: '$s2', roles: { 'Y': true } },
                        { displayName: 'col3', queryName: '$s3', roles: { 'Size': true } },
                        { displayName: 'col4', queryName: '$s4', roles: { 'X': true } },
                    ]
                },
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory(),
            })[0];
            expect(pivotedDataView).not.toBe(dataView);
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(pivotedDataView, viewport, colors).dataPoints;
            expect(scatterChartData[0].category).toBe(powerbi.visuals.valueFormatter.format(null));
            expect(scatterChartData[0].fill).not.toBe(scatterChartData[1].fill);
            //Tooltips
            expect(scatterChartData[0].tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col4', value: '310' }, { displayName: 'col2', value: '110' }, { displayName: 'col3', value: '210' }]);
            expect(scatterChartData[1].tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col4', value: '320' }, { displayName: 'col2', value: '120' }, { displayName: 'col3', value: '220' }]);
        });
        it('scatter chart bubble color category no size', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe(dataPoints[1].fill);
            //Tooltips
            expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: 'col1', value: 'a' }, { displayName: 'col3', value: '210' }, { displayName: 'col2', value: '110' }]);
            expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: 'col1', value: 'b' }, { displayName: 'col3', value: '220' }, { displayName: 'col2', value: '120' }]);
            expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: 'col1', value: 'c' }, { displayName: 'col3', value: '230' }, { displayName: 'col2', value: '130' }]);
            expect(dataPoints[3].tooltipInfo).toEqual([{ displayName: 'col1', value: 'd' }, { displayName: 'col3', value: '240' }, { displayName: 'col2', value: '140' }]);
            expect(dataPoints[4].tooltipInfo).toEqual([{ displayName: 'col1', value: 'e' }, { displayName: 'col3', value: '250' }, { displayName: 'col2', value: '150' }]);
        });
        it('scatter chart bubble color category no size default color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var hexDefaultColorRed = "#FF0000";
            metadata.objects = {
                dataPoint: { defaultColor: { solid: { color: hexDefaultColorRed } } }
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors, null);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe(hexDefaultColorRed);
        });
        it('scatter chart null X axes values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                            objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE1' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE2' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE3' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [null, null, null, null, null]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null Y axes values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [null, null, null, null, null]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [110, 120, 130, 140, 150]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null X measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { "Y": true } }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e']
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: null
                        },
                        {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart null Y measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col4', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                            objects: [{ dataPoint: { fill: { solid: { color: '#41BEE0' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE1' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE2' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE3' } } } },
                                { dataPoint: { fill: { solid: { color: '#41BEE4' } } } }],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [210, 220, 230, 240, 250]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints[0].category).toBe('a');
            expect(scatterChartDataPoints[1].fill).toBe('#41BEE1');
            expect(scatterChartDataPoints[0].x).toBe(210);
            expect(scatterChartDataPoints[0].y).toBe(0);
        });
        it('scatter chart null X and Y measure', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: null
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var scatterChartDataPoints = scatterChartData.dataPoints;
            expect(scatterChartDataPoints.length).toBe(0);
        });
        it('scatter chart converter data labels default values', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a'],
                            identity: categoryIdentities,
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110]
                        }, {
                            source: metadata.columns[2],
                            values: [210]
                        }])
                }
            };
            var dataLabelsSettings = powerbi.visuals.dataLabelUtils.getDefaultPointLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            expect(scatterChartData.dataLabelsSettings).toEqual(dataLabelsSettings);
        });
        it('scatter chart bubble gradient color', function () {
            var viewport = {
                height: 500,
                width: 500
            };
            var metadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Y": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col5', isMeasure: true, roles: { "Gradient": true } }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: "#d9f2fb" } } } },
                { dataPoint: { fill: { solid: { color: "#b1eab7" } } } },
                { dataPoint: { fill: { solid: { color: "#cceab7" } } } },
                { dataPoint: { fill: { solid: { color: "#b100b7" } } } },
                { dataPoint: { fill: { solid: { color: "#cceab7" } } } }
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['a', 'b', 'c', 'd', 'e'],
                            identity: categoryIdentities,
                            objects: objectDefinitions
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }, {
                            source: metadata.columns[3],
                            values: [10, 20, 15, 10, 100]
                        }, {
                            source: metadata.columns[4],
                            values: [13, 33, 55, 11, 55]
                        }])
                }
            };
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var scatterChartData = ScatterChart.converter(dataView, viewport, colors);
            var dataPoints = scatterChartData.dataPoints;
            expect(dataPoints[0].fill).toBe('#d9f2fb');
            expect(dataPoints[1].fill).toBe('#b1eab7');
            expect(dataPoints[2].fill).toBe('#cceab7');
            expect(dataPoints[3].fill).toBe('#b100b7');
            expect(dataPoints[4].fill).toBe('#cceab7');
        });
    });
    describe('scatterChart interactivity', function () {
        var v, element;
        var hostServices;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
            ]
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            hostServices = powerbitests.mocks.createVisualHostServices();
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        it('scatter chart single select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart repeated single select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart multi select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[4]);
                var mockEvent = {
                    abc: 'def',
                    ctrlKey: true,
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger4(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]],
                        }
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                trigger1(mockEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart single and multi select', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger1 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var trigger3 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[3]);
                var trigger4 = powerbitests.helpers.getClickTriggerFunctionForD3(dots[4]);
                var singleEvent = {
                    abc: 'def',
                    stopPropagation: function () { },
                };
                var multiEvent = {
                    abc: 'def',
                    ctrlKey: true,
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger1(singleEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                trigger3(multiEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        },
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                trigger1(singleEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                trigger4(multiEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[3]]
                        }
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                trigger3(singleEvent);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1]]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart external clear', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                identities[3]
                            ]
                        }
                    ]
                });
                v.onClearSelection();
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart clear on clearCatcher click', function (done) {
            var dimmedOpacity = ScatterChart.DimmedBubbleOpacity.toString();
            var defaultOpacity = ScatterChart.DefaultBubbleOpacity.toString();
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var dots = element.find('.dot');
                var trigger = powerbitests.helpers.getClickTriggerFunctionForD3(dots[1]);
                var mockEvent = {
                    abc: 'def',
                    stopPropagation: function () { },
                };
                spyOn(hostServices, 'onSelect').and.callThrough();
                trigger(mockEvent);
                expect(dots.length).toBe(5);
                expect(dots[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(dots[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                identities[3]
                            ]
                        }
                    ]
                });
                ($('.clearCatcher').last()).d3Click(0, 0);
                expect(dots[0].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[1].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[2].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[3].style.fillOpacity).toBe(defaultOpacity);
                expect(dots[4].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: []
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("interactive legend scatterChart validation", function () {
        var v;
        var element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer) }
            ]
        };
        var identities = [
            powerbitests.mocks.dataViewScopeIdentity('a'),
            powerbitests.mocks.dataViewScopeIdentity('b'),
            powerbitests.mocks.dataViewScopeIdentity('c'),
            powerbitests.mocks.dataViewScopeIdentity('d'),
            powerbitests.mocks.dataViewScopeIdentity('e'),
        ];
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { isInteractiveLegend: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                    identity: identities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [110, 120, 130, 140, 150]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [210, 220, 230, 240, 250]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [310, 320, 330, 340, 350]
                                }])
                        }
                    }]
            });
        });
        it('Interaction scatter chart click validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) { return d.category === 'd'; });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var mouseCordinate = { x: x + 3, y: y + 2 };
            spyOn(scatterChart.interactivityService.behavior, 'getMouseCoordinates').and.returnValue(mouseCordinate);
            scatterChart.interactivityService.behavior.onClick();
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Scatter chart drag interaction validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) { return d.category === 'd'; });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var mouseCordinate = { x: x, y: y };
            spyOn(scatterChart.interactivityService.behavior, 'getMouseCoordinates').and.returnValue(mouseCordinate);
            scatterChart.interactivityService.behavior.onDrag();
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Interaction scatter chart dotClick validation', function (done) {
            var scatterChart = v.layers[0];
            var selectedCircle = scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) { return d.category === 'd'; });
            var x = selectedCircle.attr('cx');
            var y = selectedCircle.attr('cy');
            var selectedDotIndex = scatterChart.interactivityService.behavior.findClosestDotIndex(x, y);
            scatterChart.interactivityService.behavior.selectDotByIndex(selectedDotIndex);
            setTimeout(function () {
                validateInteraction(x, y, scatterChart);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    function validateInteraction(x, y, scatterChart) {
        //test crosshair position
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('y1')).toBe(y.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('y2')).toBe(y.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('x1')).toBe(x.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('x2')).toBe(x.toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('x1')).toBe('0');
        expect(scatterChart.interactivityService.behavior.crosshair.select(".horizontal").attr('x2')).toBe(scatterChart.mainGraphicsContext.attr('width').toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('y1')).toBe(scatterChart.mainGraphicsContext.attr('height').toString());
        expect(scatterChart.interactivityService.behavior.crosshair.select(".vertical").attr('y2')).toBe('0');
        //test style => dot 3 should be selected
        expect(scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) { return (d.x !== 140) && (d.y !== 240); }).attr('class')).toBe("dot notSelected");
        expect(scatterChart.mainGraphicsContext.selectAll('circle.dot').filter(function (d, i) { return (d.x === 140) && (d.y === 240); }).attr('class')).toBe("dot selected");
        //test legend
        expect($('.interactive-legend').find('.title').text().trim()).toMatch("d");
        expect($('.interactive-legend').find('.item').find('.itemName')[0].innerText.trim()).toBe('col2');
        expect($('.interactive-legend').find('.item').find('.itemName')[1].innerText.trim()).toBe('col4');
        expect($('.interactive-legend').find('.item').find('.itemName')[2].innerText.trim()).toBe('col3');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[0].innerText.trim()).toBe('140');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[1].innerText.trim()).toBe('340');
        expect($('.interactive-legend').find('.item').find('.itemMeasure')[2].innerText.trim()).toBe('240');
    }
    describe("scatterChart axis label existence validation", function () {
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, false, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, true, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, false, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight interactive', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, true, false);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(0);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height smaller than axisLabelVisibleMinHeight interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleSmallerThanMinHeightString, axisLabelVisibleSmallerThanMinHeightString, true, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart axis labels existence dom validation with viewport height greater than axisLabelVisibleMinHeight interactive mobile', function (done) {
            testAxisAndLegendExistence(axisLabelVisibleGreaterThanMinHeightString, axisLabelVisibleGreaterThanMinHeightString, true, true);
            setTimeout(function () {
                expect($('.scatterChart .axisGraphicsContext .xAxisLabel').length).toBe(1);
                expect($('.scatterChart .axisGraphicsContext .yAxisLabel').length).toBe(1);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("scatterChart legends existence validation", function () {
        it('scatter chart legends existence dom validation with viewport height greater than legendVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(legendVisibleGreaterThanMinHeightString, "500", false, false);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height smaller than legendVisibleMinHeight non-interactive', function (done) {
            testAxisAndLegendExistence(legendVisibleSmallerThanMinHeightString, "500", false, false);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height smaller than legendVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(legendVisibleSmallerThanMinHeightString, legendVisibleSmallerThanMinHeightString, false, true);
            setTimeout(function () {
                expect($('.legend .label').length).toBe(0);
                expect($('.legend .item').length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('scatter chart legends existence dom validation with viewport height greater than legendVisibleMinHeight non-interactive mobile', function (done) {
            testAxisAndLegendExistence(legendVisibleGreaterThanMinHeightString, "500", false, true);
            setTimeout(function () {
                expect($('.legendText').length).toBe(3);
                expect($('.legendItem').length).toBe(3);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        var dataViewMetadataFourColumn = {
            columns: [
                { displayName: 'col1', roles: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'col2', isMeasure: true, roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col3', isMeasure: true, roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'col4', isMeasure: true, roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
            ]
        };
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var categoryValues = ['a', 'b', 'c', 'd', 'e'];
            var categoryIdentities = categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: categoryValues,
                                    identity: categoryIdentities,
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [100, 200, 300, 400, 500]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(7);
                expect(points[0].properties['defaultColor']).toBeDefined();
                expect(points[1].properties['showAllDataPoints']).toBeDefined();
                for (var i = 2; i < points.length; i++) {
                    expect(_.contains(categoryValues, points[i].displayName)).toBeTruthy();
                    expect(points[i].properties['fill']).toBeDefined();
                }
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('enumerateObjectInstances: Verify x-axis property card for scatter chart', function () {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e'],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataFourColumn.columns[1],
                                    values: [1, 2, 3, 4, 5]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[2],
                                    values: [200, 400, 600, 800, 1000]
                                }, {
                                    source: dataViewMetadataFourColumn.columns[3],
                                    values: [1, 2, 3, 4, 5]
                                }])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var points = v.enumerateObjectInstances({ objectName: 'categoryAxis' });
            expect('start' in points[0].properties).toBeTruthy(); //better to check if the index key is found
            expect('end' in points[0].properties).toBeTruthy();
            expect('axisType' in points[0].properties).toBeFalsy();
            expect('show' in points[0].properties).toBeTruthy();
            expect('showAxisTitle' in points[0].properties).toBeTruthy();
            expect('axisStyle' in points[1].properties).toBeTruthy();
        });
        it('X-axis customization: Test forced domain (start and end)', function () {
            dataViewMetadataFourColumn.objects = {
                categoryAxis: {
                    show: true,
                    start: 0,
                    end: 25,
                    axisType: AxisType.scalar,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: [1, 2, 3, 4, 5],
                                }]
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var labels = $('.x.axis').children('.tick');
            expect(labels[0].textContent).toBe('0');
            expect(labels[labels.length - 1].textContent).toBe('25');
        });
        it('Y-axis customization: Test forced domain (start and end)', function () {
            dataViewMetadataFourColumn.objects = {
                valueAxis: {
                    show: true,
                    position: 'Right',
                    start: 0,
                    end: 500,
                    showAxisTitle: true,
                    axisStyle: true
                }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataFourColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataFourColumn.columns[0],
                                    values: [1, 2, 3, 4, 5],
                                }]
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var labels = $('.y.axis').children('.tick');
            expect(labels[0].textContent).toBe('0');
            expect(labels[labels.length - 1].textContent).toBe('500');
        });
    });
    function testAxisAndLegendExistence(domSizeHeightString, domSizeWidthString, isInteractive, isMobile) {
        var element = powerbitests.helpers.testDom(domSizeHeightString, domSizeWidthString);
        var v;
        if (isMobile) {
            v = powerbi.visuals.visualPluginFactory.createMobile().getPlugin('scatterChart').create();
        }
        else {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
        }
        v.init({
            element: element,
            host: powerbitests.mocks.createVisualHostServices(),
            style: powerbi.visuals.visualStyles.create(),
            viewport: {
                height: element.height(),
                width: element.width()
            },
            animation: { transitionImmediate: true },
            interactivity: { isInteractiveLegend: isInteractive },
        });
        // Category and series are the same field
        var metadata = {
            columns: [
                { displayName: 'series', isMeasure: false, queryName: 'series', roles: { "Category": true, "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                { displayName: 'value1', groupName: 'a', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value2', groupName: 'a', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value3', groupName: 'a', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value1', groupName: 'b', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value2', groupName: 'b', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value3', groupName: 'b', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value1', groupName: 'c', isMeasure: true, queryName: "x", roles: { "X": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value2', groupName: 'c', isMeasure: true, queryName: "size", roles: { "Size": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                { displayName: 'value3', groupName: 'c', isMeasure: true, queryName: "y", roles: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            ],
            objects: { categoryLabels: { show: true } },
        };
        var seriesValues = ['a', 'b', 'c'];
        var seriesIdentities = seriesValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
        var seriesIdentityField = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'series' });
        var valueColumns = DataViewTransform.createValueColumns([
            {
                source: metadata.columns[1],
                values: [0, null, null],
                identity: seriesIdentities[0],
            }, {
                source: metadata.columns[2],
                values: [1, null, null],
                identity: seriesIdentities[0],
            }, {
                source: metadata.columns[3],
                values: [10, null, null],
                identity: seriesIdentities[0],
            }, {
                source: metadata.columns[4],
                values: [null, 100, null],
                identity: seriesIdentities[1],
            }, {
                source: metadata.columns[5],
                values: [null, 2, null],
                identity: seriesIdentities[1],
            }, {
                source: metadata.columns[6],
                values: [null, 20, null],
                identity: seriesIdentities[1],
            }, {
                source: metadata.columns[7],
                values: [null, null, 200],
                identity: seriesIdentities[2],
            }, {
                source: metadata.columns[8],
                values: [null, null, 3],
                identity: seriesIdentities[2],
            }, {
                source: metadata.columns[9],
                values: [null, null, 30],
                identity: seriesIdentities[2],
            }], [seriesIdentityField]);
        valueColumns.source = metadata.columns[0];
        v.onDataChanged({
            dataViews: [{
                    metadata: metadata,
                    categorical: {
                        categories: [{
                                source: metadata.columns[0],
                                values: seriesValues,
                                identity: seriesIdentities,
                                identityFields: [seriesIdentityField],
                            }],
                        values: valueColumns
                    }
                }]
        });
    }
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var Slicer = powerbi.visuals.Slicer;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var EventType = powerbitests.helpers.ClickEventType;
    var ValueType = powerbi.ValueType;
    var SelectionId = powerbi.visuals.SelectionId;
    powerbitests.mocks.setLocale();
    var dataViewMetadata = {
        columns: [
            { displayName: "Fruit", properties: { "Category": true }, type: ValueType.fromDescriptor({ text: true }) },
            { displayName: "Price", isMeasure: true }]
    };
    var dataViewCategorical = {
        categories: [{
                source: dataViewMetadata.columns[0],
                values: ["Apple", "Orange", "Kiwi", "Grapes", "Banana"],
                identity: [
                    powerbitests.mocks.dataViewScopeIdentity("Apple"),
                    powerbitests.mocks.dataViewScopeIdentity("Orange"),
                    powerbitests.mocks.dataViewScopeIdentity("Kiwi"),
                    powerbitests.mocks.dataViewScopeIdentity("Grapes"),
                    powerbitests.mocks.dataViewScopeIdentity("Banana")
                ]
            }],
        values: DataViewTransform.createValueColumns([{
                source: dataViewMetadata.columns[1],
                values: [20, 10, 30, 15, 12]
            }])
    };
    var dataView = {
        metadata: dataViewMetadata,
        categorical: dataViewCategorical
    };
    var interactiveDataViewOptions = {
        dataViews: [dataView]
    };
    describe("Slicer", function () {
        it("Slicer_registered_capabilities", function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin("slicer").capabilities).toBe(powerbi.visuals.slicerCapabilities);
        });
        it("Capabilities should include dataViewMapping", function () {
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings).toBeDefined();
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings.length).toBe(1);
        });
        it("Capabilities should have condition", function () {
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings[0].conditions.length).toBe(1);
            expect(powerbi.visuals.slicerCapabilities.dataViewMappings[0].conditions[0][powerbi.visuals.slicerCapabilities.dataRoles[0].name].max).toBe(1);
        });
        it("Capabilities should include dataRoles", function () {
            expect(powerbi.visuals.slicerCapabilities.dataRoles).toBeDefined();
            expect(powerbi.visuals.slicerCapabilities.dataRoles.length).toBe(1);
        });
        it("Capabilities should suppressDefaultTitle", function () {
            expect(powerbi.visuals.slicerCapabilities.suppressDefaultTitle).toBe(true);
        });
        it("Filter property should match calculated", function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFilterOutput(powerbi.visuals.slicerCapabilities.objects)).toEqual(powerbi.visuals.slicerProps.filterPropertyIdentifier);
        });
        it("Sort should be default so the sort UI shows", function () {
            expect(powerbi.visuals.slicerCapabilities.sorting.custom).not.toBeDefined();
            expect(powerbi.visuals.slicerCapabilities.sorting.default).toBeDefined();
        });
    });
    describe("Slicer DOM tests", function () {
        var v;
        var element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom("200", "300");
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("slicer").create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                }
            });
        });
        it("Slicer DOM Validation", function (done) {
            spyOn(powerbi.visuals.valueFormatter, "format").and.callThrough();
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                expect($(".slicerContainer")).toBeInDOM();
                expect($(".slicerContainer .headerText")).toBeInDOM();
                expect($(".slicerContainer .slicerHeader .clear")).toBeInDOM();
                expect($(".slicerContainer .slicerBody")).toBeInDOM();
                expect($(".slicerContainer .slicerBody .row .slicerText")).toBeInDOM();
                expect($(".slicerText").length).toBe(5);
                expect($(".slicerText").first().text()).toBe("Apple");
                expect($(".slicerText").last().text()).toBe("Banana");
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith("Apple", undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith("Orange", undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith("Kiwi", undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith("Grapes", undefined);
                expect(powerbi.visuals.valueFormatter.format).toHaveBeenCalledWith("Banana", undefined);
                // Subsequent update
                var dataView2 = {
                    metadata: dataViewMetadata,
                    categorical: {
                        categories: [{
                                source: dataViewMetadata.columns[0],
                                values: ["Strawberry", "Blueberry", "Blackberry"],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity("Strawberry"),
                                    powerbitests.mocks.dataViewScopeIdentity("Blueberry"),
                                    powerbitests.mocks.dataViewScopeIdentity("Blackberry")
                                ]
                            }],
                        values: DataViewTransform.createValueColumns([{
                                source: dataViewMetadata.columns[1],
                                values: [40, 25, 22]
                            }])
                    }
                };
                v.onDataChanged({ dataViews: [dataView2] });
                setTimeout(function () {
                    expect($(".slicerContainer")).toBeInDOM();
                    expect($(".slicerContainer .headerText")).toBeInDOM();
                    expect($(".slicerContainer .slicerHeader .clear")).toBeInDOM();
                    expect($(".slicerContainer .slicerBody")).toBeInDOM();
                    expect($(".slicerContainer .slicerBody .row .slicerText")).toBeInDOM();
                    expect($(".slicerText").length).toBe(3);
                    expect($(".slicerText").first().text()).toBe("Strawberry");
                    expect($(".slicerText").last().text()).toBe("Blackberry");
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
        it("Validate converter", function (done) {
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                var slicerData = Slicer.converter(dataView);
                expect(slicerData.slicerDataPoints.length).toBe(5);
                var dataViewIdentities = dataView.categorical.categories[0].identity;
                var selectionIds = [
                    SelectionId.createWithId(dataViewIdentities[0]),
                    SelectionId.createWithId(dataViewIdentities[1]),
                    SelectionId.createWithId(dataViewIdentities[2]),
                    SelectionId.createWithId(dataViewIdentities[3]),
                    SelectionId.createWithId(dataViewIdentities[4])
                ];
                var dataPoints = [
                    {
                        value: "Apple",
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[0],
                        selected: false
                    },
                    {
                        value: "Orange",
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[1],
                        selected: false
                    },
                    {
                        value: "Kiwi",
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[2],
                        selected: false
                    },
                    {
                        value: "Grapes",
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[3],
                        selected: false
                    },
                    {
                        value: "Banana",
                        mouseOver: false,
                        mouseOut: true,
                        identity: selectionIds[4],
                        selected: false
                    }];
                expect(slicerData).toEqual({ categorySourceName: "Fruit", formatString: undefined, slicerDataPoints: dataPoints });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it('Null dataView test', function (done) {
            v.onDataChanged({ dataViews: [] });
            setTimeout(function () {
                expect($(".slicerText").length).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Slicer resize", function (done) {
            var viewport = {
                height: 200,
                width: 300
            };
            v.onResizing(viewport);
            setTimeout(function () {
                expect($(".slicerContainer .slicerBody").first().css("height")).toBe("177px");
                expect($(".slicerContainer .slicerBody").first().css("width")).toBe("300px");
                expect($(".slicerContainer .headerText").first().css("width")).toBe("292px");
                // Next Resize
                var viewport2 = {
                    height: 150,
                    width: 150
                };
                v.onResizing(viewport2);
                setTimeout(function () {
                    expect($(".slicerContainer .slicerBody").first().css("height")).toBe("127px");
                    expect($(".slicerContainer .slicerBody").first().css("width")).toBe("150px");
                    done();
                }, powerbitests.DefaultWaitForRender);
            }, powerbitests.DefaultWaitForRender);
        });
    });
    describe("Slicer Interactivity", function () {
        var v, element, slicers, slicerCheckboxInput;
        var hostServices;
        beforeEach(function () {
            element = powerbitests.helpers.testDom("200", "300");
            v = powerbi.visuals.visualPluginFactory.create().getPlugin("slicer").create();
            hostServices = powerbitests.mocks.createVisualHostServices();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                interactivity: { selection: true }
            });
            v.onDataChanged(interactiveDataViewOptions);
            slicers = $(".slicerText");
            slicerCheckboxInput = $("label.slicerCheckbox").find("input");
            spyOn(hostServices, "onSelect").and.callThrough();
        });
        it("slicer item select", function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(true);
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[1]).property("checked")).toBe(false);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]
                            ]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer item multi-select checkboxes", function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]
                            ]
                        }
                    ]
                });
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(true);
                expect(d3.select(slicerCheckboxInput[1]).property("checked")).toBe(false);
                slicers.last().d3Click(0, 0);
                expect(slicers[4].style.color).toBe("rgb(33, 33, 33)");
                expect(d3.select(slicerCheckboxInput[4]).property("checked")).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]
                            ]
                        }
                    ]
                });
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[4]
                            ]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer item multi-select with control key", function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(true);
                expect(d3.select(slicerCheckboxInput[1]).property("checked")).toBe(false);
                slicers.last().d3Click(0, 0, EventType.CtrlKey);
                expect(slicers[4].style.color).toBe("rgb(33, 33, 33)");
                expect(d3.select(slicerCheckboxInput[4]).property("checked")).toBe(true);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [
                                interactiveDataViewOptions.dataViews[0].categorical.categories[0].identity[0]
                            ]
                        }
                    ]
                });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer item repeated selection", function (done) {
            setTimeout(function () {
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                slicers.last().d3Click(0, 0);
                slicers.last().d3Click(0, 0);
                expect(slicers[4].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(true);
                expect(d3.select(slicerCheckboxInput[4]).property("checked")).toBe(false);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer clear", function (done) {
            setTimeout(function () {
                var clearBtn = $(".clear");
                // Slicer click
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                slicers.last().d3Click(0, 0);
                expect(slicers[4].style.color).toBe("rgb(33, 33, 33)");
                /* Slicer clear */
                clearBtn.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(102, 102, 102)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(slicers[2].style.color).toBe("rgb(102, 102, 102)");
                expect(slicers[3].style.color).toBe("rgb(102, 102, 102)");
                expect(slicers[4].style.color).toBe("rgb(102, 102, 102)");
                expect(hostServices.onSelect).toHaveBeenCalledWith({ data: [] });
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer mouseover", function (done) {
            setTimeout(function () {
                var event = document.createEvent("Event");
                event.initEvent("mouseover", true, true);
                slicers[0].dispatchEvent(event);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                expect(slicers[1].style.color).toBe("rgb(102, 102, 102)");
                expect(d3.select(slicerCheckboxInput[0]).property("checked")).toBe(false);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer mouseout", function (done) {
            setTimeout(function () {
                // mouseover, mouseout
                var mouseOverEvent = document.createEvent("Event");
                mouseOverEvent.initEvent("mouseover", true, true);
                slicers[0].dispatchEvent(mouseOverEvent);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                var mouseOutEvent = document.createEvent("Event");
                mouseOutEvent.initEvent("mouseout", true, true);
                slicers[0].dispatchEvent(mouseOutEvent);
                expect(slicers[0].style.color).toBe("rgb(102, 102, 102)");
                slicers.first().d3Click(0, 0);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                var mouseOverEvent1 = document.createEvent("Event");
                mouseOverEvent1.initEvent("mouseover", true, true);
                slicers[0].dispatchEvent(mouseOverEvent1);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                var mouseOutEvent1 = document.createEvent("Event");
                mouseOutEvent1.initEvent("mouseout", true, true);
                slicers[0].dispatchEvent(mouseOutEvent1);
                expect(slicers[0].style.color).toBe("rgb(33, 33, 33)");
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("slicer loadMoreData noSegment", function () {
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).not.toHaveBeenCalled();
        });
        it("slicer loadMoreData", function () {
            var metadata = {
                columns: dataViewMetadata.columns,
                segment: {}
            };
            var interactiveDataViewOptions = {
                dataViews: [{ metadata: metadata, categorical: dataViewCategorical }]
            };
            v.onDataChanged(interactiveDataViewOptions);
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            expect(loadMoreSpy).toHaveBeenCalled();
        });
        it("slicer loadMoreData already called", function () {
            var metadata = {
                columns: dataViewMetadata.columns,
                segment: {}
            };
            var interactiveDataViewOptions = {
                dataViews: [{ metadata: metadata, categorical: dataViewCategorical }]
            };
            v.onDataChanged(interactiveDataViewOptions);
            var listViewOptions = v["listView"]["options"];
            var loadMoreSpy = spyOn(hostServices, "loadMoreData");
            listViewOptions.loadMoreData();
            listViewOptions.loadMoreData();
            expect(loadMoreSpy.calls.all().length).toBe(1);
        });
        it('Validate scroll position on onDataChanged', function (done) {
            var interactiveDataViewOptionsWithLoadMore = {
                dataViews: [{ metadata: dataViewMetadata, categorical: dataViewCategorical }],
                operationKind: 1 /* Append */
            };
            dataViewCategorical = {
                categories: [{
                        source: dataViewMetadata.columns[0],
                        values: ['PineApple', 'Strawberry', 'Mango', 'Grapes', 'Banana'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('PineApple'),
                            powerbitests.mocks.dataViewScopeIdentity('Strawberry'),
                            powerbitests.mocks.dataViewScopeIdentity('Mango'),
                            powerbitests.mocks.dataViewScopeIdentity('Grapes'),
                            powerbitests.mocks.dataViewScopeIdentity('Banana'),
                        ]
                    }],
                values: DataViewTransform.createValueColumns([{
                        source: dataViewMetadata.columns[1],
                        values: [20, 10, 30, 15, 12]
                    }]),
            };
            var interactiveDataViewOptionWithCreate = {
                dataViews: [{ metadata: dataViewMetadata, categorical: dataViewCategorical }],
                operationKind: 0 /* Create */
            };
            var listView = v['listView'];
            var renderSpy = spyOn(listView, 'render');
            v.onDataChanged(interactiveDataViewOptions);
            setTimeout(function () {
                // Loading the same categories should NOT reset the scrollbar
                expect(renderSpy).toHaveBeenCalledWith(true, false);
                // LoadMore should NOT reset the scrollbar
                v.onDataChanged(interactiveDataViewOptionsWithLoadMore);
                expect(renderSpy).toHaveBeenCalledWith(true, false);
                // OperationKind of create and data with different category identity should reset the scrollbar position
                v.onDataChanged(interactiveDataViewOptionWithCreate);
                expect(renderSpy).toHaveBeenCalledWith(true, true);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var CompiledSubtotalType = powerbi.data.CompiledSubtotalType;
    var Table = powerbi.visuals.Table;
    var TableHierarchyNavigator = powerbi.visuals.TableHierarchyNavigator;
    var valueFormatter = powerbi.visuals.valueFormatter;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var DefaultWaitForRender = 500;
    powerbitests.mocks.setLocale();
    var dataTypeNumber = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
    var dataTypeString = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text);
    var dataTypeWebUrl = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text, 'WebUrl');
    var groupSource1 = { displayName: 'group1', queryName: 'group1', type: dataTypeString, index: 0 };
    var groupSource2 = { displayName: 'group2', queryName: 'group2', type: dataTypeString, index: 1 };
    var groupSource3 = { displayName: 'group3', queryName: 'group3', type: dataTypeString, index: 2 };
    var groupSourceWebUrl = { displayName: 'groupWebUrl', queryName: 'groupWebUrl', type: dataTypeWebUrl, index: 0 };
    var measureSource1 = { displayName: 'measure1', queryName: 'measure1', type: dataTypeNumber, isMeasure: true, index: 3, objects: { general: { formatString: '#.0' } } };
    var measureSource2 = { displayName: 'measure2', queryName: 'measure2', type: dataTypeNumber, isMeasure: true, index: 4, objects: { general: { formatString: '#.00' } } };
    var measureSource3 = { displayName: 'measure3', queryName: 'measure3', type: dataTypeNumber, isMeasure: true, index: 5, objects: { general: { formatString: '#' } } };
    var webPluginService = new powerbi.visuals.visualPluginFactory.MinervaVisualPluginService({});
    var tableTotals = {
        general: {
            totals: true
        }
    };
    var tableNoTotals = {
        general: {
            totals: false
        }
    };
    var tableOneMeasure = {
        metadata: { columns: [measureSource1] },
        table: {
            columns: [measureSource1],
            rows: [
                [100]
            ]
        }
    };
    var dataViewTableOneGroup = {
        columns: [groupSource1],
        rows: [
            ['A'],
            ['B'],
            ['C']
        ]
    };
    var tableOneGroup = {
        metadata: { columns: [groupSource1] },
        table: dataViewTableOneGroup
    };
    var tableOneGroupNulls = {
        metadata: { columns: [groupSource1] },
        table: {
            columns: [groupSource1],
            rows: [
                [''],
                [null]
            ]
        }
    };
    var dataViewTableTwoGroups = {
        columns: [groupSource1, groupSource2],
        rows: [
            ['A', 'a1'],
            ['A', 'a2'],
            ['A', 'a3'],
            ['B', 'a1'],
            ['B', 'a2'],
            ['C', 'c1'],
            ['C', 'c2']
        ]
    };
    var tableTwoGroups = {
        metadata: { columns: [groupSource1, groupSource2] },
        table: dataViewTableTwoGroups
    };
    var tableTwoGroupsThreeMeasures = {
        metadata: {
            columns: [groupSource1, groupSource2, measureSource1, measureSource2, measureSource3],
            objects: tableTotals
        },
        table: {
            columns: [groupSource1, groupSource2, measureSource1, measureSource2, measureSource3],
            rows: [
                ['A', 'a1', 100, 101, 102],
                ['A', 'a2', 103, 104, 105],
                ['A', 'a3', 106, 107, 108],
                ['B', 'a1', 109, 110, 111],
                ['B', 'a2', 112, 113, 114],
                ['C', 'c1', 115, 116, 117],
                ['C', 'c2', 118, 119, 120]
            ],
            totals: [null, null, 763, 770, 777]
        }
    };
    var tableTwoGroups1MeasureNulls = {
        metadata: {
            columns: [groupSource1, groupSource2, measureSource1],
        },
        table: {
            columns: [groupSource1, groupSource2, measureSource1],
            rows: [
                ['A', 'a1', 100],
                ['', null, 103],
                ['', 'a3', 106],
                ['B', '', 112],
                [null, '', null]
            ]
        }
    };
    var tableThreeGroupsThreeMeasuresInterleaved = {
        metadata: { columns: [groupSource1, measureSource1, groupSource2, measureSource2, groupSource3, measureSource3] },
        table: {
            columns: [groupSource1, measureSource1, groupSource2, measureSource2, groupSource3, measureSource3],
            rows: [
                ['A', 100, 'aa', 101, 'aa1', 102],
                ['A', 103, 'aa', 104, 'aa2', 105],
                ['A', 106, 'ab', 107, 'ab1', 108],
                ['B', 109, 'ba', 110, 'ba1', 111],
                ['B', 112, 'bb', 113, 'bb1', 114],
                ['B', 115, 'bb', 116, 'bb2', 117],
                ['C', 118, 'cc', 119, 'cc1', 120],
            ]
        }
    };
    var tableOneMeasureOneGroupSubtotals = {
        metadata: {
            columns: [measureSource1, groupSource1],
            objects: tableTotals
        },
        table: {
            columns: [measureSource1, groupSource1],
            rows: [
                [1, 'A'],
                [2, 'B'],
                [3, 'C']
            ],
            totals: [6, null]
        }
    };
    var tableOneMeasureOneGroup = {
        metadata: {
            columns: [measureSource1, groupSource1],
            objects: tableNoTotals
        },
        table: {
            columns: [measureSource1, groupSource1],
            rows: [
                [1, 'A'],
                [2, 'B'],
                [3, 'C']
            ]
        }
    };
    var tableWebUrl = {
        metadata: {
            columns: [groupSourceWebUrl],
            objects: tableNoTotals,
        },
        table: {
            columns: [groupSourceWebUrl],
            rows: [
                ['http://www.microsoft.com'],
                ['data:url'],
                ['https://www.microsoft.com/2'],
            ]
        }
    };
    describe('Table', function () {
        it('Table registered capabilities', function () {
            expect(webPluginService.getPlugin('table').capabilities).toEqual(Table.capabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(Table.capabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(Table.capabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should suppressDefaultTitle', function () {
            expect(Table.capabilities.suppressDefaultTitle).toBe(true);
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(Table.capabilities.objects)).toEqual(Table.formatStringProp);
        });
        it('CustomizeQuery picks up enabled total', function () {
            var objects = {
                general: {
                    totals: true
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(CompiledSubtotalType.Before);
        });
        it('CustomizeQuery picks up disabled total', function () {
            var objects = {
                general: {
                    totals: false
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            powerbi.visuals.Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(CompiledSubtotalType.None);
        });
        it('CustomizeQuery handles missing settings', function () {
            var dataViewMapping = createCompiledDataViewMapping();
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Total should be enabled by default
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(CompiledSubtotalType.Before);
        });
        it('CustomizeQuery handles missing subtotal settings', function () {
            var objects = {
                general: {
                    totals: undefined
                }
            };
            var dataViewMapping = createCompiledDataViewMapping(objects);
            Table.customizeQuery({
                dataViewMappings: [dataViewMapping]
            });
            // Total should be enabled by default
            var rows = dataViewMapping.table.rows;
            expect(rows.for.in.subtotalType).toEqual(CompiledSubtotalType.Before);
        });
        function createCompiledDataViewMapping(objects) {
            return {
                metadata: {
                    objects: objects
                },
                table: {
                    rows: {
                        for: {
                            in: { role: 'Values', items: [] }
                        }
                    }
                }
            };
        }
    });
    describe('Table hierarchy navigator tests', function () {
        function createNavigator(dataView) {
            return new TableHierarchyNavigator(dataView.table, valueFormatter.formatRaw);
        }
        describe('getDepth', function () {
            var dataView = tableTwoGroupsThreeMeasures;
            var navigator = createNavigator(dataView);
            it('returns 1 for row dimension', function () {
                expect(navigator.getDepth(dataView.table.rows)).toBe(1);
            });
            it('returns 1 for column dimension', function () {
                expect(navigator.getDepth(dataView.table.columns)).toBe(1);
            });
            it('always returns 1', function () {
                expect(navigator.getDepth(null)).toBe(1);
            });
        });
        describe('getLeafCount', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns the row count for row dimension', function () {
                expect(navigator.getLeafCount(dataView.table.rows)).toBe(7);
            });
            it('returns the column count for column dimension', function () {
                expect(navigator.getLeafCount(dataView.table.columns)).toBe(6);
            });
        });
        describe('getLeafAt', function () {
            it('returns the correct leaf from the row dimension', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getLeafAt(rows, 0)).toBe(rows[0]);
                expect(navigator.getLeafAt(rows, 1)).toBe(rows[1]);
                expect(navigator.getLeafAt(rows, 6)).toBe(rows[6]);
            });
            it('returns the correct leaf from the column dimension', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getLeafAt(columns, 0)).toBe(columns[0]);
                expect(navigator.getLeafAt(columns, 1)).toBe(columns[1]);
                expect(navigator.getLeafAt(columns, 5)).toBe(columns[5]);
            });
            it('returns undefined if index is out of bounds in the row dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getLeafAt(rows, 1)).not.toBeDefined();
            });
            it('returns undefined if index is out of bounds in the column dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getLeafAt(columns, 1)).not.toBeDefined();
            });
        });
        describe('getParent', function () {
            var dataView = tableTwoGroupsThreeMeasures;
            var navigator = createNavigator(dataView);
            it('returns null for column header', function () {
                var columns = dataView.table.columns;
                expect(navigator.getParent(columns[0])).toBeNull();
            });
            it('returns null for row', function () {
                var rows = dataView.table.rows;
                expect(navigator.getParent(rows[0])).toBeNull();
            });
            it('returns null in any other cases', function () {
                expect(navigator.getParent(null)).toBeNull();
            });
        });
        describe('getIndex', function () {
            it('returns the correct index for columns', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                var column1 = columns[0];
                var column2 = columns[1];
                var column3 = columns[2];
                var column4 = columns[3];
                var column5 = columns[4];
                var column6 = columns[5];
                expect(navigator.getIndex(column1)).toBe(0);
                expect(navigator.getIndex(column2)).toBe(1);
                expect(navigator.getIndex(column3)).toBe(2);
                expect(navigator.getIndex(column4)).toBe(3);
                expect(navigator.getIndex(column5)).toBe(4);
                expect(navigator.getIndex(column6)).toBe(5);
            });
            it('returns the correct index for rows', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                var row1 = { index: 0, values: rows[0] };
                var row2 = { index: 1, values: rows[1] };
                expect(navigator.getIndex(row1)).toBe(0);
                expect(navigator.getIndex(row2)).toBe(1);
            });
            it('returns -1 if cannot find column in the collection', function () {
                var dataView = tableTwoGroups;
                var navigator = createNavigator(dataView);
                var columnInAnotherTable = tableThreeGroupsThreeMeasuresInterleaved.table.columns[4];
                expect(navigator.getIndex(columnInAnotherTable)).toBe(-1);
            });
            it('returns -1 if it is null', function () {
                var dataView = tableTwoGroups;
                var navigator = createNavigator(dataView);
                expect(navigator.getIndex(null)).toBe(-1);
            });
        });
        describe('isLeaf', function () {
            it('returns true for columns', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                var column1 = columns[0];
                var column2 = columns[1];
                var column3 = columns[2];
                var column4 = columns[3];
                var column5 = columns[4];
                var column6 = columns[5];
                expect(navigator.isLeaf(column1)).toBeTruthy();
                expect(navigator.isLeaf(column2)).toBeTruthy();
                expect(navigator.isLeaf(column3)).toBeTruthy();
                expect(navigator.isLeaf(column4)).toBeTruthy();
                expect(navigator.isLeaf(column5)).toBeTruthy();
                expect(navigator.isLeaf(column6)).toBeTruthy();
            });
            it('returns true for rows', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                var row1 = rows[0];
                var row2 = rows[1];
                var row3 = rows[2];
                var row4 = rows[3];
                var row5 = rows[4];
                var row6 = rows[5];
                var row7 = rows[6];
                expect(navigator.isLeaf(row1)).toBeTruthy();
                expect(navigator.isLeaf(row2)).toBeTruthy();
                expect(navigator.isLeaf(row3)).toBeTruthy();
                expect(navigator.isLeaf(row4)).toBeTruthy();
                expect(navigator.isLeaf(row5)).toBeTruthy();
                expect(navigator.isLeaf(row6)).toBeTruthy();
                expect(navigator.isLeaf(row7)).toBeTruthy();
            });
        });
        describe('getChildren', function () {
            it('returns null for column', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var column = dataView.table.columns[3];
                expect(navigator.getChildren(column)).toBeNull();
            });
            it('returns null for row', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var row = dataView.table.rows[4];
                expect(navigator.getChildren(row)).toBeNull();
            });
        });
        describe('getCount', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns the number of the columns for column dimension', function () {
                expect(navigator.getCount(dataView.table.columns)).toBe(dataView.table.columns.length);
            });
            it('returns the number of the rows for row dimension', function () {
                expect(navigator.getCount(dataView.table.rows)).toBe(dataView.table.rows.length);
            });
        });
        describe('getAt', function () {
            it('returns the correct item from the row dimension', function () {
                var dataView = tableTwoGroupsThreeMeasures;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getAt(rows, 0)).toBe(rows[0]);
                expect(navigator.getAt(rows, 1)).toBe(rows[1]);
                expect(navigator.getAt(rows, 6)).toBe(rows[6]);
            });
            it('returns the correct item from the column dimension', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getAt(columns, 0)).toBe(columns[0]);
                expect(navigator.getAt(columns, 1)).toBe(columns[1]);
                expect(navigator.getAt(columns, 5)).toBe(columns[5]);
            });
            it('returns undefined if index is out of bounds in the row dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var rows = dataView.table.rows;
                expect(navigator.getAt(rows, 1)).not.toBeDefined();
            });
            it('returns undefined if index is out of bounds in the column dimension', function () {
                var dataView = tableOneMeasure;
                var navigator = createNavigator(dataView);
                var columns = dataView.table.columns;
                expect(navigator.getAt(columns, 1)).not.toBeDefined();
            });
        });
        describe('getLevel', function () {
            var dataView = tableThreeGroupsThreeMeasuresInterleaved;
            var navigator = createNavigator(dataView);
            it('returns 0 for column', function () {
                var columns = dataView.table.columns;
                expect(navigator.getLevel(columns[1])).toBe(0);
            });
            it('returns 0 for row', function () {
                var rows = dataView.table.rows;
                expect(navigator.getLevel(rows[5])).toBe(0);
            });
        });
        describe('getIntersection', function () {
            it('returns values in the intersection', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var visualTable = powerbi.visuals.Table.converter(dataView.table);
                var rows = visualTable.visualRows;
                var columns = dataView.table.columns;
                var expectedValues = [
                    ['A', '100.0', 'aa', '101.00', 'aa1', '102'],
                    ['A', '103.0', 'aa', '104.00', 'aa2', '105'],
                    ['A', '106.0', 'ab', '107.00', 'ab1', '108'],
                    ['B', '109.0', 'ba', '110.00', 'ba1', '111'],
                    ['B', '112.0', 'bb', '113.00', 'bb1', '114'],
                    ['B', '115.0', 'bb', '116.00', 'bb2', '117'],
                    ['C', '118.0', 'cc', '119.00', 'cc1', '120']
                ];
                var navigator = new TableHierarchyNavigator(visualTable, valueFormatter.formatRaw);
                validateIntersections(navigator, rows, columns, expectedValues);
            });
            it('returns weburl values', function () {
                var dataView = tableWebUrl;
                var visualTable = powerbi.visuals.Table.converter(dataView.table);
                var rows = visualTable.visualRows;
                var columns = dataView.table.columns;
                var navigator = new TableHierarchyNavigator(visualTable, valueFormatter.formatRaw);
                var result = [];
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columns.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rows[i], columns[j]).showUrl;
                }
                var expectedValues = [
                    [true],
                    [false],
                    [true],
                ];
                expect(result).toEqual(expectedValues);
            });
            function validateIntersections(navigator, rows, columns, expectedValues) {
                var result = [];
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    result[i] = [];
                    for (var j = 0, jlen = columns.length; j < jlen; j++)
                        result[i][j] = navigator.getIntersection(rows[i], columns[j]).value;
                }
                expect(result).toEqual(expectedValues);
            }
        });
        describe('getCorner', function () {
            it('always returns null', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                expect(navigator.getCorner(0, 0)).toBeNull();
                expect(navigator.getCorner(10, 0)).toBeNull();
                expect(navigator.getCorner(0, 10)).toBeNull();
                expect(navigator.getCorner(10, 10)).toBeNull();
            });
        });
        describe('headerItemEquals', function () {
            it('returns true if the two items are the same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var row = dataView.table.rows[0];
                var column = dataView.table.columns[0];
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals(row, row)).toBeTruthy();
                expect(navigator.headerItemEquals(column, column)).toBeTruthy();
            });
            it('returns true for equivalent columns', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals({ displayName: 'a' }, { displayName: 'a' })).toBeTruthy();
            });
            it('returns true for rows with index', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals({ index: 1, values: [] }, { index: 1, values: [] })).toBeTruthy();
            });
            it('returns false if the two items are not same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var row = dataView.table.rows[0];
                var column = dataView.table.columns[0];
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals(row, column)).toBeFalsy();
                expect(navigator.headerItemEquals(column, row)).toBeFalsy();
            });
            it('returns false detects rows with index', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var navigator = createNavigator(dataView);
                expect(navigator.headerItemEquals({ index: 1 }, { index: 2 })).toBeFalsy();
            });
        });
        describe('bodyCellItemEquals', function () {
            it('returns true if the two items are the same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var cell1 = dataView.table.rows[0][3];
                var navigator = createNavigator(dataView);
                expect(navigator.bodyCellItemEquals(cell1, cell1)).toBeTruthy();
            });
            it('returns false if the two items are not same', function () {
                var dataView = tableThreeGroupsThreeMeasuresInterleaved;
                var cell1 = dataView.table.rows[1][3];
                var cell2 = dataView.table.rows[2][3];
                var navigator = createNavigator(dataView);
                expect(navigator.bodyCellItemEquals(cell1, cell2)).toBeFalsy();
            });
        });
    });
    describe('Table logic', function () {
        var v, element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () { return true; };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: true
                }
            });
        });
        it('loadMoreData calls control refresh', function () {
            var nav = { update: function () { } };
            var control = { refresh: function () { }, rowDimension: {}, updateModels: function (resetScrollOffsets, rowModel, columnModel) { } };
            var navSpy = spyOn(nav, "update");
            var controlSpy = spyOn(control, "refresh");
            v['hierarchyNavigator'] = nav;
            v['tablixControl'] = control;
            v.onDataChanged({
                dataViews: [tableOneGroup],
                operationKind: 1 /* Append */
            });
            expect(navSpy).toHaveBeenCalled();
            expect(controlSpy).toHaveBeenCalled();
        });
        it('needsMoreData waitingForData', function () {
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [groupSource1], segment: {} },
                        table: dataViewTableOneGroup
                    }]
            });
            v['waitingForData'] = true;
            var tableVisual = v;
            var lastRow = dataViewTableOneGroup.rows[2];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData segmentComplete', function () {
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [groupSource1] },
                        table: dataViewTableOneGroup
                    }]
            });
            var tableVisual = v;
            var lastRow = dataViewTableOneGroup.rows[2];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData belowThreshold', function () {
            var table = dataViewTableTwoGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [groupSource1, groupSource2], segment: {} },
                        table: table
                    }]
            });
            var tableVisual = v;
            var lastRow = table.rows[3];
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(false);
        });
        it('needsMoreData aboveThreshold', function () {
            var table = dataViewTableTwoGroups;
            v.onDataChanged({
                dataViews: [{
                        metadata: { columns: [groupSource1, groupSource2], segment: {} },
                        table: table
                    }]
            });
            var tableVisual = v;
            var lastRow = { index: 6, values: table.rows[6] };
            var result = tableVisual.needsMoreData(lastRow);
            expect(result).toBe(true);
        });
        it('bindRowHeader callback', function () {
            var callBackCalled = false;
            var binderOptions = {
                onBindRowHeader: function (item) { callBackCalled = true; },
                layoutKind: powerbi.visuals.controls.TablixLayoutKind.Canvas,
            };
            var binder = new powerbi.visuals.TableBinder(binderOptions);
            binder.bindRowHeader({ name: null }, {
                type: null, item: null, colSpan: 0, rowSpan: 0, textAlign: '',
                extension: { setContainerStyle: function () { } }
            });
            expect(callBackCalled).toBe(true);
        });
        it('enumerateObjectInstances empty data view', function () {
            v.onDataChanged({ dataViews: [] });
            // Note: this must not throw an exception
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([]);
        });
        it('enumerateObjectInstances general totals on', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroupSubtotals] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: 'general',
                    properties: {
                        totals: true
                    }
                }]);
        });
        it('enumerateObjectInstances general totals off', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroup] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: 'general',
                    properties: {
                        totals: false
                    }
                }]);
        });
        it('enumerateObjectInstances general no objects', function () {
            var dataView = {
                metadata: {
                    columns: [measureSource1, groupSource1]
                },
                table: {
                    columns: [measureSource1, groupSource1],
                    rows: [
                        [1, 'A'],
                        [2, 'B'],
                        [3, 'C']
                    ],
                    totals: [6, null]
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var objects = v.enumerateObjectInstances({ objectName: 'general' });
            expect(objects).toEqual([{
                    selector: null,
                    objectName: 'general',
                    properties: {
                        totals: true
                    }
                }]);
        });
        it('enumerateObjectInstances some other object', function () {
            v.onDataChanged({ dataViews: [tableOneMeasureOneGroup] });
            var objects = v.enumerateObjectInstances({ objectName: 'some other object' });
            expect(objects).toEqual([]);
        });
        it('RefreshControl invisible parent', function () {
            var control = { refresh: function () { } };
            var controlSpy = spyOn(control, "refresh");
            v['shouldAllowHeaderResize'] = function () { return true; };
            v['hierarchyNavigator'] = { update: function () { } };
            v['tablixControl'] = control;
            v['element']['visible'] = function () { return false; };
            v.onResizing({ width: 100, height: 100 });
            expect(controlSpy).not.toHaveBeenCalled();
        });
        it('RefreshControl invisible parent but dashboard layout', function () {
            var control = { refresh: function () { } };
            var controlSpy = spyOn(control, "refresh");
            v['shouldAllowHeaderResize'] = function () { return true; };
            v['hierarchyNavigator'] = { update: function () { } };
            v['tablixControl'] = control;
            v['element']['visible'] = function () { return false; };
            v['isInteractive'] = false;
            v.onResizing({ width: 100, height: 100 });
            expect(controlSpy).toHaveBeenCalled();
        });
        it('ShouldClearControl noSort', function (done) {
            v.onDataChanged({ dataViews: [tableOneGroup] });
            var refreshSpy = spyOn(v, "refreshControl").and.callFake(function () { });
            v.onDataChanged({ dataViews: [tableOneGroup] });
            setTimeout(function () {
                expect(refreshSpy).toHaveBeenCalledWith(true);
                done();
            }, DefaultWaitForRender);
        });
        it('ShouldClearControl sort', function (done) {
            v.onDataChanged({ dataViews: [tableOneGroup] });
            var refreshSpy = spyOn(v, "refreshControl").and.callFake(function () { });
            v['waitingForSort'] = true;
            v.onDataChanged({ dataViews: [tableOneGroup] });
            setTimeout(function () {
                expect(refreshSpy).toHaveBeenCalledWith(false);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe('Table DOM validation', function () {
        var v, element, NoMarginClass = 'bi-tablix-cellNoMarginStyle', ColumnHeaderClassName = 'bi-table-column-header', RowClassName = 'bi-table-row', LastRowClassName = 'bi-table-last-row', FooterClassName = 'bi-table-footer', NumericCellClassName = ' bi-table-cell-numeric', EmptyHeaderCell = '\xa0';
        beforeEach(function () {
            groupSource1.index = 0;
            groupSource2.index = 1;
            groupSource3.index = 2;
            measureSource1.index = 3;
            measureSource2.index = 4;
            measureSource3.index = 5;
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () { return true; };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: true
                }
            });
        });
        function validateTable(expectedValues) {
            powerbitests.tablixHelper.validateTable(expectedValues, '.bi-tablix tr');
        }
        function validateChildTag(expectedChildTag) {
            var rows = $('.bi-tablix tr');
            var result = [];
            for (var i = 0, ilen = rows.length; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                for (var j = 0, jlen = cells.length; j < jlen; j++) {
                    var childTag = expectedChildTag[i][j];
                    if (childTag) {
                        var child = cells.eq(j).find(childTag);
                        if (child.length > 0)
                            result[i][j] = childTag;
                        else
                            result[i][j] = undefined;
                    }
                    else
                        result[i][j] = undefined;
                }
            }
            expect(result).toEqual(expectedChildTag);
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-tablix tr', NoMarginClass);
        }
        it('1x2 table (one measure)', function (done) {
            var dataView = tableOneMeasure;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue = formatter(dataView.table.rows[0][0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, ''],
                    ['', cellValue]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName + NumericCellClassName, ''],
                    ['', LastRowClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 table (one group null)', function (done) {
            var dataView = tableOneGroupNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    [EmptyHeaderCell, ''],
                    [EmptyHeaderCell, '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x5 table (2 groups 1 measure nulls)', function (done) {
            var dataView = tableTwoGroups1MeasureNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, ''],
                    ['', 'A', 'a1', '100.0'],
                    ['', '', '', '103.0'],
                    ['', '', 'a3', '106.0'],
                    ['', 'B', '', '112.0'],
                    [EmptyHeaderCell, '', '', '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances)', function (done) {
            var dataView = tableOneGroup;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ''],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x8 table (group instances)', function (done) {
            var dataView = tableTwoGroups;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var cellValue6 = formatter(dataView.table.rows[5][0], groupSource1);
                var cellValue7 = formatter(dataView.table.rows[6][0], groupSource1);
                var cellValue8 = formatter(dataView.table.rows[0][1], groupSource2);
                var cellValue9 = formatter(dataView.table.rows[1][1], groupSource2);
                var cellValue10 = formatter(dataView.table.rows[2][1], groupSource2);
                var cellValue11 = formatter(dataView.table.rows[3][1], groupSource2);
                var cellValue12 = formatter(dataView.table.rows[4][1], groupSource2);
                var cellValue13 = formatter(dataView.table.rows[5][1], groupSource2);
                var cellValue14 = formatter(dataView.table.rows[6][1], groupSource2);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, ''],
                    ['', cellValue1, cellValue8],
                    ['', cellValue2, cellValue9],
                    ['', cellValue3, cellValue10],
                    ['', cellValue4, cellValue11],
                    ['', cellValue5, cellValue12],
                    ['', cellValue6, cellValue13],
                    ['', cellValue7, cellValue14]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('5x9 table (group instances and measure values) with totals', function (done) {
            powerbitests.mocks.setLocale();
            var dataView = tableTwoGroupsThreeMeasures;
            measureSource1.index = 2;
            measureSource2.index = 3;
            measureSource3.index = 4;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][2], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][2], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][2], measureSource1);
                var cellValue4 = formatter(dataView.table.rows[3][2], measureSource1);
                var cellValue5 = formatter(dataView.table.rows[4][2], measureSource1);
                var cellValue6 = formatter(dataView.table.rows[5][2], measureSource1);
                var cellValue7 = formatter(dataView.table.rows[6][2], measureSource1);
                var cellValue8 = formatter(dataView.table.rows[0][3], measureSource2);
                var cellValue9 = formatter(dataView.table.rows[1][3], measureSource2);
                var cellValue10 = formatter(dataView.table.rows[2][3], measureSource2);
                var cellValue11 = formatter(dataView.table.rows[3][3], measureSource2);
                var cellValue12 = formatter(dataView.table.rows[4][3], measureSource2);
                var cellValue13 = formatter(dataView.table.rows[5][3], measureSource2);
                var cellValue14 = formatter(dataView.table.rows[6][3], measureSource2);
                var cellValue15 = formatter(dataView.table.rows[0][4], measureSource3);
                var cellValue16 = formatter(dataView.table.rows[1][4], measureSource3);
                var cellValue17 = formatter(dataView.table.rows[2][4], measureSource3);
                var cellValue18 = formatter(dataView.table.rows[3][4], measureSource3);
                var cellValue19 = formatter(dataView.table.rows[4][4], measureSource3);
                var cellValue20 = formatter(dataView.table.rows[5][4], measureSource3);
                var cellValue21 = formatter(dataView.table.rows[6][4], measureSource3);
                var total1 = formatter(dataView.table.totals[2], measureSource1);
                var total2 = formatter(dataView.table.totals[3], measureSource2);
                var total3 = formatter(dataView.table.totals[4], measureSource3);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName, ''],
                    ['', dataView.table.rows[0][0], dataView.table.rows[0][1], cellValue1, cellValue8, cellValue15],
                    ['', dataView.table.rows[1][0], dataView.table.rows[1][1], cellValue2, cellValue9, cellValue16],
                    ['', dataView.table.rows[2][0], dataView.table.rows[2][1], cellValue3, cellValue10, cellValue17],
                    ['', dataView.table.rows[3][0], dataView.table.rows[3][1], cellValue4, cellValue11, cellValue18],
                    ['', dataView.table.rows[4][0], dataView.table.rows[4][1], cellValue5, cellValue12, cellValue19],
                    ['', dataView.table.rows[5][0], dataView.table.rows[5][1], cellValue6, cellValue13, cellValue20],
                    ['', dataView.table.rows[6][0], dataView.table.rows[6][1], cellValue7, cellValue14, cellValue21],
                    ['', 'Total', '', total1, total2, total3, '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName + NumericCellClassName, ''],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', LastRowClassName, LastRowClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName],
                    ['', FooterClassName, FooterClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName, '']
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) with totals, total value comes first', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName, ''],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '', '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName, ''],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', LastRowClassName + NumericCellClassName, LastRowClassName],
                    ['', FooterClassName + NumericCellClassName, FooterClassName, '']
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) totals on then off', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName, ''],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '', '']
                ];
                validateTable(expectedCells);
                // Now update with totals off
                var dataViewNoTotal = tableOneMeasureOneGroup;
                v.onDataChanged({ dataViews: [dataViewNoTotal] });
                setTimeout(function () {
                    var expectedCellsNoTotal = [
                        ['', measureSource1.displayName, groupSource1.displayName, ''],
                        ['', cellValue1, dataViewNoTotal.table.rows[0][1]],
                        ['', cellValue2, dataViewNoTotal.table.rows[1][1]],
                        ['', cellValue3, dataViewNoTotal.table.rows[2][1]]
                    ];
                    validateTable(expectedCellsNoTotal);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances with WebUrl)', function (done) {
            var dataView = tableWebUrl;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSourceWebUrl);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSourceWebUrl);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSourceWebUrl);
                var expectedCells = [
                    ['', groupSourceWebUrl.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ''],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                var expectedChildTags = [
                    [undefined, undefined, undefined],
                    [undefined, 'A'],
                    [undefined, undefined],
                    [undefined, 'A']
                ];
                validateChildTag(expectedChildTags);
                done();
            }, DefaultWaitForRender);
        });
        it('1x1 table loadMoreData', function (done) {
            var dataView = {
                metadata: { columns: [groupSource1], segment: {} },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['A'],
                        ['B'],
                        ['C']
                    ]
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            var segment2 = {
                metadata: { columns: [groupSource1] },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['D'],
                        ['E']
                    ]
                }
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTables(dataView.table, segment2.table);
            v.onDataChanged({
                dataViews: [dataView],
                operationKind: 1 /* Append */
            });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName, ''],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3],
                    ['', cellValue4],
                    ['', cellValue5]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table reorder loadMoreData', function (done) {
            var dataView = {
                metadata: { columns: [groupSource1, groupSource2], segment: {} },
                table: {
                    columns: [groupSource1, groupSource2],
                    rows: [
                        ['A', '1'],
                        ['B', '2'],
                        ['C', '3']
                    ]
                }
            };
            v.onDataChanged({
                dataViews: [dataView]
            });
            // Simulate column reordering
            var transformedDataView = applyTransform(dataView);
            v.onDataChanged({ dataViews: [transformedDataView] });
            var segment2 = {
                metadata: { columns: [groupSource1] },
                table: {
                    columns: [groupSource1],
                    rows: [
                        ['D', '4'],
                        ['E', '5']
                    ]
                }
            };
            // Simulate a load more merge
            powerbi.data.segmentation.DataViewMerger.mergeTables(dataView.table, segment2.table);
            var transformedDataView = applyTransform(dataView);
            v.onDataChanged({
                dataViews: [transformedDataView],
                operationKind: 1 /* Append */
            });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource2.displayName, groupSource1.displayName, ''],
                    ['', '1', 'A'],
                    ['', '2', 'B'],
                    ['', '3', 'C'],
                    ['', '4', 'D'],
                    ['', '5', 'E']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        function applyTransform(dataView) {
            var transforms = {
                selects: [
                    {
                        displayName: groupSource1.displayName,
                        type: powerbi.ValueType.fromDescriptor({ text: true }),
                    }, {
                        displayName: groupSource2.displayName,
                        type: powerbi.ValueType.fromDescriptor({ text: true }),
                    }
                ],
                projectionOrdering: {
                    Values: [1, 0]
                }
            };
            var transformedDataView = powerbi.data.DataViewTransform.apply({
                prototype: dataView,
                objectDescriptors: null,
                transforms: transforms,
                dataViewMappings: powerbi.visuals.Table.capabilities.dataViewMappings,
                colorAllocatorFactory: powerbi.visuals.createColorAllocatorFactory()
            })[0];
            return transformedDataView;
        }
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Table.formatStringProp, false));
        }
    });
    describe('Dashboard table DOM validation', function () {
        var v, element, NoMarginClass = 'bi-tablix-cellNoMarginStyle', ColumnHeaderClassName = 'bi-table-column-header', RowClassName = 'bi-table-row', LastRowClassName = 'bi-table-last-row', FooterClassName = 'bi-table-footer', NumericCellClassName = ' bi-table-cell-numeric', EmptyHeaderCell = '\xa0';
        beforeEach(function () {
            groupSource1.index = 0;
            groupSource2.index = 1;
            groupSource3.index = 2;
            measureSource1.index = 3;
            measureSource2.index = 4;
            measureSource3.index = 5;
        });
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            element['visible'] = function () { return false; };
            v = webPluginService.getPlugin('table').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: {
                    selection: null
                }
            });
        });
        function validateTable(expectedValues) {
            powerbitests.tablixHelper.validateTable(expectedValues, '.bi-dashboard-tablix tr');
        }
        function validateChildTag(expectedChildTag) {
            var rows = $('.bi-dashboard-tablix tr');
            var result = [];
            for (var i = 0, ilen = rows.length; i < ilen; i++) {
                result[i] = [];
                var cells = rows.eq(i).find('td');
                for (var j = 0, jlen = cells.length; j < jlen; j++) {
                    var childTag = expectedChildTag[i][j];
                    if (childTag) {
                        var child = cells.eq(j).find(childTag);
                        if (child.length > 0)
                            result[i][j] = childTag;
                        else
                            result[i][j] = undefined;
                    }
                    else
                        result[i][j] = undefined;
                }
            }
            expect(result).toEqual(expectedChildTag);
        }
        function validateClassNames(expectedValues) {
            powerbitests.tablixHelper.validateClassNames(expectedValues, '.bi-dashboard-tablix tr', NoMarginClass);
        }
        it('1x2 table (one measure)', function (done) {
            var dataView = tableOneMeasure;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue = formatter(dataView.table.rows[0][0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName],
                    ['', cellValue]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName + NumericCellClassName],
                    ['', LastRowClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('1x2 table (one group null)', function (done) {
            var dataView = tableOneGroupNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName],
                    [EmptyHeaderCell, ''],
                    [EmptyHeaderCell, '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('3x5 table (2 groups 1 measure nulls)', function (done) {
            var dataView = tableTwoGroups1MeasureNulls;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName],
                    ['', 'A', 'a1', '100.0'],
                    ['', '', '', '103.0'],
                    ['', '', 'a3', '106.0'],
                    ['', 'B', '', '112.0'],
                    [EmptyHeaderCell, '', '', '']
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances)', function (done) {
            var dataView = tableOneGroup;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var expectedCells = [
                    ['', groupSource1.displayName],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x8 table (group instances)', function (done) {
            var dataView = tableTwoGroups;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSource1);
                var cellValue4 = formatter(dataView.table.rows[3][0], groupSource1);
                var cellValue5 = formatter(dataView.table.rows[4][0], groupSource1);
                var cellValue6 = formatter(dataView.table.rows[5][0], groupSource1);
                var cellValue7 = formatter(dataView.table.rows[6][0], groupSource1);
                var cellValue8 = formatter(dataView.table.rows[0][1], groupSource2);
                var cellValue9 = formatter(dataView.table.rows[1][1], groupSource2);
                var cellValue10 = formatter(dataView.table.rows[2][1], groupSource2);
                var cellValue11 = formatter(dataView.table.rows[3][1], groupSource2);
                var cellValue12 = formatter(dataView.table.rows[4][1], groupSource2);
                var cellValue13 = formatter(dataView.table.rows[5][1], groupSource2);
                var cellValue14 = formatter(dataView.table.rows[6][1], groupSource2);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName],
                    ['', cellValue1, cellValue8],
                    ['', cellValue2, cellValue9],
                    ['', cellValue3, cellValue10],
                    ['', cellValue4, cellValue11],
                    ['', cellValue5, cellValue12],
                    ['', cellValue6, cellValue13],
                    ['', cellValue7, cellValue14]
                ];
                validateTable(expectedCells);
                done();
            }, DefaultWaitForRender);
        });
        it('5x9 table (group instances and measure values) with totals', function (done) {
            var dataView = tableTwoGroupsThreeMeasures;
            measureSource1.index = 2;
            measureSource2.index = 3;
            measureSource3.index = 4;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][2], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][2], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][2], measureSource1);
                var cellValue4 = formatter(dataView.table.rows[3][2], measureSource1);
                var cellValue5 = formatter(dataView.table.rows[4][2], measureSource1);
                var cellValue6 = formatter(dataView.table.rows[5][2], measureSource1);
                var cellValue7 = formatter(dataView.table.rows[6][2], measureSource1);
                var cellValue8 = formatter(dataView.table.rows[0][3], measureSource2);
                var cellValue9 = formatter(dataView.table.rows[1][3], measureSource2);
                var cellValue10 = formatter(dataView.table.rows[2][3], measureSource2);
                var cellValue11 = formatter(dataView.table.rows[3][3], measureSource2);
                var cellValue12 = formatter(dataView.table.rows[4][3], measureSource2);
                var cellValue13 = formatter(dataView.table.rows[5][3], measureSource2);
                var cellValue14 = formatter(dataView.table.rows[6][3], measureSource2);
                var cellValue15 = formatter(dataView.table.rows[0][4], measureSource3);
                var cellValue16 = formatter(dataView.table.rows[1][4], measureSource3);
                var cellValue17 = formatter(dataView.table.rows[2][4], measureSource3);
                var cellValue18 = formatter(dataView.table.rows[3][4], measureSource3);
                var cellValue19 = formatter(dataView.table.rows[4][4], measureSource3);
                var cellValue20 = formatter(dataView.table.rows[5][4], measureSource3);
                var cellValue21 = formatter(dataView.table.rows[6][4], measureSource3);
                var total1 = formatter(dataView.table.totals[2], measureSource1);
                var total2 = formatter(dataView.table.totals[3], measureSource2);
                var total3 = formatter(dataView.table.totals[4], measureSource3);
                var expectedCells = [
                    ['', groupSource1.displayName, groupSource2.displayName, measureSource1.displayName, measureSource2.displayName, measureSource3.displayName],
                    ['', dataView.table.rows[0][0], dataView.table.rows[0][1], cellValue1, cellValue8, cellValue15],
                    ['', dataView.table.rows[1][0], dataView.table.rows[1][1], cellValue2, cellValue9, cellValue16],
                    ['', dataView.table.rows[2][0], dataView.table.rows[2][1], cellValue3, cellValue10, cellValue17],
                    ['', dataView.table.rows[3][0], dataView.table.rows[3][1], cellValue4, cellValue11, cellValue18],
                    ['', dataView.table.rows[4][0], dataView.table.rows[4][1], cellValue5, cellValue12, cellValue19],
                    ['', dataView.table.rows[5][0], dataView.table.rows[5][1], cellValue6, cellValue13, cellValue20],
                    ['', dataView.table.rows[6][0], dataView.table.rows[6][1], cellValue7, cellValue14, cellValue21],
                    ['', 'Total', '', total1, total2, total3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName, ColumnHeaderClassName, ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', RowClassName, RowClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName, RowClassName + NumericCellClassName],
                    ['', LastRowClassName, LastRowClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName, LastRowClassName + NumericCellClassName],
                    ['', FooterClassName, FooterClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName, FooterClassName + NumericCellClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) with totals, total value comes first', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '']
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName + NumericCellClassName, ColumnHeaderClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', RowClassName + NumericCellClassName, RowClassName],
                    ['', LastRowClassName + NumericCellClassName, LastRowClassName],
                    ['', FooterClassName + NumericCellClassName, FooterClassName]
                ];
                validateClassNames(expectedClassNames);
                done();
            }, DefaultWaitForRender);
        });
        it('2x5 table (group instances and measure values) totals on then off', function (done) {
            var dataView = tableOneMeasureOneGroupSubtotals;
            measureSource1.index = 0;
            groupSource1.index = 1;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], measureSource1);
                var cellValue2 = formatter(dataView.table.rows[1][0], measureSource1);
                var cellValue3 = formatter(dataView.table.rows[2][0], measureSource1);
                var total = formatter(dataView.table.totals[0], measureSource1);
                var expectedCells = [
                    ['', measureSource1.displayName, groupSource1.displayName],
                    ['', cellValue1, dataView.table.rows[0][1]],
                    ['', cellValue2, dataView.table.rows[1][1]],
                    ['', cellValue3, dataView.table.rows[2][1]],
                    ['', total, '']
                ];
                validateTable(expectedCells);
                // Now update with totals off
                var dataViewNoTotal = tableOneMeasureOneGroup;
                v.onDataChanged({ dataViews: [dataViewNoTotal] });
                setTimeout(function () {
                    var expectedCellsNoTotal = [
                        ['', measureSource1.displayName, groupSource1.displayName],
                        ['', cellValue1, dataViewNoTotal.table.rows[0][1]],
                        ['', cellValue2, dataViewNoTotal.table.rows[1][1]],
                        ['', cellValue3, dataViewNoTotal.table.rows[2][1]]
                    ];
                    validateTable(expectedCellsNoTotal);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('1x3 table (group instances with WebUrl)', function (done) {
            var dataView = tableWebUrl;
            v.onDataChanged({ dataViews: [dataView] });
            setTimeout(function () {
                var cellValue1 = formatter(dataView.table.rows[0][0], groupSourceWebUrl);
                var cellValue2 = formatter(dataView.table.rows[1][0], groupSourceWebUrl);
                var cellValue3 = formatter(dataView.table.rows[2][0], groupSourceWebUrl);
                var expectedCells = [
                    ['', groupSourceWebUrl.displayName],
                    ['', cellValue1],
                    ['', cellValue2],
                    ['', cellValue3]
                ];
                validateTable(expectedCells);
                var expectedClassNames = [
                    ['', ColumnHeaderClassName],
                    ['', RowClassName],
                    ['', RowClassName],
                    ['', LastRowClassName]
                ];
                validateClassNames(expectedClassNames);
                var expectedChildTags = [
                    [undefined, undefined],
                    [undefined, 'A'],
                    [undefined, undefined],
                    [undefined, 'A']
                ];
                validateChildTag(expectedChildTags);
                done();
            }, DefaultWaitForRender);
        });
        function formatter(value, source) {
            return valueFormatter.formatRaw(value, valueFormatter.getFormatString(source, Table.formatStringProp, false));
        }
    });
    describe("Table sort validation", function () {
        var element;
        beforeEach(function (done) {
            element = powerbitests.helpers.testDom('800', '800');
            element['visible'] = function () { return true; };
            done();
        });
        it('table with single measure', function (done) {
            // Clicking on the measure will result in a sort event
            var data = tableOneMeasure;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "measure1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }];
            var expectedSorts = [
                [{ queryName: "measure1" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with single group', function (done) {
            // Clicking on the group header multiple times will result in multiple sort events.
            // Clicking on non-header cells will not result in sort events.
            var data = tableOneGroup;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }];
            var clicks = [{ row: 0, col: 1 }, { row: 1, col: 1 }, { row: 2, col: 1 }, { row: 0, col: 1 }];
            var expectedSorts = [
                [{ queryName: "group1" }], [{ queryName: "group1" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with two groups', function (done) {
            // Clicking on different group headers multiple times results in a sort event for each click
            var data = tableTwoGroups;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }, { row: 0, col: 2, expectedText: "group2" }];
            var clicks = [{ row: 0, col: 1 }, { row: 0, col: 2 }, { row: 0, col: 1 }, { row: 0, col: 2 }];
            var expectedSorts = [
                [{ queryName: "group1" }], [{ queryName: "group2" }], [{ queryName: "group1" }], [{ queryName: "group2" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
        it('table with two groups and three measures', function (done) {
            // Clicking on different group headers multiple times results in a sort event for each click
            var data = tableTwoGroupsThreeMeasures;
            var expectedColumnHeaders = [{ row: 0, col: 1, expectedText: "group1" }, { row: 0, col: 2, expectedText: "group2" }, { row: 0, col: 3, expectedText: "measure1" }, { row: 0, col: 4, expectedText: "measure2" }, { row: 0, col: 5, expectedText: "measure3" }];
            var clicks = [{ row: 0, col: 5 }, { row: 0, col: 2 }, { row: 0, col: 4 }, { row: 0, col: 1 }, { row: 0, col: 3 }, { row: 0, col: 1 }, { row: 0, col: 5 }];
            var expectedSorts = [
                [{ queryName: "measure3" }], [{ queryName: "group2" }], [{ queryName: "measure2" }], [{ queryName: "group1" }], [{ queryName: "measure1" }], [{ queryName: "group1" }], [{ queryName: "measure3" }]
            ];
            powerbitests.tablixHelper.runTablixSortTest(element, done, 'table', data, expectedColumnHeaders, clicks, expectedSorts);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var TooltipBuilder = powerbi.visuals.TooltipBuilder;
    var TooltipManager = powerbi.visuals.TooltipManager;
    var ValueType = powerbi.ValueType;
    var SVGUtil = powerbi.visuals.SVGUtil;
    powerbitests.mocks.setLocale();
    describe("Tooltip", function () {
        it('Tooltip instance created', function () {
            expect(TooltipManager.ToolTipInstance).toBeDefined();
        });
        it('Tooltip has localization options defined', function () {
            expect(powerbi.visuals.ToolTipComponent.localizationOptions).toBeDefined();
        });
    });
    describe("Tooltip DOM tests", function () {
        var element;
        var d3Element;
        var tooltipInfo;
        //var timerCallback: jasmine.Spy;
        beforeEach(function () {
            //timerCallback = jasmine.createSpy("timerCallback");
            //jasmine.clock().install();
            createDomElement();
        });
        afterEach(function () {
            //jasmine.clock().uninstall();
        });
        it('DOM container exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer.length).toBe(1);
        });
        it('Has single instance of DOM container', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Show
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer.length).toBe(1);
        });
        it('DOM two rows exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipRow = $('.tooltip-row');
            expect(tooltipRow.length).toBe(2);
        });
        it('DOM two title cells exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipTitle = $('.tooltip-title-cell');
            expect(tooltipTitle.length).toBe(2);
        });
        it('DOM two value cells exist', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipValue = $('.tooltip-value-cell');
            expect(tooltipValue.length).toBe(2);
        });
        it('DOM content container exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContentContainer = $('.tooltip-content-container');
            expect(tooltipContentContainer.length).toBe(1);
        });
        it('DOM container visible', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            expect(tooltipContainer).toBeVisible();
        });
        it('DOM container is visible - Show ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainerVisibility = $('.tooltip-container');
            expect(tooltipContainerVisibility).toBeVisible();
        });
        it('DOM container style Opacity is 1 - Show ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            powerbi.visuals.SVGUtil.flushAllD3Transitions();
            var tooltipContainerOpacity = $('.tooltip-container').css('opacity');
            expect(tooltipContainerOpacity).toBeCloseTo(1, 2);
        });
        it('DOM container hiden - Hide ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            var tooltipContainer = $('.tooltip-container');
            var visibility = tooltipContainer.css("visibility");
            expect("hidden").toBe(visibility);
        });
        it('DOM container style Opacity is 1 - Hide ToolTip', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            // Hide
            hideTooltip();
            var tooltipContainerOpacity = $('.tooltip-container').css('opacity');
            expect(tooltipContainerOpacity).toBe('0');
        });
        it('DOM arrow exists', function () {
            // Show tooltip
            var clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var tooltipContainer = $('.tooltip-container');
            var arrow = tooltipContainer.find('.arrow');
            expect(arrow.length).toBe(1);
        });
        it('DOM arrow position test', function () {
            var clickedArea;
            // Set test screen size
            TooltipManager.ToolTipInstance.setTestScreenSize(1000, 700);
            // Show tooltip at top left of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(200, 200, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            var arrowClass;
            var tooltipContainer = $('.tooltip-container');
            var arrow = tooltipContainer.find('.arrow');
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow top left');
            // Hide
            hideTooltip();
            // Show tooltip at top right of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(600, 100, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow top right');
            // Hide
            hideTooltip();
            // Show tooltip at bottom left of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(300, 500, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow bottom left');
            // Hide
            hideTooltip();
            // Show tooltip at bottom right of the screen
            clickedArea = new powerbi.visuals.controls.TouchUtils.Rectangle(700, 800, 0, 0);
            TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
            arrowClass = arrow.attr('class');
            expect(arrowClass).toBe('arrow bottom right');
            // Hide
            hideTooltip();
            // Reset test screen size
            TooltipManager.ToolTipInstance.setTestScreenSize(null, null);
        });
        it("Should invoke mouseover event.", function () {
            var spyEvent = spyOnEvent('#item', 'mouseover');
            hideTooltip();
            emulateShowTooltip();
            expect('mouseover').toHaveBeenTriggeredOn('#item');
            expect(spyEvent).toHaveBeenTriggered();
        });
        it("Touch click should ignore immediate mouseover event.", function (done) {
            hideTooltip();
            emulateTouchClick();
            emulateShowTooltip();
            setTimeout(function () {
                var visibility = getTooltipVisibility();
                expect(visibility).toEqual('hidden');
                done();
            }, 513);
        });
        it('tooltip is visible after 200ms', function (done) {
            hideTooltip();
            var tooltipEvent = getMockTooltipEvent();
            TooltipManager.showDelayedTooltip(tooltipEvent, getMockTooltipData, 500);
            setTimeout(function () {
                var visibility = getTooltipVisibility();
                expect(visibility).toEqual('hidden');
                done();
            }, 200);
        });
        it('tooltip is visible after 500ms', function (done) {
            hideTooltip();
            var tooltipEvent = getMockTooltipEvent();
            TooltipManager.showDelayedTooltip(tooltipEvent, getMockTooltipData, 500);
            setTimeout(function () {
                var visibility = getTooltipVisibility();
                expect(visibility).toEqual('visible');
                done();
            }, 513);
        });
        function getMockTooltipEvent() {
            return {
                data: null,
                index: 0,
                coordinates: [10, 10],
                elementCoordinates: [2, 2],
                context: this,
                isTouchEvent: false
            };
        }
        function getMockTooltipData(tooltipEvent) {
            return [
                { displayName: "test 1", value: "111" },
                { displayName: "test 2", value: "222" }
            ];
        }
        function emulateShowTooltip() {
            // Fire mouseover event
            var evt = document.createEvent("MouseEvents");
            evt.initMouseEvent("mouseover", true, true, window, 1, 2, 2, 2, 2, false, false, false, false, 0, null);
            d3Element.node().dispatchEvent(evt);
        }
        function emulateTouchClick() {
            // Simulate a touch event using 'touchstart' and 'touchend'
            var evt = document.createEvent("TouchEvent");
            evt.initEvent("touchstart", true, true);
            evt.eventName = "touchstart";
            d3Element.node().dispatchEvent(evt);
            var evt2 = document.createEvent("TouchEvent");
            evt2.initEvent("touchend", true, true);
            evt2.eventName = "touchend";
            d3Element.node().dispatchEvent(evt2);
        }
        function getTooltipVisibility() {
            var tooltipContainer = $('.tooltip-container');
            return tooltipContainer.length > 0 ? tooltipContainer.css("visibility") : "hidden";
        }
        function hideTooltip() {
            TooltipManager.ToolTipInstance.hide();
            SVGUtil.flushAllD3Transitions();
        }
        function createDomElement() {
            if (element) {
                // remove existing one
                element.remove();
            }
            element = powerbitests.helpers.testDom('500', '500');
            d3Element = d3.select("#" + element.attr("id"));
            tooltipInfo = [
                { displayName: "test 1", value: "111" },
                { displayName: "test 2", value: "222" }
            ];
            TooltipManager.addTooltip(d3Element, getMockTooltipData);
        }
    });
    describe("Tooltip Builder tests", function () {
        it('createTooltipInfo: category & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                }, {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true })
                },
            ];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
                powerbitests.mocks.dataViewScopeIdentity("ghi")];
            var dataView = {
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                            source: columns[0],
                            values: ['abc', 'def', 'ghi'],
                            identity: categoryIdentities,
                            identityFields: [],
                        }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[1],
                            values: [123.321, 234.789, 456.001],
                        }])
                }
            };
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321, [{ value: 123.321, metadata: dataView.categorical.values[0] }], 0);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'val', value: '123.321' }]);
        });
        it('createTooltipInfo: category, series & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                }, {
                    displayName: 'ser',
                    type: ValueType.fromDescriptor({ text: true }),
                }, {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true }),
                    groupName: 'ser1',
                },
            ];
            var dataView = {
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                            source: columns[0],
                            values: ['abc', 'def'],
                            identity: [powerbitests.mocks.dataViewScopeIdentity("abc"), powerbitests.mocks.dataViewScopeIdentity("def")],
                        }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[2],
                            values: [123, 234],
                            identity: powerbitests.mocks.dataViewScopeIdentity("ABC"),
                        }, {
                            source: columns[2],
                            values: [345, 456],
                            identity: powerbitests.mocks.dataViewScopeIdentity("DEF"),
                        }], undefined, columns[1])
                }
            };
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321, [{ value: 123.321, metadata: dataView.categorical.values[0] }], 0);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'ser', value: 'ser1' },
                { displayName: 'val', value: '123.321' }]);
        });
        it('createTooltipInfo: self cross-joined category & measure', function () {
            var columns = [
                {
                    displayName: 'cat',
                    type: ValueType.fromDescriptor({ text: true })
                }, {
                    displayName: 'val',
                    isMeasure: true,
                    type: ValueType.fromDescriptor({ numeric: true })
                },
            ];
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("abc"),
                powerbitests.mocks.dataViewScopeIdentity("def"),
                powerbitests.mocks.dataViewScopeIdentity("ghi")];
            var dataView = powerbi.data.DataViewSelfCrossJoin.apply({
                metadata: { columns: columns },
                categorical: {
                    categories: [{
                            source: columns[0],
                            values: ['abc', 'def', 'ghi'],
                            identity: categoryIdentities,
                            identityFields: [],
                        }],
                    values: powerbi.data.DataViewTransform.createValueColumns([
                        {
                            source: columns[1],
                            values: [123.321, 234.789, 456.001],
                        }])
                }
            });
            var tooltipInfo = TooltipBuilder.createTooltipInfo(null, dataView.categorical.categories, 'abc', dataView.categorical.values, 123.321);
            expect(tooltipInfo).toEqual([
                { displayName: 'cat', value: 'abc' },
                { displayName: 'val', value: '123.321' }]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var CssConstants = jsCommon.CssConstants;
    var data = powerbi.data;
    var DataViewAnalysis = powerbi.DataViewAnalysis;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var QueryProjectionCollection = powerbi.data.QueryProjectionCollection;
    var SQExprBuilder = powerbi.data.SQExprBuilder;
    var Treemap = powerbi.visuals.Treemap;
    var SelectionId = powerbi.visuals.SelectionId;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var dataTypeNumber = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
    var dataTypeString = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text);
    var DefaultWaitForRender = 500;
    powerbitests.mocks.setLocale();
    var dataViewMetadataCategorySeriesColumns = {
        columns: [
            { displayName: 'Squad', queryName: 'select0', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
            { displayName: 'Period', queryName: 'select1', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: null, queryName: 'select2', groupName: '201501', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: null, queryName: 'select2', groupName: '201502', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: null, queryName: 'select2', groupName: '201503', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
        ]
    };
    var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Squad' });
    var seriesColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: 's', entity: 'e', column: 'Period' });
    var dataViewMetadataCategoryColumn = {
        columns: [
            { displayName: 'Genre', queryName: 'select0', properties: { "Category": true }, type: dataTypeString },
            { displayName: 'TotalSales', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: dataTypeNumber }
        ]
    };
    var dataViewMetadataCategoryColumnAndLongText = {
        columns: [
            { displayName: 'Category group', queryName: 'select0', properties: { "Category": true }, type: dataTypeString },
            { displayName: 'Measure with long name', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: dataTypeNumber },
            { displayName: 'Measure', queryName: 'select2', isMeasure: true, properties: { "Values": true }, type: dataTypeNumber }
        ]
    };
    var dataViewMetadataCategoryAndMeasures = {
        columns: [
            { displayName: 'Area', queryName: 'select0', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
            { displayName: 'BugsFiled', queryName: 'select1', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
            { displayName: 'BugsFixed', queryName: 'select2', isMeasure: true, properties: { "Values": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
        ]
    };
    describe("Treemap", function () {
        var categoryColumn = { displayName: 'year', queryName: 'select0', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
        var measureColumn = { displayName: 'sales', queryName: 'select1', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) };
        it('Treemap registered capabilities', function () {
            expect(powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').capabilities).toBe(powerbi.visuals.treemapCapabilities);
        });
        it('Capabilities should include dataViewMappings', function () {
            expect(powerbi.visuals.treemapCapabilities.dataViewMappings).toBeDefined();
        });
        it('Capabilities should include dataRoles', function () {
            expect(powerbi.visuals.treemapCapabilities.dataRoles).toBeDefined();
        });
        it('Capabilities should include objects', function () {
            expect(powerbi.visuals.treemapCapabilities.objects).toBeDefined();
        });
        it('Capabilities should include implicitSort', function () {
            expect(powerbi.visuals.treemapCapabilities.sorting.implicit).toBeDefined();
        });
        it('FormatString property should match calculated', function () {
            expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.treemapCapabilities.objects)).toEqual(powerbi.visuals.treemapProps.general.formatString);
        });
        it('preferred capability does not support zero rows', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: categoryColumn,
                            values: []
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            values: []
                        }]),
                }
            };
            expect(DataViewAnalysis.supports(dataView, powerbi.visuals.treemapCapabilities.dataViewMappings[0], true))
                .toBe(false);
        });
        it('preferred capability does not support one row', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'Year' },
                    { displayName: 'Value', isMeasure: true }],
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: categoryColumn,
                            values: [2012, 2013]
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: measureColumn,
                            values: [200]
                        }]),
                }
            };
            expect(DataViewAnalysis.supports(dataView, powerbi.visuals.treemapCapabilities.dataViewMappings[0], true))
                .toBe(false);
        });
        it('Capabilities should only allow one measure if there are group and detail', function () {
            var allowedProjections = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }]),
                'Details': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([{ queryRef: '2' }]),
            };
            var disallowedProjections1 = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }]),
                'Details': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: '2' },
                    { queryRef: '3' }
                ])
            };
            var disallowedProjections2 = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }]),
                'Details': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: '2' },
                    { queryRef: '3' },
                    { queryRef: '4' }
                ])
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
        });
        it('Capabilities should only allow one measure if is a detail group', function () {
            var allowedProjections = {
                'Details': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([{ queryRef: '0' }]),
            };
            var disallowedProjections = {
                'Details': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: '2' },
                    { queryRef: '0' }
                ]),
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections, dataViewMappings)).toBe(null);
        });
        it('Capabilities should allow multiple measures if there is no detail group', function () {
            var allowedProjections1 = {
                'Group': new QueryProjectionCollection([{ queryRef: '2' }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: '1' },
                    { queryRef: '0' }
                ])
            };
            var allowedProjections2 = {
                'Group': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([
                    { queryRef: '2' },
                    { queryRef: '0' },
                    { queryRef: '3' }
                ]),
            };
            var allowedProjections3 = {
                'Group': new QueryProjectionCollection([{ queryRef: '1' }]),
                'Values': new QueryProjectionCollection([{ queryRef: '0' }]),
            };
            var allowedProjections4 = {
                'Values': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]),
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
        it('Capabilities should not allow multiple category groups', function () {
            var disallowedProjections1 = {
                'Group': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]),
            };
            var disallowedProjections2 = {
                'Group': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]),
                'Values': new QueryProjectionCollection([{ queryRef: '2' }]),
            };
            var disallowedProjections3 = {
                'Group': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]),
                'Details': new QueryProjectionCollection([{ queryRef: '2' }]),
                'Values': new QueryProjectionCollection([{ queryRef: '3' }]),
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections3, dataViewMappings)).toBe(null);
        });
        it('Capabilities should not allow multiple detail groups', function () {
            var disallowedProjections1 = {
                'Details': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ])
            };
            var disallowedProjections2 = {
                'Details': new QueryProjectionCollection([
                    { queryRef: '0' },
                    { queryRef: '1' }
                ]),
                'Values': new QueryProjectionCollection([{ queryRef: '2' }])
            };
            var disallowedProjections3 = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }]),
                'Details': new QueryProjectionCollection([
                    { queryRef: '1' },
                    { queryRef: '2' }
                ]),
                'Values': new QueryProjectionCollection([{ queryRef: '3' }]),
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections1, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections2, dataViewMappings)).toBe(null);
            expect(DataViewAnalysis.chooseDataViewMappings(disallowedProjections3, dataViewMappings)).toBe(null);
        });
        it('Capabilities should allow one category and/or one detail groups', function () {
            var allowedProjections1 = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }])
            };
            var allowedProjections2 = {
                'Detail': new QueryProjectionCollection([{ queryRef: '0' }])
            };
            var allowedProjections3 = {
                'Group': new QueryProjectionCollection([{ queryRef: '0' }]),
                'Detail': new QueryProjectionCollection([{ queryRef: '1' }]),
            };
            var allowedProjections4 = {
                'Values': new QueryProjectionCollection([{ queryRef: '0' }]),
            };
            var dataViewMappings = powerbi.visuals.treemapCapabilities.dataViewMappings;
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections1, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections2, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections3, dataViewMappings)).toEqual(dataViewMappings);
            expect(DataViewAnalysis.chooseDataViewMappings(allowedProjections4, dataViewMappings)).toEqual(dataViewMappings);
        });
    });
    describe("treemap data labels validation", function () {
        var v, element;
        var hostServices;
        beforeEach(function () {
            hostServices = powerbitests.mocks.createVisualHostServices();
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('NaN in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([NaN, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('NaNNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Negative Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([Number.NEGATIVE_INFINITY, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('InfinityValuesNotSupported');
                done();
            }, DefaultWaitForRender);
        });
        it('Positive Infinity in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([Number.POSITIVE_INFINITY, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                done();
            }, DefaultWaitForRender);
        });
        it('Out of range value in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([1e301, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(warningSpy.calls.argsFor(0)[0][0].code).toBe('GeometryCulledWarning');
                done();
            }, DefaultWaitForRender);
        });
        it('All okay in values shows a warning', function (done) {
            var warningSpy = jasmine.createSpy('warning');
            hostServices.setWarnings = warningSpy;
            var dataChangedOptions = getOptionsForValueWarnings([300, 120]);
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect(warningSpy).not.toHaveBeenCalled();
                done();
            }, DefaultWaitForRender);
        });
        function getOptionsForValueWarnings(values) {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef]
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: values,
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }], [seriesColumnRef], dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            return dataChangedOptions;
        }
        it('labels should be visible by default', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef]
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], [seriesColumnRef], dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').css('opacity')).toBe('1');
                expect($('.treemap .labels .majorLabel').css('opacity')).toBe('1');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should be visible', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: { show: true },
                categoryLabels: { show: true }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').css('opacity')).toBe('1');
                expect($('.treemap .labels .majorLabel').css('opacity')).toBe('1');
                done();
            }, DefaultWaitForRender);
        });
        it('labels should be hidden', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: { show: false },
                categoryLabels: { show: false }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .minorLabel').length).toEqual(0);
                expect($('.treemap .labels .majorLabel').length).toEqual(0);
                done();
            }, DefaultWaitForRender);
        });
        it('only category labels should be visible', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: { show: false },
                categoryLabels: { show: true }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.treemap .labels .majorLabel').length).toEqual(0);
                expect($('.treemap .labels .minorLabel').length).toEqual(6);
                done();
            }, DefaultWaitForRender);
        });
        it('hidden labels with highlights dom validation', function (done) {
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: { show: false },
                categoryLabels: { show: false }
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("Drama"),
                powerbitests.mocks.dataViewScopeIdentity("Comedy"),
                powerbitests.mocks.dataViewScopeIdentity("Documentary"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[1],
                                    values: [110, 120, 130],
                                    highlights: [60, 80, 20]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .labels .majorLabel').length).toBe(0);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('labels color should changed from settings', function (done) {
            var colorRgb = 'rgb(120,110,100)';
            dataViewMetadataCategorySeriesColumns.objects = {
                labels: {
                    color: { solid: { color: colorRgb } },
                    show: true,
                },
                categoryLabels: { show: true }
            };
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var minorActualColor = $('.treemap .labels .minorLabel').css('fill').replace(/\ /g, "");
                var majorActualColor = $('.treemap .labels .majorLabel').css('fill').replace(/\ /g, "");
                //convert the actual color to rgb format if target browser returns hex format
                minorActualColor = (minorActualColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(minorActualColor)) : minorActualColor;
                majorActualColor = (majorActualColor[0] === '#') ? jsCommon.color.rgbString(jsCommon.color.parseRgb(majorActualColor)) : majorActualColor;
                expect(minorActualColor).toBe(colorRgb);
                expect(majorActualColor).toBe(colorRgb);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("Enumerate Objects", function () {
        var v, element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('Check basic enumeration', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                var points = v.enumerateObjectInstances({ objectName: 'dataPoint' });
                expect(points.length).toBe(2);
                expect(points[0].displayName).toEqual('The Nuthatches');
                expect(points[0].properties['fill']).toBeDefined();
                expect(points[1].displayName).toEqual('Skylarks');
                expect(points[1].properties['fill']).toBeDefined();
                done();
            }, DefaultWaitForRender);
        });
    });
    function treemapDomValidation(hasLegendObject) {
        var v, element;
        var hostServices = powerbitests.mocks.createVisualHostServices();
        if (hasLegendObject) {
            dataViewMetadataCategorySeriesColumns.objects = { legend: { show: true } };
        }
        else {
            dataViewMetadataCategorySeriesColumns.objects = undefined;
        }
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('treemap categories and series dom validation', function (done) {
            var dataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(dataChangedOptions);
            var renderLegend = dataViewMetadataCategorySeriesColumns.objects && dataViewMetadataCategorySeriesColumns.objects['legend'];
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Skylarks');
                expect($('.treemap .labels .minorLabel').length).toBe(6);
                expect($('.treemap .labels .minorLabel').last().text()).toBe('201503');
                if (renderLegend) {
                    expect($('.legend .item').length).toBe(2);
                    expect($('.legend .item').first().text()).toBe('The Nuthatches');
                    expect($('.legend .title').text()).toBe('Squad');
                }
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and series onDataChanged dom validation', function (done) {
            var initialDataViews = [{
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataCategorySeriesColumns.columns[0],
                                values: ['The Nuthatches', 'Skylarks'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('a'),
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                            }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                    }
                }];
            var updatedMetadata = {
                columns: [
                    { displayName: 'Squad', properties: { "Category": true }, type: dataTypeString },
                    { displayName: 'Period', properties: { "Series": true }, type: dataTypeNumber },
                    { displayName: null, groupName: '201503', isMeasure: true, properties: { "Y": true }, type: dataTypeNumber },
                    { displayName: null, groupName: '201504', isMeasure: true, properties: { "Y": true }, type: dataTypeNumber }
                ]
            };
            var updatedDataViews = [{
                    metadata: updatedMetadata,
                    categorical: {
                        categories: [{
                                source: updatedMetadata.columns[0],
                                values: ['The Nuthatches', 'OddOneOut'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('a'),
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: updatedMetadata.columns[2],
                                values: [210, 220],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                            }, {
                                source: updatedMetadata.columns[3],
                                values: [310, 320],
                                identity: powerbitests.mocks.dataViewScopeIdentity('201504'),
                            }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                    }
                }];
            v.onDataChanged({ dataViews: initialDataViews });
            var renderLegend = dataViewMetadataCategorySeriesColumns.objects && dataViewMetadataCategorySeriesColumns.objects['legend'];
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Skylarks');
                expect($('.treemap .labels .minorLabel').length).toBe(6);
                expect($('.treemap .labels .minorLabel').last().text()).toBe('201503');
                if (renderLegend) {
                    expect($('.legend .item').length).toBe(2);
                    expect($('.legend .item').first().text()).toBe('The Nuthatches');
                    expect($('.legend .item').last().text()).toBe('Skylarks');
                    expect($('.legend .title').text()).toBe('Squad');
                }
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(4);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').last().text()).toBe('OddOneOut');
                    expect($('.treemap .labels .minorLabel').length).toBe(4);
                    expect($('.treemap .labels .minorLabel').last().text()).toBe('201504');
                    if (renderLegend) {
                        expect($('.legend .item').first().text()).toBe('The Nuthatches');
                        expect($('.legend .item').last().text()).toBe('OddOneOut');
                        expect($('.legend .title').text()).toBe('Squad');
                    }
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and series onResize from small to medium tile dom validation', function (done) {
            var onDataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: powerbitests.mocks.dataViewScopeIdentity('201501'),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: powerbitests.mocks.dataViewScopeIdentity('201502'),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: powerbitests.mocks.dataViewScopeIdentity('201503'),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(onDataChangedOptions);
            v.onResizing({
                height: 100,
                width: 200
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .minorLabel').length).toBe(4);
                v.onResizing({ height: 300, width: 300 });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(6);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .minorLabel').length).toBe(6);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumn.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumn.columns[1],
                                    values: [110, 120, 130]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap culls invisible rectangles dom validation', function (done) {
            //spyOn(hostServices, 'setWarnings').and.callThrough();
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumn.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumn.columns[1],
                                    values: [110, 120, 0.000000001]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Comedy');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                expect(hostServices.setWarnings).toHaveBeenCalledWith([new powerbi.visuals.GeometryCulledWarning()]);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure with highlights dom validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("Drama"),
                powerbitests.mocks.dataViewScopeIdentity("Comedy"),
                powerbitests.mocks.dataViewScopeIdentity("Documentary"),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumn.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumn.columns[1],
                                    values: [110, 120, 130],
                                    highlights: [60, 80, 20]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(6);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure with overflowing highlights dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumn.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumn.columns[1],
                                    values: [110, 120, 130],
                                    highlights: [140, 160, 135]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Documentary');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measures with highlights dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryAndMeasures,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryAndMeasures.columns[0],
                                    values: ['Front end', 'Back end'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('f'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryAndMeasures.columns[1],
                                    values: [110, 120],
                                    highlights: [60, 60]
                                }, {
                                    source: dataViewMetadataCategoryAndMeasures.columns[2],
                                    values: [210, 220],
                                    highlights: [140, 200]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(2);
                expect($('.treemap .shapes .nodeGroup').length).toBe(8);
                expect($('.treemap .shapes .parentGroup.treemapNodeHighlight').length).toBe(0);
                expect($('.treemap .shapes .nodeGroup.treemapNodeHighlight').length).toBe(4);
                expect($('.treemap .labels .majorLabel').length).toBe(2);
                expect($('.treemap .labels .majorLabel').last().text()).toBe('Back end');
                expect($('.treemap .labels .minorLabel').length).toBe(4);
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure onDataChanged dom validation', function (done) {
            var initialDataViews = [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataCategoryColumn.columns[0],
                                values: ['Drama', 'Comedy', 'Documentary'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('a'),
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                    powerbitests.mocks.dataViewScopeIdentity('c'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [110, 120, 130]
                            }])
                    }
                }];
            var updatedDataViews = [{
                    metadata: dataViewMetadataCategoryColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataCategoryColumn.columns[0],
                                values: ['Comedy', 'Documentary'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('b'),
                                    powerbitests.mocks.dataViewScopeIdentity('c'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategoryColumn.columns[1],
                                values: [120, 130]
                            }])
                    }
                }];
            v.onDataChanged({ dataViews: initialDataViews });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .majorLabel').first().text()).toBe('Drama');
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(2);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').first().text()).toBe('Comedy');
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap categories and measure onResize from small to medium tile dom validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumn,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumn.columns[0],
                                    values: ['Drama', 'Comedy', 'Documentary'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                        powerbitests.mocks.dataViewScopeIdentity('b'),
                                        powerbitests.mocks.dataViewScopeIdentity('c'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumn.columns[1],
                                    values: [110, 120, 130]
                                }])
                        }
                    }]
            });
            v.onResizing({
                height: 100,
                width: 200
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(3);
                expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                expect($('.treemap .labels .majorLabel').length).toBe(3);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onResizing({ height: 300, width: 300 });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(3);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').length).toBe(3);
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap category and measure labeling validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryColumnAndLongText,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryColumnAndLongText.columns[0],
                                    values: ['Very very long value'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('a'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryColumnAndLongText.columns[1],
                                    values: [100]
                                }, {
                                    source: dataViewMetadataCategoryColumnAndLongText.columns[2],
                                    values: [100]
                                }])
                        }
                    }]
            });
            v.onResizing({
                height: 12,
                width: 100
            });
            setTimeout(function () {
                expect($('.treemap .shapes .rootNode').length).toBe(1);
                expect($('.treemap .shapes .parentGroup').length).toBe(1);
                expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                expect($('.treemap .labels .majorLabel').length).toBe(0);
                expect($('.treemap .labels .minorLabel').length).toBe(0);
                v.onResizing({ height: 24, width: 100 });
                setTimeout(function () {
                    expect($('.treemap .shapes .rootNode').length).toBe(1);
                    expect($('.treemap .shapes .parentGroup').length).toBe(1);
                    expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                    expect($('.treemap .labels .majorLabel').length).toBe(1);
                    expect($('.treemap .labels .minorLabel').length).toBe(0);
                    expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                    v.onResizing({ height: 32, width: 200 });
                    setTimeout(function () {
                        expect($('.treemap .shapes .rootNode').length).toBe(1);
                        expect($('.treemap .shapes .parentGroup').length).toBe(1);
                        expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                        expect($('.treemap .labels .majorLabel').length).toBe(1);
                        expect($('.treemap .labels .minorLabel').length).toBe(0);
                        expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                        v.onResizing({ height: 64, width: 200 });
                        setTimeout(function () {
                            expect($('.treemap .shapes .rootNode').length).toBe(1);
                            expect($('.treemap .shapes .parentGroup').length).toBe(1);
                            expect($('.treemap .shapes .nodeGroup').length).toBe(2);
                            expect($('.treemap .labels .majorLabel').length).toBe(1);
                            expect($('.treemap .labels .majorLabel').first().text().length).toBeGreaterThan(0);
                            expect($('.treemap .labels .minorLabel').length).toBe(2);
                            expect($('.treemap .labels .minorLabel').first().text().length).toBeGreaterThan(0);
                            expect($('.treemap .labels .minorLabel').last().text().length).toBeGreaterThan(0);
                            done();
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        if (hasLegendObject) {
            it('legend formatting', function (done) {
                var dataView = {
                    metadata: dataViewMetadataCategorySeriesColumns,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataCategorySeriesColumns.columns[0],
                                values: ['The Nuthatches', 'Skylarks'],
                                identity: [
                                    powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                    powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                ],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataCategorySeriesColumns.columns[2],
                                values: [110, 120],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[3],
                                values: [210, 220],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                            }, {
                                source: dataViewMetadataCategorySeriesColumns.columns[4],
                                values: [310, 320],
                                identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                            }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                    }
                };
                // Check legend should show, if show is undefined
                dataView.metadata.objects = { legend: {} };
                v.onDataChanged({
                    dataViews: [dataView]
                });
                setTimeout(function () {
                    expect($('.legendItem')).toBeInDOM();
                    //change legend position
                    dataView.metadata.objects = { legend: { show: true } };
                    v.onDataChanged({
                        dataViews: [dataView]
                    });
                    setTimeout(function () {
                        expect($('.legendItem')).toBeInDOM();
                        //change legend position
                        dataView.metadata.objects = { legend: { show: true, position: 'Right' } };
                        v.onDataChanged({
                            dataViews: [dataView]
                        });
                        setTimeout(function () {
                            expect($('.legendItem')).toBeInDOM();
                            //set title
                            var testTitle = 'Test Title';
                            dataView.metadata.objects = { legend: { show: true, position: 'Right', showTitle: true, titleText: testTitle } };
                            v.onDataChanged({
                                dataViews: [dataView]
                            });
                            setTimeout(function () {
                                expect($('.legendItem')).toBeInDOM();
                                expect($('.legendTitle').text()).toBe(testTitle);
                                //hide legend
                                dataView.metadata.objects = { legend: { show: false, position: 'Right' } };
                                v.onDataChanged({
                                    dataViews: [dataView]
                                });
                                setTimeout(function () {
                                    expect($('.legendItem')).not.toBeInDOM();
                                    done();
                                }, DefaultWaitForRender);
                            }, DefaultWaitForRender);
                        }, DefaultWaitForRender);
                    }, DefaultWaitForRender);
                }, DefaultWaitForRender);
            });
        }
    }
    ;
    describe("Treemap DOM validation", function () { return treemapDomValidation(false); });
    describe("Treemap DOM validation - with legend", function () { return treemapDomValidation(true); });
    describe("treemap web animation", function () {
        var v, element;
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin('treemap').create();
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
        });
        it('treemap highlight animation', function (done) {
            var noHighlightsDataViews = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            var highlightsDataViewsA = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    highlights: [60, 70],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    highlights: [160, 170],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    highlights: [260, 270],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            var highlightsDataViewsB = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    highlights: [20, 10],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    highlights: [120, 110],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    highlights: [220, 210],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(noHighlightsDataViews);
            setTimeout(function () {
                var svgInit = $('.treemap');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(highlightsDataViewsA);
                v.onDataChanged(highlightsDataViewsB);
                v.onDataChanged(noHighlightsDataViews);
                expect(animator).toBeTruthy();
                expect(animator.animate).toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.treemap');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap highlight animation - suppressAnimations', function (done) {
            var noHighlightsDataViews = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            var highlightsDataViewsA = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    highlights: [60, 70],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    highlights: [160, 170],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    highlights: [260, 270],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            var highlightsDataViewsB = {
                suppressAnimations: true,
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['The Nuthatches', 'Skylarks'],
                                    identity: [
                                        powerbitests.mocks.dataViewScopeIdentity('The Nuthatches'),
                                        powerbitests.mocks.dataViewScopeIdentity('Skylarks'),
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    highlights: [20, 10],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201501')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    highlights: [120, 110],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201502')),
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    highlights: [220, 210],
                                    identity: data.createDataViewScopeIdentity(SQExprBuilder.text('201503')),
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(noHighlightsDataViews);
            setTimeout(function () {
                var svgInit = $('.treemap');
                var initialHeight = svgInit.attr('height'), initialWidth = svgInit.attr('width');
                var animator = v.animator;
                spyOn(animator, 'animate').and.callThrough();
                v.onDataChanged(highlightsDataViewsA);
                v.onDataChanged(highlightsDataViewsB);
                v.onDataChanged(noHighlightsDataViews);
                expect(animator).toBeTruthy();
                expect(animator.animate).not.toHaveBeenCalled();
                setTimeout(function () {
                    var svg = $('.treemap');
                    expect(svg).toBeInDOM();
                    expect(svg.attr('height')).toBe(initialHeight);
                    expect(svg.attr('width')).toBe(initialWidth);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
    });
    describe("treemap interactivity", function () {
        var v, element;
        var hostServices;
        var defaultOpacity = '';
        var dimmedOpacity = Treemap.DimmedShapeOpacity.toString();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '500');
            hostServices = powerbitests.mocks.createVisualHostServices();
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('treemap').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
                interactivity: { selection: true }
            });
        });
        it('treemap categories and series - single select', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['A', 'B'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: seriesIdentities[0],
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: seriesIdentities[1],
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: seriesIdentities[2],
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select a major label
                $('.majorLabel').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                $('.majorLabel').first().d3Click(0, 0);
                // Select the first nested shape
                $('.nodeGroup').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0], seriesIdentities[0]]
                        }
                    ]
                });
                // Select the last minor label
                $('.minorLabel').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[1], seriesIdentities[2]]
                        }
                    ]
                });
                $('.minorLabel').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({ data: [] });
                done();
            }, DefaultWaitForRender);
        });
        it('treemap categories and measures - single click on category node (parent shape must be selectable)', function (done) {
            var identities = [
                powerbitests.mocks.dataViewScopeIdentity('f'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadataCategoryAndMeasures,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategoryAndMeasures.columns[0],
                                    values: ['Front end', 'Back end'],
                                    identity: identities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategoryAndMeasures.columns[1],
                                    values: [110, 120]
                                }, {
                                    source: dataViewMetadataCategoryAndMeasures.columns[2],
                                    values: [210, 220]
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                expect(shapes[0].style.fill).toBe(CssConstants.noneValue);
                expect(shapes[1].style.fill).toBe(CssConstants.noneValue);
                expect(nestedShapes[0].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[1].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[2].style.fill).not.toBe(CssConstants.noneValue);
                expect(nestedShapes[3].style.fill).not.toBe(CssConstants.noneValue);
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select the shape for the second category instance
                $('.parentGroup').last().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [identities[1]]
                        }
                    ]
                });
                done();
            }, DefaultWaitForRender);
        });
        // Disabling due to changes in how we handle selection breaking the preservation of selection across data view changes.  Bug filed as #4904881
        /*it('treemap categories and series onDataChanged - single click on old and new shapes', (done) => {
            var categoryIdentities: powerbi.DataViewScopeIdentity[] = [
                mocks.dataViewScopeIdentity('a'),
                mocks.dataViewScopeIdentity('b'),
            ];

            var initialDataViews: DataView[] = [{
                metadata: dataViewMetadataCategorySeriesColumns,
                categorical: {
                    categories: [{
                        source: dataViewMetadataCategorySeriesColumns.columns[0],
                        values: ['A', 'B'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategorySeriesColumns.columns[2],
                            values: [110, 120],
                            identity: mocks.dataViewScopeIdentity('201501'),
                        }, {
                            source: dataViewMetadataCategorySeriesColumns.columns[3],
                            values: [210, 220],
                            identity: mocks.dataViewScopeIdentity('201502'),
                        }, {
                            source: dataViewMetadataCategorySeriesColumns.columns[4],
                            values: [310, 320],
                            identity: mocks.dataViewScopeIdentity('201503'),
                        }],
                        undefined,
                        dataViewMetadataCategorySeriesColumns.columns[1])
                }
            }];
            var updatedMetadata: powerbi.DataViewMetadata = {
                columns: [
                    { displayName: 'Squad', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'Period', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: '201503', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: '201504', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var updatedDataViewsSeriesIdentities: powerbi.DataViewScopeIdentity[] = [
                mocks.dataViewScopeIdentity('201503'),
                mocks.dataViewScopeIdentity('201504'),
            ];
            var updatedDataViews: DataView[] = [{
                metadata: updatedMetadata,
                categorical: {
                    categories: [{
                        source: updatedMetadata.columns[0],
                        values: ['A', 'B'],
                        identity: categoryIdentities
                    }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: updatedMetadata.columns[2],
                            values: [210, 220],
                            identity: updatedDataViewsSeriesIdentities[0],
                        }, {
                            source: updatedMetadata.columns[3],
                            values: [310, 320],
                            identity: updatedDataViewsSeriesIdentities[1],
                        }],
                        undefined,
                        dataViewMetadataCategorySeriesColumns.columns[1])
                }
            }];

            v.onDataChanged({ dataViews: initialDataViews });

            setTimeout(() => {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');

                spyOn(hostServices, 'onSelect').and.callThrough();

                // Make a selection
                (<any>$('.majorLabel')).first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);

                // Change data
                v.onDataChanged({ dataViews: updatedDataViews });
                setTimeout(() => {
                    shapes = $('.treemap .shapes .parentGroup');
                    nestedShapes = $('.treemap .shapes .nodeGroup');

                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);

                    // Select a new shape
                    (<any>$('.nodeGroup')).last().d3Click(0, 0);
                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                    expect(hostServices.onSelect).toHaveBeenCalledWith(
                        {
                            data: [categoryIdentities[1]]
                        });

                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        }); */
        it('treemap categories and series - selection across resize', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['A', 'B'],
                                    identity: categoryIdentities,
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: seriesIdentities[0],
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: seriesIdentities[1],
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: seriesIdentities[2],
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                // Select a major label
                $('.majorLabel').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0]]
                        }
                    ]
                });
                v.onResizing({ width: 300, height: 300 });
                setTimeout(function () {
                    // Select a major label
                    expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                    expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                    expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                    done();
                }, DefaultWaitForRender);
            }, DefaultWaitForRender);
        });
        it('treemap external clear selection ', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('201501'),
                powerbitests.mocks.dataViewScopeIdentity('201502'),
                powerbitests.mocks.dataViewScopeIdentity('201503'),
            ];
            var onDataChangedOptions = {
                dataViews: [{
                        metadata: dataViewMetadataCategorySeriesColumns,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadataCategorySeriesColumns.columns[0],
                                    values: ['A', 'B'],
                                    identity: [
                                        categoryIdentities[0],
                                        categoryIdentities[1],
                                    ],
                                    identityFields: [categoryColumnRef],
                                }],
                            values: DataViewTransform.createValueColumns([
                                {
                                    source: dataViewMetadataCategorySeriesColumns.columns[2],
                                    values: [110, 120],
                                    identity: seriesIdentities[0]
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[3],
                                    values: [210, 220],
                                    identity: seriesIdentities[1]
                                }, {
                                    source: dataViewMetadataCategorySeriesColumns.columns[4],
                                    values: [310, 320],
                                    identity: seriesIdentities[2]
                                }], undefined, dataViewMetadataCategorySeriesColumns.columns[1])
                        }
                    }]
            };
            v.onDataChanged(onDataChangedOptions);
            setTimeout(function () {
                var rootShape = $('.treemap .shapes .rootNode');
                var shapes = $('.treemap .shapes .parentGroup');
                var nestedShapes = $('.treemap .shapes .nodeGroup');
                spyOn(hostServices, 'onSelect').and.callThrough();
                $('.nodeGroup').first().d3Click(0, 0);
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(dimmedOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(dimmedOpacity);
                expect(hostServices.onSelect).toHaveBeenCalledWith({
                    data: [
                        {
                            data: [categoryIdentities[0], seriesIdentities[0]]
                        }
                    ]
                });
                v.onClearSelection();
                expect(rootShape[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(shapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[0].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[1].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[2].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[3].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[4].style.fillOpacity).toBe(defaultOpacity);
                expect(nestedShapes[5].style.fillOpacity).toBe(defaultOpacity);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("treemap converter validation", function () {
        var viewport = {
            width: 500,
            height: 500,
        };
        it('treemap dataView multi measure', function () {
            var metadata = {
                columns: [
                    {
                        displayName: 'EventCount',
                        queryName: 'EventCount',
                        isMeasure: true,
                        properties: { "Y": true },
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                        objects: { dataPoint: { fill: { solid: { color: 'red' } } } }
                    },
                    {
                        displayName: 'MedalCount',
                        queryName: 'MedalCount',
                        isMeasure: true,
                        properties: { "Y": true },
                        type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                    }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        }, {
                            source: metadata.columns[1],
                            values: [210]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithMeasure("EventCount"),
                SelectionId.createWithMeasure("MedalCount"),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(2);
            expect(nodes[0].name).toBe('EventCount');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            expect(nodes[1].name).toBe('MedalCount');
            expect(nodes[1].size).toBe(210);
            expect(nodes[1].children).not.toBeDefined();
            expect(nodes[1].key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            expect(shapeColors[0]).toEqual('red');
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it('treemap dataView multi measure with null values', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'EventCount', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'MedalCount', queryName: 'MedalCount', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        }, {
                            source: metadata.columns[1],
                            values: [null]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithMeasure("EventCount"),
                SelectionId.createWithMeasure("MedalCount"),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(1);
            expect(nodes[0].name).toBe('EventCount');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it('treemap dataView multi category multi measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', queryName: 'select0', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'MedalCount', queryName: 'select2', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['Africa', 'Asia', 'Australia', 'Europe', 'North America'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130, 140, 150]
                        }, {
                            source: metadata.columns[2],
                            values: [210, 220, 230, 240, 250]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = categoryIdentities.map(function (categoryId) { return SelectionId.createWithId(categoryId); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(5);
            var node = nodes[0];
            expect(node.name).toBe('Africa');
            expect(node.size).toBe(320);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[0].getKey());
            node = nodes[1];
            expect(node.name).toBe('Asia');
            expect(node.size).toBe(340);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[1].getKey());
            node = nodes[2];
            expect(node.name).toBe('Australia');
            expect(node.size).toBe(360);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[2].getKey());
            node = nodes[3];
            expect(node.name).toBe('Europe');
            expect(node.size).toBe(380);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[3].getKey());
            node = nodes[4];
            expect(node.name).toBe('North America');
            expect(node.size).toBe(400);
            expect(node.children).toBeDefined();
            expect(node.children.length).toBe(2);
            expect(node.key).toBe(selectionIds[4].getKey());
            var childIds = [
                SelectionId.createWithIdAndMeasure(categoryIdentities[4], 'select1'),
                SelectionId.createWithIdAndMeasure(categoryIdentities[4], 'select2'),
            ];
            var childNode = node.children[0];
            expect(childNode.name).toBe('EventCount');
            expect(childNode.size).toBe(150);
            expect(childNode.children).not.toBeDefined();
            expect(childNode.key).toBe(childIds[0].getKey());
            expect(childNode.color).toBe(node.color);
            childNode = node.children[1];
            expect(childNode.name).toBe('MedalCount');
            expect(childNode.size).toBe(250);
            expect(childNode.children).not.toBeDefined();
            expect(childNode.key).toBe(childIds[1].getKey());
            expect(childNode.color).toBe(node.color);
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('Africa');
        });
        it('treemap dataView multi series one measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'Year', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'MedalCount', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['2004', '2008', '2012'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[1],
                            values: [110, 120, 130]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithId(categoryIdentities[0]),
                SelectionId.createWithId(categoryIdentities[2]),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(3);
            expect(nodes[0].name).toBe('2004');
            expect(nodes[0].size).toBe(110);
            expect(nodes[0].children).not.toBeDefined();
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            expect(nodes[2].name).toBe('2012');
            expect(nodes[2].size).toBe(130);
            expect(nodes[2].children).not.toBeDefined();
            expect(nodes[2].key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Year');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('2004');
        });
        it('treemap dataView multi category/series', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'Year', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity('a'),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: ['Africa', 'Asia', 'Australia', 'Europe', 'North America'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [110, 120, 130, 140, 150],
                            identity: seriesIdentities[0],
                        }, {
                            source: metadata.columns[3],
                            values: [210, 220, 230, 240, 250],
                            identity: seriesIdentities[1],
                        }, {
                            source: metadata.columns[4],
                            values: [310, 320, 330, 340, 350],
                            identity: seriesIdentities[2],
                        }], undefined, metadata.columns[1])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = [
                SelectionId.createWithId(categoryIdentities[0]),
                SelectionId.createWithId(categoryIdentities[4]),
                SelectionId.createWithIds(categoryIdentities[4], seriesIdentities[2]),
            ];
            var nodes = rootNode.children;
            expect(nodes.length).toBe(5);
            expect(nodes[0].name).toBe('Africa');
            expect(nodes[0].size).toBe(630);
            expect(nodes[0].children).toBeDefined();
            expect(nodes[0].children.length).toBe(3);
            expect(nodes[0].key).toBe(selectionIds[0].getKey());
            var lastNode = nodes[4];
            expect(lastNode.name).toBe('North America');
            expect(lastNode.size).toBe(750);
            expect(lastNode.children).toBeDefined();
            expect(lastNode.children.length).toBe(3);
            expect(lastNode.key).toBe(selectionIds[1].getKey());
            var childNodes = lastNode.children;
            expect(childNodes[2].name).toBe('2012');
            expect(childNodes[2].size).toBe(350);
            expect(childNodes[2].children).not.toBeDefined();
            expect(childNodes[2].key).toBe(selectionIds[2].getKey());
            childNodes.forEach(function (n) { return expect(n.color).toBe(lastNode.color); });
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('Africa');
        });
        it('treemap dataView multi category/series with null values', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'Year', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: [null, 'Asia', 'Australia', 'Europe', 'North America'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [null, 120, 130, 140, null],
                            identity: seriesIdentities[0],
                        }, {
                            source: metadata.columns[3],
                            values: [210, 220, null, 240, null],
                            identity: seriesIdentities[1],
                        }, {
                            source: metadata.columns[4],
                            values: [null, 320, 330, 340, null],
                            identity: seriesIdentities[2],
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var nodes = rootNode.children;
            expect(nodes.length).toBe(4);
            expect(nodes[0].name).toBe('(Blank)');
            expect(nodes[0].size).toBe(210);
            expect(nodes[0].children).toBeDefined();
            expect(nodes[0].children.length).toBe(1);
            expect(nodes[0].key).toBe(SelectionId.createWithId(categoryIdentities[0]).getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('Continent');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('(Blank)');
            expect(treeMapData.legendData.dataPoints[1].label).toBe('Asia');
        });
        it('treemap dataView multi category/series with null values tooltip data test', function () {
            var metadata = {
                columns: [
                    { displayName: 'Continent', properties: { "Category": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) },
                    { displayName: 'Year', properties: { "Series": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2004', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2008', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: null, groupName: '2012', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(null),
                powerbitests.mocks.dataViewScopeIdentity('b'),
                powerbitests.mocks.dataViewScopeIdentity('c'),
                powerbitests.mocks.dataViewScopeIdentity('d'),
                powerbitests.mocks.dataViewScopeIdentity('e'),
            ];
            var seriesIdentities = [
                powerbitests.mocks.dataViewScopeIdentity(2004),
                powerbitests.mocks.dataViewScopeIdentity(2008),
                powerbitests.mocks.dataViewScopeIdentity(2012),
            ];
            var dataView = {
                metadata: metadata,
                categorical: {
                    categories: [{
                            source: metadata.columns[0],
                            values: [null, 'Asia', 'Australia', 'Europe', 'North America'],
                            identity: categoryIdentities,
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[2],
                            values: [null, 120, 130, 140, null],
                            identity: seriesIdentities[0],
                        }, {
                            source: metadata.columns[3],
                            values: [210, 220, null, 240, null],
                            identity: seriesIdentities[1],
                        }, {
                            source: metadata.columns[4],
                            values: [null, 320, 330, 340, null],
                            identity: seriesIdentities[2],
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport).root;
            var node1 = rootNode.children[0];
            var node11 = rootNode.children[0].children[0];
            var node2 = rootNode.children[1];
            var node3 = rootNode.children[2];
            var node4 = rootNode.children[3];
            expect(node1.tooltipInfo).toEqual([{ displayName: "Continent", value: "(Blank)" }]);
            expect(node11.tooltipInfo).toEqual([{ displayName: "Continent", value: "(Blank)" }, { displayName: null, value: "210" }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: "Continent", value: "Asia" }, { displayName: null, value: "120" }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: "Continent", value: "Australia" }, { displayName: null, value: "130" }]);
            expect(node4.tooltipInfo).toEqual([{ displayName: "Continent", value: "Europe" }, { displayName: null, value: "140" }]);
        });
        it('treemap non-categorical multi-measure tooltip values test', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'a', queryName: 'a', isMeasure: true },
                    { displayName: 'b', queryName: 'b', isMeasure: true },
                    { displayName: 'c', queryName: 'c', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadata.columns[0],
                            values: [1],
                        },
                        {
                            source: dataViewMetadata.columns[1],
                            values: [2],
                        },
                        {
                            source: dataViewMetadata.columns[2],
                            values: [3],
                        }
                    ])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport).root;
            var node1 = rootNode.children[0];
            var node2 = rootNode.children[1];
            var node3 = rootNode.children[2];
            expect(node1.tooltipInfo).toEqual([{ displayName: 'a', value: '1' }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: 'b', value: '2' }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: 'c', value: '3' }]);
        });
        it('treemap dataView multi measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) },
                    { displayName: 'MedalCount', queryName: 'select2', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110]
                        }, {
                            source: metadata.columns[1],
                            values: [210]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = metadata.columns.map(function (measure) { return SelectionId.createWithMeasure(measure.queryName); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(2);
            var node = nodes[0];
            expect(node.name).toBe('EventCount');
            expect(node.size).toBe(110);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[0].getKey());
            node = nodes[1];
            expect(node.name).toBe('MedalCount');
            expect(node.size).toBe(210);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[1].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
            expect(treeMapData.legendData.dataPoints[1].label).toBe('MedalCount');
        });
        it('treemap dataView single measure', function () {
            var metadata = {
                columns: [
                    { displayName: 'EventCount', queryName: 'select1', isMeasure: true, properties: { "Y": true }, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double) }
                ]
            };
            var dataView = {
                metadata: metadata,
                categorical: {
                    values: DataViewTransform.createValueColumns([
                        {
                            source: metadata.columns[0],
                            values: [110],
                        }
                    ]),
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var treeMapData = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport);
            var rootNode = treeMapData.root;
            var selectionIds = metadata.columns.map(function (measure) { return SelectionId.createWithMeasure(measure.queryName); });
            var nodes = rootNode.children;
            expect(nodes.length).toBe(1);
            var node = nodes[0];
            expect(node.name).toBe('EventCount');
            expect(node.size).toBe(110);
            expect(node.children).not.toBeDefined();
            expect(node.key).toBe(selectionIds[0].getKey());
            var shapeColors = nodes.map(function (n) { return n.color; });
            expect(shapeColors).toEqual(ArrayExtensions.distinct(shapeColors));
            // Legend
            expect(treeMapData.legendData.title).toBe('');
            expect(treeMapData.legendData.dataPoints[0].label).toBe('EventCount');
        });
        it("treemap categories and measures with highlights tooltip data test", function () {
            var dataView = {
                metadata: dataViewMetadataCategoryAndMeasures,
                categorical: {
                    categories: [{
                            source: dataViewMetadataCategoryAndMeasures.columns[0],
                            values: ['Front end', 'Back end'],
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('f'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ],
                            identityFields: [categoryColumnRef],
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewMetadataCategoryAndMeasures.columns[1],
                            values: [110, 120],
                            highlights: [60, 60]
                        }, {
                            source: dataViewMetadataCategoryAndMeasures.columns[2],
                            values: [210, 220],
                            highlights: [140, 200]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport).root;
            var node1 = rootNode.children[0].children[0];
            var node2 = rootNode.children[0].children[1];
            var node3 = rootNode.children[1].children[0];
            var node4 = rootNode.children[1].children[1];
            expect(node1.tooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFiled", value: "110" }]);
            expect(node1.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFiled", value: "110" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "60" }]);
            expect(node2.tooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFixed", value: "210" }]);
            expect(node2.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Front end" }, { displayName: "BugsFixed", value: "210" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "140" }]);
            expect(node3.tooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFiled", value: "120" }]);
            expect(node3.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFiled", value: "120" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "60" }]);
            expect(node4.tooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFixed", value: "220" }]);
            expect(node4.highlightedTooltipInfo).toEqual([{ displayName: "Area", value: "Back end" }, { displayName: "BugsFixed", value: "220" }, { displayName: powerbi.visuals.ToolTipComponent.localizationOptions.highlightedValueDisplayName, value: "200" }]);
        });
        it("treemap gradient color test", function () {
            var dataPointColors = ["#d9f2fb", "#ff557f", "#b1eab7"];
            var objectDefinitions = [
                { dataPoint: { fill: { solid: { color: dataPointColors[0] } } } },
                { dataPoint: { fill: { solid: { color: dataPointColors[1] } } } },
                { dataPoint: { fill: { solid: { color: dataPointColors[2] } } } }
            ];
            var dataViewGradientMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true, roles: { 'Gradient': true } }
                ]
            };
            var dataView = {
                metadata: dataViewGradientMetadata,
                categorical: {
                    categories: [{
                            source: dataViewGradientMetadata.columns[0],
                            values: ['Front end', 'Back end'],
                            objects: objectDefinitions,
                            identity: [
                                powerbitests.mocks.dataViewScopeIdentity('f'),
                                powerbitests.mocks.dataViewScopeIdentity('b'),
                            ]
                        }],
                    values: DataViewTransform.createValueColumns([
                        {
                            source: dataViewGradientMetadata.columns[1],
                            values: [110, 120],
                            highlights: [60, 60]
                        }, {
                            source: dataViewGradientMetadata.columns[2],
                            values: [210, 220],
                            highlights: [140, 200]
                        }])
                }
            };
            var dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            var colors = powerbi.visuals.visualStyles.create().colorPalette.dataColors;
            var rootNode = Treemap.converter(dataView, colors, dataLabelSettings, null, viewport, null).root;
            var node1 = rootNode.children[0];
            var node2 = rootNode.children[1];
            expect(node1.color).toEqual(dataPointColors[0]);
            expect(node2.color).toEqual(dataPointColors[1]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    describe("VisualFactory", function () {
        var mockVisualKey = "mock";
        beforeEach(function () {
            var plugin = {
                name: mockVisualKey,
                capabilities: {},
                create: function () { return {}; }
            };
            powerbi.visuals.plugins[mockVisualKey] = plugin;
        });
        it("getPlugin finds mock", function () {
            var plugin = powerbi.visuals.visualPluginFactory.create().getPlugin(mockVisualKey);
            expect(plugin).toBe(powerbi.visuals.plugins[mockVisualKey]);
        });
        it("getRegisteredVisuals includes test", function () {
            var registered = powerbi.visuals.visualPluginFactory.create().getVisuals()
                .filter(function (v) { return v.name === mockVisualKey; });
            expect(registered).toEqual([powerbi.visuals.plugins[mockVisualKey]]);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var WaterfallChart = powerbi.visuals.WaterfallChart;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var DataViewTransform = powerbi.data.DataViewTransform;
    var SVGUtil = powerbi.visuals.SVGUtil;
    var ColorConverter = powerbitests.utils.ColorUtility.convertFromRGBorHexToHex;
    powerbitests.mocks.setLocale();
    describe("WaterfallChart", function () {
        describe("capabilities", function () {
            it("should register capabilities", function () {
                var pluginFactory = powerbi.visuals.visualPluginFactory.create();
                var plugin = pluginFactory.getPlugin("waterfallChart");
                expect(plugin).toBeDefined();
                expect(plugin.capabilities).toBe(powerbi.visuals.waterfallChartCapabilities);
            });
            it("should exist", function () {
                expect(powerbi.visuals.waterfallChartCapabilities).toBeDefined();
            });
            it("should include dataViewMappings", function () {
                expect(powerbi.visuals.waterfallChartCapabilities.dataViewMappings).toBeDefined();
            });
            it("Waterfall specifies DataReduction", function () {
                expect(powerbi.visuals.waterfallChartCapabilities.dataViewMappings[0].categorical.categories.dataReductionAlgorithm).toBeDefined();
            });
            it("should include dataRoles", function () {
                expect(powerbi.visuals.waterfallChartCapabilities.dataRoles).toBeDefined();
            });
            it("should not support highlight", function () {
                expect(powerbi.visuals.waterfallChartCapabilities.supportsHighlight).toBeUndefined();
            });
            it("FormatString property should match calculated", function () {
                expect(powerbi.data.DataViewObjectDescriptors.findFormatString(powerbi.visuals.waterfallChartCapabilities.objects)).toEqual(WaterfallChart.formatStringProp);
            });
        });
        describe("warnings", function () {
            var v;
            var warningSpy;
            var hostServices;
            beforeEach(function () {
                var builder = new WaterfallVisualBuilder();
                v = builder.build();
                hostServices = powerbitests.mocks.createVisualHostServices();
                warningSpy = jasmine.createSpy("warning");
                hostServices.setWarnings = warningSpy;
            });
            it("NaN in values shows a warning", function () {
                var dataView = getDataViewFromValues([200, NaN, 0, 0, 0]);
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(getWarningValue(warningSpy.calls.argsFor(0))).toBe("NaNNotSupported");
            });
            it("negative infinity in values shows a warning", function () {
                var dataView = getDataViewFromValues([200, Number.NEGATIVE_INFINITY, 0, 0, 0]);
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(getWarningValue(warningSpy.calls.argsFor(0))).toBe("InfinityValuesNotSupported");
            });
            it("postive infinity in values shows a warning", function () {
                var dataView = getDataViewFromValues([200, Number.POSITIVE_INFINITY, 0, 0, 0]);
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(getWarningValue(warningSpy.calls.argsFor(0))).toBe("InfinityValuesNotSupported");
            });
            it("value out of range in values shows a warning", function () {
                var dataView = getDataViewFromValues([200, -1e301, 0, 0, 0]);
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).toHaveBeenCalled();
                expect(warningSpy.calls.count()).toBe(1);
                expect(getWarningValue(warningSpy.calls.argsFor(0))).toBe("ValuesOutOfRange");
            });
            it("all okay in values shows no warning", function () {
                var dataView = getDataViewFromValues([200, 300, 0, 0, 0]);
                v.onDataChanged({ dataViews: [dataView] });
                expect(warningSpy).not.toHaveBeenCalled();
            });
            function getDataViewFromValues(values) {
                var builder = new WaterfallDataBuilder();
                // NOTE: min/max/total not used here
                return builder.withMeasureValues(values, 0, 0, 0).build();
            }
            function getWarningValue(args) {
                return args[0][0].code;
            }
        });
        describe("axes", function () {
            var v;
            beforeEach(function () {
                v = new WaterfallVisualBuilder().build();
            });
            it("axis titles should be correct ", function () {
                var dataView = new WaterfallDataBuilder().build();
                dataView.metadata.objects = {
                    categoryAxis: {
                        showAxisTitle: true
                    },
                    valueAxis: {
                        showAxisTitle: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                expect($(".xAxisLabel").first().text()).toBe("year");
                expect($(".yAxisLabel").first().text()).toBe("sales");
            });
            it("axis titles should show/hide ", function () {
                var dataView = new WaterfallDataBuilder().build();
                dataView.metadata.objects = {
                    categoryAxis: {
                        showAxisTitle: true
                    },
                    valueAxis: {
                        showAxisTitle: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                expect($(".xAxisLabel").length).toBe(1);
                expect($(".yAxisLabel").length).toBe(1);
                // Hide Axis titles
                dataView.metadata.objects = {
                    categoryAxis: {
                        showAxisTitle: false
                    },
                    valueAxis: {
                        showAxisTitle: false
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                expect($(".xAxisLabel").length).toBe(0);
                expect($(".yAxisLabel").length).toBe(0);
            });
            it("zero axis line is darkened", function (done) {
                var dataView = new WaterfallDataBuilder().build();
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var zeroTicks = $("g.tick:has(line.zero-line)");
                    expect(zeroTicks.length).toBe(2);
                    zeroTicks.each(function (i, item) { return expect(d3.select(item).datum() === 0).toBe(true); });
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        });
        describe("data converter", function () {
            var visualBuilder;
            var colors;
            var dataBuilder;
            var data;
            var dataPoints;
            beforeEach(function () {
                visualBuilder = new WaterfallVisualBuilder();
                colors = visualBuilder.style.colorPalette.dataColors;
                dataBuilder = new WaterfallDataBuilder();
                var dataView = dataBuilder.build();
                data = WaterfallChart.converter(dataView, colors, visualBuilder.host, dataBuilder.dataLabelSettings, dataBuilder.sentimentColors, null);
                dataPoints = data.series[0].data;
            });
            it("legend should have 3 items", function () {
                expect(data.legend.dataPoints.length).toBe(3); // Gain, Loss, Total
            });
            it("has correct positions", function () {
                // values: [100, -200, 0, 300, null, NaN]
                var positions = [0, 100, -100, -100, 200, 200, 0]; // The last position represents the total and is always 0.
                expect(dataPoints.map(function (d) { return d.position; })).toEqual(positions);
                expect(data.positionMin).toBe(dataBuilder.positionMin);
                expect(data.positionMax).toBe(dataBuilder.positionMax);
            });
            it("has correct values", function () {
                // values: [100, -200, 0, 300, null, NaN]
                var valuesWithTotal = [100, -200, 0, 300, 0, 0, 200];
                expect(dataPoints.map(function (d) { return d.value; })).toEqual(valuesWithTotal);
                expect(data.positionMin).toBe(dataBuilder.positionMin);
                expect(data.positionMax).toBe(dataBuilder.positionMax);
            });
            it("gain/loss colors match legend", function () {
                var gainLegend = data.legend.dataPoints[0];
                var lossLegend = data.legend.dataPoints[1];
                expect(dataPoints[0].color).toBe(gainLegend.color); // first value is a gain
                expect(dataPoints[1].color).toBe(lossLegend.color); // second value is a loss
            });
            it("should have no highlights", function () {
                expect(dataPoints.some(function (d) { return d.highlight; })).toBe(false);
                expect(data.hasHighlights).toBe(false);
            });
            it("should have no selected data points", function () {
                expect(dataPoints.some(function (d) { return d.selected; })).toBe(false);
            });
            it("should have tooltip data", function () {
                // categoryValues: [2015, 2016, 2017, 2018, 2019, 2020]
                // measureValues: [100, -200, 0, 300, null, NaN];
                expect(dataPoints[0].tooltipInfo).toEqual([{ displayName: "year", value: "2015" }, { displayName: "sales", value: "$100" }]);
                expect(dataPoints[1].tooltipInfo).toEqual([{ displayName: "year", value: "2016" }, { displayName: "sales", value: "-$200" }]);
                expect(dataPoints[2].tooltipInfo).toEqual([{ displayName: "year", value: "2017" }, { displayName: "sales", value: "$0" }]);
                expect(dataPoints[3].tooltipInfo).toEqual([{ displayName: "year", value: "2018" }, { displayName: "sales", value: "$300" }]);
                expect(dataPoints[4].tooltipInfo).toEqual([{ displayName: "year", value: "2019" }, { displayName: "sales", value: "$0" }]);
                expect(dataPoints[5].tooltipInfo).toEqual([{ displayName: "year", value: "2020" }, { displayName: "sales", value: "$0" }]);
                expect(dataPoints[6].tooltipInfo).toEqual([{ displayName: "year", value: "Total" }, { displayName: "sales", value: "$200" }]);
            });
        });
        describe("setData", function () {
            var chart;
            beforeEach(function () {
                var visualBuilder = new WaterfallVisualBuilder();
                chart = new WaterfallChart({ isScrollable: false, interactivityService: undefined });
                chart.init(visualBuilder.buildInitOptions());
            });
            it("sentiment colors should be set from data object", function () {
                var increaseFill = "#000001";
                var decreaseFill = "#000002";
                var dataView = new WaterfallDataBuilder().build();
                dataView.metadata.objects = {
                    sentimentColors: {
                        increaseFill: { solid: { color: increaseFill } },
                        decreaseFill: { solid: { color: decreaseFill } }
                    }
                };
                chart.setData([dataView]);
                var legendData = chart.calculateLegend();
                expect(legendData.dataPoints[0].color).toBe(increaseFill); // first point is an increase.
                expect(legendData.dataPoints[1].color).toBe(decreaseFill); // second point is a decrease.
            });
            it("should clear data if passed empty array", function () {
                var dataView = new WaterfallDataBuilder().build();
                chart.setData([dataView]);
                expect(chart.calculateLegend().dataPoints.length).not.toBe(0);
                chart.setData([]);
                expect(chart.calculateLegend().dataPoints.length).toBe(0);
            });
        });
        describe("scrollbars", function () {
            var v;
            var element;
            var dataBuilder;
            beforeEach(function () {
                // More data than usual to force scrolling.
                dataBuilder = new WaterfallDataBuilder();
                var dataView = dataBuilder
                    .withMeasureValues([1, 2, 3, 4, -5, 6, 7, -8, -9], 0, 18, 1)
                    .withCategories(["a", "b", "c", "d", "e", "f", "g", "h", "i"])
                    .build();
                var visualBuilder = new WaterfallVisualBuilder();
                // Extra small container to force scrolling.
                v = visualBuilder
                    .withSize(150, 50)
                    .build(true);
                element = visualBuilder.element;
                v.onDataChanged({ dataViews: [dataView] });
            });
            it("DOM validation", function (done) {
                setTimeout(function () {
                    var brushExtent = getBrushExtent();
                    expect(brushExtent.length).toBe(1);
                    var tick = getTicks('x').last();
                    var tickTransform = SVGUtil.parseTranslateTransform(tick.attr('transform'));
                    expect(parseFloat(tickTransform.x)).toBeLessThan(element.width());
                    expect(parseFloat(brushExtent.attr("width"))).toBeGreaterThan(1);
                    expect(brushExtent.attr("x")).toBe("0");
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it('should have correct tick labels after scrolling', function (done) {
                setTimeout(function () {
                    var tickCount = getTicks('x').length;
                    var categoryCount = dataBuilder.categoryValues.length + 1; // +1 for total
                    // Scroll so the last ticks are in view.
                    var startIndex = categoryCount - tickCount;
                    var expectedValues = dataBuilder.categoryValues.slice(startIndex);
                    powerbitests.helpers.runWithImmediateAnimationFrames(function () {
                        v.scrollTo(startIndex);
                        setTimeout(function () {
                            var tickValues = _.map(getTicks('x').get(), function (v) { return $(v).text(); });
                            expect(tickValues.slice(0, tickValues.length - 1)).toEqual(expectedValues);
                            expect(_.startsWith(_.last(tickValues), 'T')).toBeTruthy(); // "Total" may be truncated
                            done();
                        }, powerbitests.DefaultWaitForRender);
                    });
                }, powerbitests.DefaultWaitForRender);
            });
            function getBrushExtent() {
                return $('.brush .extent');
            }
        });
        describe("data labels validation", function () {
            var v;
            var dataView;
            beforeEach(function () {
                // Larger values so we can test label formatting
                dataView = new WaterfallDataBuilder()
                    .withMeasureValues([10000, -20000, 25000, 200, -100, 0], -10000, 15100, 15100)
                    .build();
                v = new WaterfallVisualBuilder().build();
            });
            it("verify labels in DOM", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true,
                        labelPrecision: 0
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var labels = getDataLabels();
                    expect(labels).toBeInDOM();
                    expect(labels.first().text()).toBe("10K");
                    expect(labels.last().text()).toBe("15K"); // Total
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("labels should be visible", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    // 7 data points and 1 total (no overlapping)
                    expect(getDataLabels().length).toBe(7);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("labels should be hidden", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: false
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getDataLabels()).not.toBeInDOM();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("labels should respect display unit setting", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true,
                        labelDisplayUnits: 10,
                        labelPrecision: 0
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getDataLabels().first().text()).toBe('10,000');
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("labels should support display units with no precision", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true,
                        labelDisplayUnits: 1000,
                        labelPrecision: 0
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getDataLabels().last().text()).toBe("15K"); // Total
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("labels should support display units with precision", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true,
                        labelDisplayUnits: 1000,
                        labelPrecision: 1
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getDataLabels().last().text()).toBe("15.1K"); // Total
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("label color should be overriden", function (done) {
                var expectedColor = "#000001";
                var expectedColorInside = powerbi.visuals.dataLabelUtils.defaultInsideLabelColor;
                dataView.metadata.objects = {
                    labels: {
                        show: true,
                        color: { solid: { color: expectedColor } }
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var labels = getDataLabels();
                    labels.each(function (i, label) {
                        if (i === 1)
                            expect(getFillColor($(label))).toBe(expectedColorInside);
                        else
                            expect(getFillColor($(label))).toBe(expectedColor);
                    });
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("label color should be the default color", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var labels = getDataLabels();
                    for (var i = 0, len = labels.length; i < len; i++) {
                        var labelColor = getFillColor(labels.eq(i));
                        expect(labelColor).toBe(labelColor);
                    }
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("label for negative values should be below the bar", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var negativeLabel = getDataLabels().eq(4);
                    var negativeRect = getRects().eq(4);
                    var labelY = parseFloat(negativeLabel.attr("y"));
                    var rectBottomY = parseFloat(negativeRect.attr("y")) + parseFloat(negativeRect.attr("height"));
                    expect(labelY).toBeGreaterThan(rectBottomY);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            // After visual resizing, labels that bigger than shapes, aren't in the DOM
            it("labels that don't fit inside or above the shape should be hidden", function (done) {
                dataView.metadata.objects = {
                    labels: {
                        show: true
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                v.onResizing({ height: 500, width: 200 });
                setTimeout(function () {
                    //one positive label collaide with another label (index 3), and the total label is outside view port, so only 5 labels visible
                    expect(getDataLabels().length).toBe(5);
                    setTimeout(function () {
                        v.onResizing({ height: 10, width: 200 });
                        expect(getDataLabels().length).toBe(0);
                        done();
                    }, powerbitests.DefaultWaitForRender);
                }, powerbitests.DefaultWaitForRender);
            });
        });
        describe("enumerateObjectInstances", function () {
            var v;
            beforeEach(function () {
                v = new WaterfallVisualBuilder().build();
            });
            it("should include labels with empty data", function () {
                v.onDataChanged({ dataViews: [] });
                verifyLabels();
            });
            it("should include labels", function () {
                var dataView = new WaterfallDataBuilder().build();
                v.onDataChanged({ dataViews: [dataView] });
                verifyLabels();
            });
            it("should include sentiment colors with empty data", function () {
                v.onDataChanged({ dataViews: [] });
                verifyColors();
            });
            it("should include sentiment colors", function () {
                var dataView = new WaterfallDataBuilder().build();
                v.onDataChanged({ dataViews: [dataView] });
                verifyColors();
            });
            function verifyColors() {
                var objects = v.enumerateObjectInstances({ objectName: "sentimentColors" });
                expect(objects.length).toBe(1);
                expect(objects[0].properties["increaseFill"]).toBeDefined();
                expect(objects[0].properties["decreaseFill"]).toBeDefined();
                expect(objects[0].properties["totalFill"]).toBeDefined();
            }
            ;
            function verifyLabels() {
                var objects = v.enumerateObjectInstances({ objectName: "labels" });
                var defaultLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
                expect(objects.length).toBe(1);
                expect(objects[0].properties).toBeDefined();
                var properties = objects[0].properties;
                expect(properties["color"]).toBe(defaultLabelSettings.labelColor);
                expect(properties["show"]).toBe(false);
                expect(properties["labelPrecision"]).toBe(defaultLabelSettings.precision);
                expect(properties["labelDisplayUnits"]).toBe(defaultLabelSettings.displayUnits);
            }
        });
        describe("basic DOM", function () {
            var v;
            beforeEach(function () {
                v = new WaterfallVisualBuilder().build();
            });
            it("should create waterfall chart element", function (done) {
                var dataView = new WaterfallDataBuilder().build();
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect($(".waterfallChart")).toBeInDOM();
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("should have a rect for each category and one for total", function (done) {
                var dataBuilder = new WaterfallDataBuilder();
                var dataView = dataBuilder.build();
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getRects().length).toBe(dataBuilder.categoryValues.length + 1);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("rect colors should match sentiment colors", function (done) {
                var increaseFill = "#000001";
                var decreaseFill = "#000002";
                var totalFill = "#000002";
                var dataView = new WaterfallDataBuilder().build();
                dataView.metadata.objects = {
                    sentimentColors: {
                        increaseFill: { solid: { color: increaseFill } },
                        decreaseFill: { solid: { color: decreaseFill } },
                        totalFill: { solid: { color: totalFill } }
                    }
                };
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    var rects = getRects();
                    // values: [100, -200, 0, 300, null, NaN]
                    expect(getFillColor(rects.eq(0))).toEqual(increaseFill);
                    expect(getFillColor(rects.eq(1))).toEqual(decreaseFill);
                    expect(getFillColor(rects.last())).toEqual(totalFill);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
            it("should have connecting lines between rects", function (done) {
                var dataBuilder = new WaterfallDataBuilder();
                var dataView = dataBuilder.build();
                v.onDataChanged({ dataViews: [dataView] });
                setTimeout(function () {
                    expect(getConnectors().length).toBe(dataBuilder.categoryValues.length);
                    done();
                }, powerbitests.DefaultWaitForRender);
            });
        });
        function getFillColor(element) {
            return ColorConverter(element.css("fill"));
        }
        function getRects() {
            return $(".waterfallChart .mainGraphicsContext rect.column");
        }
        function getConnectors() {
            return $(".waterfallChart .mainGraphicsContext line.waterfall-connector");
        }
        function getDataLabels() {
            return $('.waterfallChart .labels .data-labels');
        }
        function getTicks(axis) {
            // axis should be either 'x' or 'y'.
            return $('.waterfallChart .axisGraphicsContext .' + axis + '.axis .tick');
        }
    });
    var WaterfallDataBuilder = (function () {
        function WaterfallDataBuilder() {
            this._categoryColumn = { displayName: "year", type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
            this._categoryValues = [2015, 2016, 2017, 2018, 2019, 2020];
            this._categoryIdentities = this.categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            this._measureColumn = { displayName: "sales", isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: "$0" } } };
            this._measureValues = [100, -200, 0, 300, null, NaN];
            this._posMax = 200;
            this._posMin = -100;
            this._total = 200;
            this._dataLabelSettings = powerbi.visuals.dataLabelUtils.getDefaultLabelSettings();
            this._sentimentColors = {
                increaseFill: {
                    solid: { color: "#FF0000" }
                },
                decreaseFill: {
                    solid: { color: "#00FF00" }
                },
                totalFill: {
                    solid: { color: "#0000FF" }
                }
            };
        }
        Object.defineProperty(WaterfallDataBuilder.prototype, "categoryColumn", {
            get: function () { return this._categoryColumn; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "categoryValues", {
            get: function () { return this._categoryValues; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "categoryIdentities", {
            get: function () { return this._categoryIdentities; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "measureColumn", {
            get: function () { return this._measureColumn; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "measureValues", {
            get: function () { return this._measureValues; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "positionMax", {
            get: function () { return this._posMax; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "positionMin", {
            get: function () { return this._posMin; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "total", {
            get: function () { return this._total; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "dataLabelSettings", {
            get: function () { return this._dataLabelSettings; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallDataBuilder.prototype, "sentimentColors", {
            get: function () { return this._sentimentColors; },
            enumerable: true,
            configurable: true
        });
        WaterfallDataBuilder.prototype.build = function () {
            return {
                metadata: {
                    columns: [this._categoryColumn, this._measureColumn]
                },
                categorical: {
                    categories: [{
                            source: this._categoryColumn,
                            values: this._categoryValues,
                            identity: this._categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: this._measureColumn,
                            values: this._measureValues
                        }])
                }
            };
        };
        WaterfallDataBuilder.prototype.withMeasureValues = function (values, posMin, posMax, total) {
            this._measureValues = values;
            this._posMin = posMin;
            this._posMax = posMax;
            this._total = total;
            return this;
        };
        WaterfallDataBuilder.prototype.withCategories = function (categories) {
            this._categoryValues = categories;
            this._categoryIdentities = this._categoryValues.map(function (v) { return powerbitests.mocks.dataViewScopeIdentity(v); });
            return this;
        };
        return WaterfallDataBuilder;
    })();
    var WaterfallVisualBuilder = (function () {
        function WaterfallVisualBuilder() {
            this._style = powerbi.visuals.visualStyles.create();
            this._host = powerbitests.mocks.createVisualHostServices();
            this._svg = d3.select($("<svg/>").get(0));
            this._viewport = {
                height: 500,
                width: 500
            };
            this._element = powerbitests.helpers.testDom("500", "500");
            this._cartesianHost = {
                updateLegend: function (data) { },
                getSharedColors: function () { return null; }
            };
        }
        Object.defineProperty(WaterfallVisualBuilder.prototype, "style", {
            get: function () { return this._style; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallVisualBuilder.prototype, "host", {
            get: function () { return this._host; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterfallVisualBuilder.prototype, "element", {
            get: function () { return this._element; },
            enumerable: true,
            configurable: true
        });
        WaterfallVisualBuilder.prototype.build = function (minerva) {
            if (minerva === void 0) { minerva = false; }
            if (minerva) {
                this._visual = powerbi.visuals.visualPluginFactory.createMinerva({}).getPlugin("waterfallChart").create();
            }
            else {
                this._visual = powerbi.visuals.visualPluginFactory.create().getPlugin("waterfallChart").create();
            }
            this._visual.init(this.buildInitOptions());
            return this._visual;
        };
        WaterfallVisualBuilder.prototype.buildInitOptions = function () {
            return {
                element: this._element,
                host: this._host,
                style: this._style,
                viewport: this._viewport,
                interactivity: { isInteractiveLegend: false },
                animation: { transitionImmediate: true },
                svg: this._svg,
                cartesianHost: this._cartesianHost
            };
        };
        WaterfallVisualBuilder.prototype.withSize = function (width, height) {
            this._element = powerbitests.helpers.testDom(height.toString(), width.toString());
            this._viewport = {
                width: width,
                height: height
            };
            return this;
        };
        return WaterfallVisualBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ContentPositions = powerbi.ContentPositions;
    var DataLabelManager = powerbi.DataLabelManager;
    var RectOrientation = powerbi.RectOrientation;
    var OutsidePlacement = powerbi.OutsidePlacement;
    describe("Default Settings", function () {
        it("Check default values are true", function () {
            var labelManager = new DataLabelManager();
            var defaultSettings = labelManager.defaultSettings;
            expect(defaultSettings.anchorMargin).toBe(0);
            expect(defaultSettings.anchorRectOrientation).toBe(RectOrientation.None);
            expect(defaultSettings.contentPosition).toBe(ContentPositions.BottomCenter);
            expect(defaultSettings.maximumMovingDistance).toBe(12);
            expect(defaultSettings.minimumMovingDistance).toBe(3);
            expect(defaultSettings.opacity).toBe(1);
            expect(defaultSettings.outsidePlacement).toBe(OutsidePlacement.Disallowed);
            expect(defaultSettings.validContentPositions).toBe(ContentPositions.BottomCenter);
        });
    });
    describe("Get Label info - One value provided", function () {
        var labelManager = new DataLabelManager();
        var defaultSettings = labelManager.defaultSettings;
        it("Get Label info", function () {
            var result = labelManager.getLabelInfo({ minimumMovingDistance: 10 });
            expect(defaultSettings.minimumMovingDistance).toEqual(3);
            expect(result.minimumMovingDistance).toEqual(10);
        });
        it("Get Label info - all values Provided", function () {
            var result = labelManager.getLabelInfo({ maximumMovingDistance: 12 });
            expect(defaultSettings.anchorMargin).toEqual(0);
            expect(result.maximumMovingDistance).toEqual(12);
        });
        it("Get Label info - Default value should be taken", function () {
            var result = labelManager.getLabelInfo({});
            expect(defaultSettings.anchorMargin).toEqual(0);
            expect(result.anchorMargin).toEqual(0);
        });
    });
    describe("Is Valid Rect", function () {
        it("Is Valid Rect - Return true", function () {
            expect(DataLabelManager.isValid({ left: 150, top: 130, width: 120, height: 110 })).toBe(true);
        });
        it("Is Valid Rect - Negative values", function () {
            expect(DataLabelManager.isValid({ left: -150, top: -130, width: -120, height: -110 })).toBe(false);
        });
        it("Is Valid Rect - Empty Rect", function () {
            expect(DataLabelManager.isValid({ left: 0, top: 0, width: 0, height: 0 })).toBe(false);
        });
        it("Is Valid Rect - null Rect", function () {
            expect(DataLabelManager.isValid(null)).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var valueFormatter = powerbi.visuals.valueFormatter;
    describe("ValueFormatter", function () {
        var columnIntObjFormat = { displayName: "col", objects: { fmtObj: { fmtProp: "R" } } };
        var columnIntObjFormatIdentitifer = { objectName: "fmtObj", propertyName: "fmtProp" };
        describe("format", function () {
            it("format null", function () {
                expect(valueFormatter.format(null)).toBe("(Blank)");
                expect(valueFormatter.formatRaw(null)).toBe("");
            });
            it("format empty", function () {
                expect(valueFormatter.format("")).toBe("");
                expect(valueFormatter.formatRaw("")).toBe("");
            });
            it("format non-null value", function () {
                var formatValue1 = valueFormatter.format(2010);
                var formatValue2 = valueFormatter.formatRaw(2010);
                expect(formatValue1).not.toBeNull();
                expect(formatValue2).not.toBeNull();
                expect(formatValue1).toBe(formatValue2);
            });
            it("format 100 pct", function () {
                expect(valueFormatter.format(1, "0.00 %;-0.00 %;0.00 %", true)).toBe("100%");
            });
            it("format 100 pct - no beautify", function () {
                expect(valueFormatter.format(1, "0.00 %;-0.00 %;0.00 %")).toBe("100.00 %");
            });
            it("format 100 pct - variation", function () {
                expect(valueFormatter.format(1, "0.0 %;-0.0 %;0.0 %", true)).toBe("100%");
            });
            it("format 52 pct - 4 decimals beautified", function () {
                // we only beautify the default format strings for percent
                expect(valueFormatter.format(0.52, "0.0000 %;-0.0000 %;0.0000 %", true)).toBe("52.0000 %");
            });
            it("format whole pct", function () {
                expect(valueFormatter.format(0.5, "0 %;-0 %;0 %", true)).toBe("50 %");
            });
            it("format Boolean", function () {
                expect(valueFormatter.format(true)).toBe("True");
                expect(valueFormatter.format(false)).toBe("False");
            });
            it("format Invalids", function () {
                expect(valueFormatter.format(Number.NaN)).toBe("NaN");
                expect(valueFormatter.format(Number.NEGATIVE_INFINITY)).toBe("-Infinity");
                expect(valueFormatter.format(Number.POSITIVE_INFINITY)).toBe("+Infinity");
                expect(valueFormatter.format(null)).toBe("(Blank)");
            });
        });
        describe("getFormatString", function () {
            it("getFormatString: column with custom object", function () {
                expect(valueFormatter.getFormatString(columnIntObjFormat, columnIntObjFormatIdentitifer)).toBe("R");
            });
            it("getFormatString: column with custom object (unspecified)", function () {
                expect(valueFormatter.getFormatString({ displayName: "col" }, columnIntObjFormatIdentitifer)).toBeUndefined();
            });
        });
        describe("create", function () {
            it("create basic format with invalid values", function () {
                var scale = valueFormatter.create({ format: "0", value: 0 });
                expect(scale.format(Number.NaN)).toBe("NaN");
                expect(scale.format(Number.NEGATIVE_INFINITY)).toBe("-Infinity");
                expect(scale.format(Number.POSITIVE_INFINITY)).toBe("+Infinity");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create non-null/null init", function () {
                var scale = valueFormatter.create({ format: "0", value: 1e6, value2: null });
                expect(scale.format(-2.4e6)).toBe("-2.4M");
            });
            it("create null/non-null init", function () {
                var scale = valueFormatter.create({ format: "0", value: null, value2: 1e6 });
                expect(scale.format(-2.4e6)).toBe("-2.4M");
            });
            it("create abs value init", function () {
                var scale = valueFormatter.create({ format: "0", value: -3e6, value2: 2 });
                expect(scale.format(-3e6)).toBe("-3M");
            });
            it("create Year", function () {
                var scale = valueFormatter.create({ format: "d", value: new Date(2010, 1) });
                expect(scale.format(2010)).toBe("2010");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create No Scale", function () {
                var scale = valueFormatter.create({ value: 0 });
                expect(scale.format(0)).toBe("0");
                expect(scale.format(0.5678934)).toBe("0.5679");
                expect(scale.format(-0.5678934)).toBe("-0.5679");
                expect(scale.format(1.234e7)).toBe("12340000");
                expect(scale.format(1.12000000000007)).toBe("1.12");
            });
            it("create Million", function () {
                var scale = valueFormatter.create({ value: 1e6 });
                expect(scale.format(4.56e7)).toBe("45.6M");
                expect(scale.format(4.56789123e7)).toBe("45.68M");
                expect(scale.format(-3130000.567)).toBe("-3.13M");
                expect(scale.format(10000)).toBe("0.01M");
                expect(scale.format(100000)).toBe("0.1M");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create Billion", function () {
                var scale = valueFormatter.create({ value: 1e9 });
                expect(scale.format(4.56e10)).toBe("45.6bn");
                expect(scale.format(4.56789123e10)).toBe("45.68bn");
                expect(scale.format(-3130000000.567)).toBe("-3.13bn");
                expect(scale.format(100000000)).toBe("0.1bn");
                expect(scale.format(1000000000)).toBe("1bn");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create Trillion", function () {
                var scale = valueFormatter.create({ value: 1e12 });
                expect(scale.format(4.56e13)).toBe("45.6T");
                expect(scale.format(4.56789123e13)).toBe("45.68T");
                expect(scale.format(-3130000000000.567)).toBe("-3.13T");
                expect(scale.format(100000000000)).toBe("0.1T");
                expect(scale.format(1000000000000)).toBe("1T");
                expect(scale.format(1000000000000000)).toBe("1000T");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create Exponent format", function () {
                var scale = valueFormatter.create({ format: "E", value: 1e15 });
                expect(scale.format(719200000000001920000000000)).toBe("7.192000E+026");
            });
            it("create Exponent format", function () {
                var scale = valueFormatter.create({ value: 1e15 });
                expect(scale.format(719200000000001920000000000)).toBe("7.192E+26");
            });
            it("create Percentage", function () {
                var scale = valueFormatter.create({ format: "0.00 %;-0.00 %;0.00 %", value: 1, allowFormatBeautification: true });
                expect(scale.format(0)).toBe("0%");
                expect(scale.format(1)).toBe("100%");
                expect(scale.format(-1)).toBe("-100%");
                expect(scale.format(.54)).toBe("54%");
                expect(scale.format(.543)).toBe("54.3%");
                expect(scale.format(.5432)).toBe("54.32%");
                expect(scale.format(.54321)).toBe("54.32%");
                expect(scale.format(6.54321)).toBe("654.32%");
                expect(scale.format(76.54321)).toBe("7,654.32%");
            });
            it("create Escaped Character format", function () {
                var scale = valueFormatter.create({ format: "\\$#,0.00;(\\$#,0.00);\\$#,0.00", value: 1e6 });
                expect(scale.format(107384391.61)).toBe("$107.38M");
                expect(scale.format(-107384391.61)).toBe("($107.38M)");
            });
            it("create Format no custom negative", function () {
                var scale = valueFormatter.create({ format: "$#,0.00", value: 1e6 });
                expect(scale.format(-107384391.61)).toBe("-$107.38M");
            });
            it("create HundredThousand", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 300000 });
                expect(scale.format(300000)).toBe("0.3M");
            });
            it("create Million", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000 });
                expect(scale.format(900000000)).toBe("0.9bn");
            });
            it("create Billion", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000 });
                expect(scale.format(900000000000)).toBe("0.9T");
            });
            it("create Trillion", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.Default });
                expect(scale.format(900000000000000)).toBe("9E+14");
            });
            it("create HundredThousand Whole Units", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 300000, displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits });
                expect(scale.format(300000)).toBe("300K");
            });
            it("create Million Whole Units", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits });
                expect(scale.format(900000000)).toBe("900M");
            });
            it("create Billion Whole Units", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits });
                expect(scale.format(900000000000)).toBe("900bn");
            });
            it("create Trillion Whole Units", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.WholeUnits });
                expect(scale.format(900000000000000)).toBe("900T");
            });
            it("create HundredThousand Verbose (No Units)", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 300000, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose });
                expect(scale.format(300000)).toBe("300000");
            });
            it("create Million Verbose (No Units)", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose });
                expect(scale.format(900000000)).toBe("900000000");
            });
            it("create Billion Verbose (No Units)", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose });
                expect(scale.format(900000000000)).toBe("900000000000");
            });
            it("create Trillion Verbose (No Units)", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 900000000000000, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose });
                expect(scale.format(900000000000000)).toBe("900000000000000");
            });
            it("create single value formatting verbose", function () {
                var format = "#,0.00";
                var scale = valueFormatter.create({ format: format, value: 26.254, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose, formatSingleValues: true });
                // Default formatting for numeric types is 2dp
                expect(scale.format(26.254)).toBe("26.25");
            });
            it("create single value formatting verbose large", function () {
                var format = "#,0.00";
                var scale = valueFormatter.create({ format: format, value: 300000.254, displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose, formatSingleValues: true });
                // Verbose formatting shouldn't use units
                expect(scale.format(300000.254)).toBe("300,000.25");
            });
            it("precision without display units", function () {
                var scale = valueFormatter.create({ value: 0, precision: 3 });
                expect(scale.format(12.1012)).toBe("12.101");
            });
            it("precision with display units", function () {
                var format = "#,0.00";
                var scale = valueFormatter.create({ format: format, value: 10000, precision: 2 });
                expect(scale.format(12177)).toBe("12.18K");
            });
            it("precision 1 with display units", function () {
                var format = "#,0.00";
                var scale = valueFormatter.create({ format: format, value: 10000, precision: 1 });
                expect(scale.format(12177)).toBe("12.2K");
            });
            it("precision with display units and no format string", function () {
                var scale = valueFormatter.create({ value: 10000, precision: 2 });
                expect(scale.format(12177)).toBe("12.18K");
            });
            it("Verify single value integer formatting for values less than 10K should not show display units", function () {
                var format = "g";
                var input = 9999;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("9999");
            });
            it("Verify single value integer formatting for numeric values less than 10K should show display units", function () {
                // NOTE: In this case the column type is Integer, but the value is actually numeric.
                var format = "g";
                var input = 9999.12345;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("10K");
            });
            it("Verify single value number formatting with display units for values greater than 10K should show display units", function () {
                var format = "g";
                var input = 10001;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("10K");
            });
            it("Verify single value custom formatting with single decimal value should not show display units", function () {
                var format = "0";
                var input = 1999.2;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("1999");
            });
            it("Verify single value custom formatting with two decimal values should show display units", function () {
                var format = "0.00";
                var input = 1999.9;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("2K");
            });
            it("Verify single value number formatting for values less than 10K should show display units", function () {
                var format = "g";
                var input = 1999.9;
                var columnType = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double);
                var scale = valueFormatter.create({ format: format, value: input, formatSingleValues: true, columnType: columnType });
                expect(scale.format(input)).toBe("2K");
            });
            it("create Boolean", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: false, value2: true, tickCount: 6 });
                expect(scale.format(true)).toBe("True");
                expect(scale.format(false)).toBe("False");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create Boolean with numeric index values", function () {
                var format;
                var scale = valueFormatter.create({ format: format, value: 0, value2: 1, tickCount: 6 });
                expect(scale.format(true)).toBe("True");
                expect(scale.format(false)).toBe("False");
                expect(scale.format(null)).toBe("(Blank)");
            });
            it("create Date", function () {
                var format = "O";
                var minDate = new Date(2014, 10, 4, 12, 34, 56, 789);
                var maxDate = new Date(2014, 10, 9, 12, 34, 56, 789);
                var scale = valueFormatter.create({ format: format, value: minDate, value2: maxDate, tickCount: 6 });
                expect(scale.format(minDate)).toBe("Nov 04");
                expect(scale.format(maxDate)).toBe("Nov 09");
                expect(scale.format(null)).toBe("(Blank)");
            });
        });
        describe("formatListAnd", function () {
            it("formatListAnd no values", function () {
                expect(valueFormatter.formatListAnd([])).toBeNull();
            });
            it("formatListAnd 1 value", function () {
                expect(valueFormatter.formatListAnd(["1"])).toBe("1");
            });
            it("formatListAnd 2 values", function () {
                expect(valueFormatter.formatListAnd(["1", "2"])).toBe("1 and 2");
            });
            it("formatListAnd 3 values", function () {
                expect(valueFormatter.formatListAnd(["1", "2", "3"])).toBe("1, 2 and 3");
            });
            it("formatListAnd wrong parameters values", function () {
                expect(valueFormatter.formatListAnd(null)).toBeNull();
                expect(valueFormatter.formatListAnd(undefined)).toBeNull();
            });
        });
        describe("formatListOr", function () {
            it("formatListOr no values", function () {
                expect(valueFormatter.formatListOr([])).toBeNull();
            });
            it("formatListOr 1 value", function () {
                expect(valueFormatter.formatListOr(["1"])).toBe("1");
            });
            it("formatListOr wrong parameters values", function () {
                expect(valueFormatter.formatListOr(null)).toBeNull();
                expect(valueFormatter.formatListOr(undefined)).toBeNull();
            });
        });
        it("getDisplayUnits", function () {
            var displayUnits = valueFormatter.getDisplayUnits(powerbi.DisplayUnitSystemType.Default);
            expect(displayUnits).toBeDefined();
            expect(displayUnits.length).toBeGreaterThan(0);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var Animator = powerbi.visuals.Animator;
    var AnimatorCommon = powerbi.visuals.AnimatorCommon;
    describe("Animator tests", function () {
        it("default animation duration", function () {
            var animator = new Animator();
            expect(animator.getDuration()).toBe(AnimatorCommon.MinervaAnimationDuration);
        });
        it("override default animation duration", function () {
            var duration = 500;
            var animator = new Animator({
                duration: duration
            });
            expect(animator.getDuration()).toBe(duration);
        });
    });
    describe("AnimatorCommon tests", function () {
        describe("GetAnimationDuration", function () {
            describe("without animator", function () {
                it("undefined: IAnimator, undefined: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(undefined, undefined);
                    expect(duration).toBe(0);
                });
                it("null: IAnimator, null: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(null, null);
                    expect(duration).toBe(0);
                });
                it("null: IAnimator, false: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(null, false);
                    expect(duration).toBe(0);
                });
                it("null: IAnimator, true: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(null, true);
                    expect(duration).toBe(0);
                });
            });
            describe("with animator", function () {
                var animator;
                var defaultDuration = 333;
                beforeEach(function () {
                    animator = new Animator({
                        duration: defaultDuration
                    });
                });
                it("animator: IAnimator, undefined: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(animator, undefined);
                    expect(duration).toBe(defaultDuration);
                });
                it("animator: IAnimator, null: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(animator, null);
                    expect(duration).toBe(defaultDuration);
                });
                it("animator: IAnimator, false: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(animator, false);
                    expect(duration).toBe(defaultDuration);
                });
                it("animator: IAnimator, true: suppressAnimations", function () {
                    var duration = AnimatorCommon.GetAnimationDuration(animator, true);
                    expect(duration).toBe(0);
                });
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var AxisHelper = powerbi.visuals.AxisHelper;
    var ValueType = powerbi.ValueType;
    describe("AxisHelper invertOrdinalScale tests", function () {
        var range;
        var ordinalScale;
        var domain;
        beforeEach(function () {
            range = [0, 99];
            domain = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            ordinalScale = d3.scale.ordinal();
            ordinalScale.rangeRoundBands(range, 0.1);
            ordinalScale.domain(domain);
        });
        it('invertOrdinalScale in middle', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 50);
            expect(invertedValue).toBe(5);
        });
        it('invertOrdinalScale at start', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 0);
            expect(invertedValue).toBe(0);
        });
        it('invertOrdinalScale at end', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 99);
            expect(invertedValue).toBe(9);
        });
        it('invertOrdinalScale at before start', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, -4);
            expect(invertedValue).toBe(0);
        });
        it('invertOrdinalScale at after end', function () {
            var invertedValue = AxisHelper.invertOrdinalScale(ordinalScale, 1222);
            expect(invertedValue).toBe(9);
        });
    });
    describe("AxisHelper createDomain tests", function () {
        var scalarCartesianSeries = [
            {
                data: [{
                        categoryValue: 7,
                        value: 11,
                        categoryIndex: 0,
                        seriesIndex: 0,
                    }, {
                        categoryValue: 9,
                        value: 9,
                        categoryIndex: 1,
                        seriesIndex: 0,
                    }, {
                        categoryValue: 15,
                        value: 6,
                        categoryIndex: 2,
                        seriesIndex: 0,
                    }, {
                        categoryValue: 22,
                        value: 7,
                        categoryIndex: 3,
                        seriesIndex: 0,
                    }]
            },
        ];
        it("ordinal - text", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ text: true }), false, []);
            expect(domain).toEqual([0, 1, 2, 3]);
        });
        it("scalar - two values", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, [5, 20]);
            expect(domain).toEqual([5, 20]);
        });
        it("scalar - undefined, val", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, [undefined, 20]);
            expect(domain).toEqual([7, 20]);
        });
        it("scalar - val, undefined", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, [5, undefined]);
            expect(domain).toEqual([5, 22]);
        });
        it("scalar - undefined, undefined", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, [undefined, undefined]);
            expect(domain).toEqual([7, 22]);
        });
        it("scalar - null", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, null);
            expect(domain).toEqual([7, 22]);
        });
        // invalid case with min > max, take actual domain
        it("scalar - min > max", function () {
            var domain = AxisHelper.createDomain(scalarCartesianSeries, ValueType.fromDescriptor({ numeric: true }), true, [15, 10]);
            expect(domain).toEqual([7, 22]);
        });
    });
    describe("AxisHelper createAxis tests", function () {
        var dataStrings = ['Sun', 'Mon', 'Holiday'];
        var dataNumbers = [47.5, 98.22, 127.3];
        var dataPercent = [0.0, 0.33, 0.49];
        var dataTime = [new Date('10/15/2014'), new Date('10/15/2015'), new Date('10/15/2016')];
        var domainOrdinal3 = [0, 1, 2];
        var domainBoolIndex = [0, 1];
        var domainNaN = [NaN, NaN];
        var metaDataColumnText = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ text: true })
        };
        var metaDataColumnNumeric = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ numeric: true }),
            objects: {
                general: {
                    formatString: '0.00;-0.00;0.00',
                }
            }
        };
        var metaDataColumnPercent = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ numeric: true }),
            objects: {
                general: {
                    formatString: '0 %;-0 %;0 %',
                }
            }
        };
        var metaDataColumnBool = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ bool: true })
        };
        var metaDataColumnTime = {
            displayName: 'Column',
            type: ValueType.fromDescriptor({ dateTime: true })
        };
        var formatStringProp = {
            objectName: 'general',
            propertyName: 'formatString',
        };
        // TODO: add a getValueFn mock to provide to createAxis so we can test tickValue generation
        it('create ordinal scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnText,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) { return dataStrings[index]; }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('Sun');
            // Provides category thickness is not set when not defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeUndefined();
            // Proves label max width is pixelSpan/tickValues when categoryThickness not defined
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toEqual(21);
        });
        it('create ordinal scale with linear values', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) { return dataNumbers[index]; }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('47.50');
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
        });
        it('create ordinal scale with no categories', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: undefined,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) { return dataStrings[index]; }
            });
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(0);
        });
        it('create ordinal scale with boolean values', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainBoolIndex,
                metaDataColumn: metaDataColumnBool,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (d, dataType) { if (d === 0)
                    return true;
                else
                    return false; }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            // check tick labels values
            expect(os.values[0]).toBe('True');
            expect(os.values[1]).toBe('False');
        });
        it('create ordinal scale with category thickness', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnText,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                categoryThickness: 14,
                getValueFn: function (index, type) { return dataStrings[index]; }
            });
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('Sun');
            // Provides category thickness set when defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toEqual(14);
            // Provides category thickness used as xLabelMaxWidth when not is scalar
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toEqual(10);
        });
        it('create linear scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataNumbers[0], dataNumbers[2]],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // Provides category thickness is not set when not defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[1]).toBe('100.00');
            // Proves label max width is pixelSpan/tickValues when is scalar and category thickness not defined
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toBeGreaterThan(28);
            expect(xLabelMaxWidth).toBeLessThan(33);
        });
        it('create linear scale with NaN domain', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainNaN,
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: true
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // check for default value fallbackDomain
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[2]).toBe('10.00');
        });
        it('create value scale - near zero min check', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [-0.000001725, 15],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: true
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[0]).toBe('0.00');
        });
        it('create linear scale with category thickness', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [40, 60],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 20,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // Proves category thickness set when defined
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toEqual(20);
            // Proves category thickness not considered for label max width when is scalar
            var xLabelMaxWidth = os.xLabelMaxWidth;
            expect(xLabelMaxWidth).toBeDefined();
            expect(xLabelMaxWidth).toBe(21);
        });
        it('create linear scale with category thickness that needs to change', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 200,
                dataDomain: [2007, 2011],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 50,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // category thickness was altered
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toBeCloseTo(33.3, 1);
        });
        it('create linear scale with category thickness and zero range (single value)', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 200,
                dataDomain: [9, 9],
                metaDataColumn: metaDataColumnNumeric,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                categoryThickness: 50,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            // category thickness was altered
            var categoryThickness = os.categoryThickness;
            expect(categoryThickness).toBeDefined();
            expect(categoryThickness).toBe(50);
        });
        it('create scalar time scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataTime[0].getTime(), dataTime[2].getTime()],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) { return new Date(index); } //index is actually milliseconds in this case
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[0]).toBe('2015');
        });
        it('create scalar time scale - single day', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataTime[0].getTime(), dataTime[0].getTime()],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) { return new Date(index); } //index is actually milliseconds in this case
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(1);
            expect(values[0]).toBe('Oct 15');
        });
        it('create scalar time scale with invaid domains', function () {
            var axisProps = [];
            axisProps[0] = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) { return new Date(index); } //index is actually milliseconds in this case
            });
            axisProps[1] = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: null,
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) { return new Date(index); } //index is actually milliseconds in this case
            });
            axisProps[2] = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [undefined, undefined],
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: false,
                getValueFn: function (index, type) { return new Date(index); } //index is actually milliseconds in this case
            });
            for (var i = 0, ilen = axisProps.length; i < ilen; i++) {
                var props = axisProps[i];
                var scale = props.scale;
                expect(scale).toBeDefined();
                // Proves scale is linear
                expect(scale.invert).toBeDefined();
                var values = props.values;
                expect(values).toBeDefined();
                expect(values.length).toEqual(2);
                expect(values[0]).toBe('Jul 2014');
                expect(props.usingDefaultDomain).toBe(true);
            }
        });
        it('create ordinal time scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: domainOrdinal3,
                metaDataColumn: metaDataColumnTime,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: false,
                isVertical: false,
                getValueFn: function (index, type) { return dataTime[index]; }
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is ordinal
            expect(scale.invert).toBeUndefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(3);
            expect(values[0]).toBe('2014');
        });
        it('create linear percent value scale', function () {
            var os = AxisHelper.createAxis({
                pixelSpan: 100,
                dataDomain: [dataPercent[0], dataPercent[2]],
                metaDataColumn: metaDataColumnPercent,
                formatStringProp: formatStringProp,
                outerPadding: 0.5,
                isScalar: true,
                isVertical: true,
            });
            var scale = os.scale;
            expect(scale).toBeDefined();
            // Proves scale is linear
            expect(scale.invert).toBeDefined();
            var values = os.values;
            expect(values).toBeDefined();
            expect(values.length).toEqual(2);
            expect(values[1]).toBe('50 %');
        });
    });
    describe("AxisHelper column type tests", function () {
        it('createOrdinalType', function () {
            var ordinalType = AxisHelper.createOrdinalType();
            expect(AxisHelper.isOrdinal(ordinalType)).toBe(true);
            expect(AxisHelper.isDateTime(ordinalType)).toBe(false);
        });
        it('isOrdinal not valid for DateTime', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ dateTime: true }))).toBe(false);
        });
        it('isOrdinal valid for bool', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ bool: true }))).toBe(true);
        });
        it('isOrdinal not valid for numeric', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ numeric: true }))).toBe(false);
        });
        it('isOrdinal valid for text', function () {
            expect(AxisHelper.isOrdinal(ValueType.fromDescriptor({ text: true }))).toBe(true);
        });
        it('isDateTime valid for DateTime', function () {
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ dateTime: true }))).toBe(true);
        });
        it('isDateTime not valid for non-DateTIme', function () {
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ numeric: true }))).toBe(false);
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ text: true }))).toBe(false);
            expect(AxisHelper.isDateTime(ValueType.fromDescriptor({ bool: true }))).toBe(false);
        });
        it('isDateTime null', function () {
            expect(AxisHelper.isDateTime(null)).toBe(false);
        });
        it('isDateTime undefined', function () {
            expect(AxisHelper.isDateTime(undefined)).toBe(false);
        });
    });
    describe("AxisHelper get Recommended tick values tests", function () {
        var labels = ['VRooom', 'FROM', '1984', 'OR', 'YEAR', '3000', '?', '?'];
        it('max is half the ticks', function () {
            var expected = ['VRooom', '1984', 'YEAR', '?'];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(4, labels);
            expect(actual).toEqual(expected);
        });
        it('max is zero ticks', function () {
            var expected = [];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(0, labels);
            expect(actual).toEqual(expected);
        });
        it('max is negative ticks', function () {
            var expected = [];
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(-1, labels);
            expect(actual).toEqual(expected);
        });
        it('max is equal to ticks', function () {
            var expected = labels;
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(8, labels);
            expect(actual).toEqual(expected);
        });
        it('max is more than ticks', function () {
            var expected = labels;
            var actual = AxisHelper.getRecommendedTickValuesForAnOrdinalRange(10, labels);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: ordinal index', function () {
            var expected = [0, 2, 4, 6, 8];
            var scale = AxisHelper.createOrdinalScale(400, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0.4);
            var actual = AxisHelper.getRecommendedTickValues(5, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: ordinal index - zero maxTicks', function () {
            var vals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            var scale = AxisHelper.createOrdinalScale(400, vals, 0.4);
            var actual = AxisHelper.getRecommendedTickValues(0, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual([]);
        });
        it('getRecommendedTickValues: ordinal index - maxTicks greater than len', function () {
            var vals = [0, 1, 2, 3, 4];
            var scale = AxisHelper.createOrdinalScale(400, vals, 0.4);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ text: true }), false);
            expect(actual).toEqual(vals);
        });
        // linear domains are always [min,max], only two values, and are already D3.nice()
        it('getRecommendedTickValues: scalar numeric - easy', function () {
            var expected = [0, 20, 40, 60, 80, 100];
            var scale = AxisHelper.createLinearScale(400, [0, 100]);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: 0 tick count', function () {
            var expected = [];
            var scale = AxisHelper.createLinearScale(400, [0, 100]);
            var actual = AxisHelper.getRecommendedTickValues(0, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: single value domain returns 0 ticks', function () {
            var expected = [];
            var scale = AxisHelper.createLinearScale(400, [1, 1]);
            var actual = AxisHelper.getRecommendedTickValues(5, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: positive range', function () {
            var expected = [60, 80, 100];
            var scale = AxisHelper.createLinearScale(400, [60, 100]);
            var actual = AxisHelper.getRecommendedTickValues(3, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: negative range', function () {
            var expected = [-200, -180, -160, -140, -120, -100];
            var scale = AxisHelper.createLinearScale(400, [-200, -100]);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: 0 between min and max', function () {
            var expected = [0, 50, 100];
            var scale = AxisHelper.createLinearScale(400, [-20, 100]);
            var actual = AxisHelper.getRecommendedTickValues(4, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: very precise decimal values and funny d3 zero tick values', function () {
            // Zero value originally returned from d3 ticks() call is '-1.7763568394002505e-17' (i.e. -1e-33)
            var expected = [-0.15000000000000002, -0.10000000000000002, -0.05000000000000002, 0, 0.04999999999999998, 0.09999999999999998];
            var scale = AxisHelper.createLinearScale(400, [-0.150000000000002, .10000000008000006]);
            var actual = AxisHelper.getRecommendedTickValues(6, scale, ValueType.fromDescriptor({ numeric: true }), true);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: integer type should not return fractional tick values', function () {
            var expected = [0, 1];
            var scale = AxisHelper.createLinearScale(500, [0, 1]);
            var actual = AxisHelper.getRecommendedTickValues(8, scale, ValueType.fromDescriptor({ integer: true }), true, 1);
            expect(actual).toEqual(expected);
        });
        it('getRecommendedTickValues: remove ticks that are more precise than the formatString', function () {
            var expected = [0, 0.1, 0.2, 0.3, 0.4, 0.5];
            var scale = AxisHelper.createLinearScale(500, [0, 0.5]);
            var actual = AxisHelper.getRecommendedTickValues(11, scale, ValueType.fromDescriptor({ numeric: true }), true, 0.1);
            expect(actual).toEqual(expected);
        });
        it('ensureValuesInRange: unsorted tick values', function () {
            var values = [1, 2, 3, 4, 5];
            var actual = AxisHelper.ensureValuesInRange(values, 2.2, 5.5);
            expect(actual).toEqual([3, 4, 5]);
        });
        it('ensureValuesInRange: only one value in range', function () {
            var values = [1, 2, 3, 4, 5];
            var actual = AxisHelper.ensureValuesInRange(values, 1.5, 2.5);
            expect(actual).toEqual([1.5, 2.5]);
        });
        it('ensureValuesInRange: no value in range', function () {
            var values = [1, 2];
            var actual = AxisHelper.ensureValuesInRange(values, 1.25, 1.75);
            expect(actual).toEqual([1.25, 1.75]);
        });
    });
    describe("AxisHelper get best number of ticks tests", function () {
        var dataViewMetadataColumnWithIntegersOnly = [
            {
                displayName: 'col1',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            }
        ];
        var dataViewMetadataColumnWithNonInteger = [
            {
                displayName: 'col1',
                isMeasure: true,
                type: ValueType.fromDescriptor({ integer: true })
            },
            {
                displayName: 'col2',
                isMeasure: true,
                type: ValueType.fromDescriptor({ numeric: true })
            }
        ];
        it('dataViewMetadataColumn with only integers small range', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 3, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(4); // [0,1,2,3]
        });
        it('dataViewMetadataColumn with only integers large range', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 10, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(6);
        });
        it('hundred percent dataViewMetadataColumn with only integers', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 1, dataViewMetadataColumnWithIntegersOnly, 6);
            expect(actual).toBe(6);
        });
        it('dataViewMetadataColumn with non integers', function () {
            var actual = AxisHelper.getBestNumberOfTicks(0, 3, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(6);
        });
        it('dataViewMetadataColumn with NaN min/max', function () {
            var actual = AxisHelper.getBestNumberOfTicks(NaN, 3, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
            actual = AxisHelper.getBestNumberOfTicks(1, NaN, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
            actual = AxisHelper.getBestNumberOfTicks(NaN, NaN, dataViewMetadataColumnWithNonInteger, 6);
            expect(actual).toBe(3);
        });
    });
    describe("AxisHelper diffScaled", function () {
        var scale;
        beforeEach(function () {
            var range = [0, 999];
            var domain = [0, 1, 2, 3, 4, 5, 6, 7, 8, 999];
            scale = d3.scale.linear()
                .range(range)
                .domain(domain);
        });
        it('diffScaled: zero', function () {
            expect(AxisHelper.diffScaled(scale, 0, 0)).toBe(0);
        });
        it('diffScaled: small nonzero +ve', function () {
            expect(AxisHelper.diffScaled(scale, 0.00000001, 0)).toBe(1);
        });
        it('diffScaled: small nonzero -ve', function () {
            expect(AxisHelper.diffScaled(scale, -0.00000001, 0)).toBe(-1);
        });
    });
    describe("AxisHelper getRecommendedNumberOfTicks tests", function () {
        it('getRecommendedNumberOfTicksForXAxis small tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(220);
            expect(tickCount).toBe(3);
        });
        it('getRecommendedNumberOfTicksForXAxis median tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(480);
            expect(tickCount).toBe(5);
        });
        it('getRecommendedNumberOfTicksForXAxis large tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForXAxis(730);
            expect(tickCount).toBe(8);
        });
        it('getRecommendedNumberOfTicksForYAxis small tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(80);
            expect(tickCount).toBe(3);
        });
        it('getRecommendedNumberOfTicksForYAxis median tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(230);
            expect(tickCount).toBe(5);
        });
        it('getRecommendedNumberOfTicksForYAxis large tile', function () {
            var tickCount = AxisHelper.getRecommendedNumberOfTicksForYAxis(350);
            expect(tickCount).toBe(8);
        });
    });
    describe("AxisHelper margins", function () {
        var viewPort = { width: 10, height: 20 };
        var xAxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [87, 78],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var y1AxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [20, 30, 50],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var y2AxisProperties = {
            scale: undefined,
            axis: undefined,
            values: [2000, 3000, 5000],
            axisType: undefined,
            formatter: undefined,
            axisLabel: '',
            isCategoryAxis: true,
            xLabelMaxWidth: 20,
        };
        var textProperties = {
            fontFamily: '',
            fontSize: '16',
        };
        it('Check that margins are calculatde correctly when you render 2 axes', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, true, true, true);
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(12);
            expect(tickCount.yRight).toBe(24);
        });
        it('Check that margins are calculated correctly when you hide all axes', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, false, false, false);
            expect(tickCount.xMax).toBe(0);
            expect(tickCount.yLeft).toBe(0);
            expect(tickCount.yRight).toBe(0);
        });
        it('Disable the secondary axis', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, false, true, true, false); //don't display secondary which is on the left now
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(12);
            expect(tickCount.yRight).toBe(0);
        });
        it('Switch the y-axes, and disable the secondary axis', function () {
            var tickCount = AxisHelper.getTickLabelMargins(viewPort, 20, powerbi.TextMeasurementService.measureSvgTextWidth, xAxisProperties, y1AxisProperties, true, 77, textProperties, y2AxisProperties, undefined, true, true, true, false); //don't display secondary which is on the left now
            expect(tickCount.xMax).toBe(7);
            expect(tickCount.yLeft).toBe(0);
            expect(tickCount.yRight).toBe(12);
        });
    });
    describe("AxisHelper apply new domain", function () {
        it('Check that customized domain is set on existing domain', function () {
            var customizedDomain = [undefined, 20];
            var existingDomain = [0, 10];
            var newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(0);
            expect(newDomain[1]).toBe(20);
            customizedDomain = [undefined, undefined];
            existingDomain = [0, 10];
            newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(0);
            expect(newDomain[1]).toBe(10);
            customizedDomain = [5, undefined];
            existingDomain = [0, 10];
            newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(5);
            expect(newDomain[1]).toBe(10);
            customizedDomain = [5, 20];
            existingDomain = [0, 10];
            newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(5);
            expect(newDomain[1]).toBe(20);
        });
        it('Check that customized domain is set on null domain', function () {
            var customizedDomain = [undefined, undefined];
            var existingDomain;
            var newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain).toBeUndefined();
            customizedDomain = [10, 20];
            var existingDomain;
            var newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(10);
            expect(newDomain[1]).toBe(20);
            customizedDomain = [undefined, 20];
            var existingDomain;
            var newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(undefined);
            expect(newDomain[1]).toBe(20);
            customizedDomain = [10, undefined];
            var existingDomain;
            var newDomain = AxisHelper.applyCustomizedDomain(customizedDomain, existingDomain);
            expect(newDomain[0]).toBe(10);
            expect(newDomain[1]).toBe(undefined);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ColorHelper = powerbi.visuals.ColorHelper;
    var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
    describe("Color Helper", function () {
        var palette;
        var columnIdentity = powerbi.data.SQExprBuilder.fieldDef({ schema: "s", entity: "e", column: "sales" });
        var fillProp = { objectName: "dataPoint", propertyName: "fill" };
        var colors = [
            { value: "#000000" },
            { value: "#000001" },
            { value: "#000002" },
            { value: "#000003" }
        ];
        beforeEach(function () {
            palette = new powerbi.visuals.DataColorPalette(colors);
        });
        describe("getColorForSeriesValue", function () {
            it("should return fill property value if it exists", function () {
                var colorHelper = new ColorHelper(palette, fillProp, "defaultColor");
                var objects = {
                    dataPoint: {
                        fill: { solid: { color: "red" } }
                    }
                };
                var color = colorHelper.getColorForSeriesValue(objects, [columnIdentity], "value");
                expect(color).toEqual("red");
            });
            it("should return default color if no fill property is defined", function () {
                var colorHelper = new ColorHelper(palette, fillProp, "defaultColor");
                var color = colorHelper.getColorForSeriesValue(undefined, [columnIdentity], "value");
                expect(color).toEqual("defaultColor");
            });
            it("should return scale color if neither fill property nor default color is defined", function () {
                var colorHelper = new ColorHelper(palette, fillProp, undefined);
                var color = colorHelper.getColorForSeriesValue(undefined, [columnIdentity], "value");
                var expectedColor = palette.getColorScaleByKey(SQExprShortSerializer.serializeArray([columnIdentity])).getColor("value").value;
                expect(color).toEqual(expectedColor);
            });
            it("should handle undefined identity array", function () {
                var colorHelper = new ColorHelper(palette, fillProp);
                var color = colorHelper.getColorForSeriesValue(undefined, undefined, "value");
                var expectedColor = palette.getColorScaleByKey(SQExprShortSerializer.serializeArray([])).getColor("value").value;
                expect(color).toEqual(expectedColor);
            });
            it("should return the same color for the same series and value", function () {
                var colorHelper = new ColorHelper(palette, fillProp);
                var color1 = colorHelper.getColorForSeriesValue(null, [columnIdentity], "value");
                var color2 = colorHelper.getColorForSeriesValue(null, [columnIdentity], "value");
                expect(color1).toEqual(color2);
            });
        });
        describe("getColorForMeasure", function () {
            it("should return fill property value if it exists", function () {
                var colorHelper = new ColorHelper(palette, fillProp, "defaultColor");
                var objects = {
                    dataPoint: {
                        fill: { solid: { color: "red" } }
                    }
                };
                var color = colorHelper.getColorForMeasure(objects, 0);
                expect(color).toEqual("red");
            });
            it("should return default color if no fill property is defined", function () {
                var colorHelper = new ColorHelper(palette, fillProp, "defaultColor");
                var color = colorHelper.getColorForMeasure(undefined, 0);
                expect(color).toEqual("defaultColor");
            });
            it("should return scale color if neither fill property nor default color is defined", function () {
                var colorHelper = new ColorHelper(palette, fillProp, undefined);
                var color = colorHelper.getColorForMeasure(undefined, 0);
                expect(color).toEqual(colors[0].value);
            });
            it("should return the nth color for the nth measure even if colors are explicitly set", function () {
                var colorHelper = new ColorHelper(palette, fillProp);
                var objects = {
                    dataPoint: { fill: { solid: { color: "red" } } }
                };
                var color1 = colorHelper.getColorForMeasure(null, 0);
                var color2 = colorHelper.getColorForMeasure(objects, 1);
                var color3 = colorHelper.getColorForMeasure(null, 2);
                expect(color1).toEqual(colors[0].value);
                expect(color2).toEqual("red");
                expect(color3).toEqual(colors[2].value);
            });
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    describe("converterHelper tests", function () {
        it('categoryIsAlsoSeriesRole default', function () {
            var dataView = createCategoricalDataView({});
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
            // Only a 'Series' role prevents us from using the Default strategy
            var dataView = createCategoricalDataView({ 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
            var dataView = createCategoricalDataView({ 'E === mc^2': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBeFalsy();
        });
        it('categoryIsAlsoSeriesRole series and category', function () {
            var dataView = createCategoricalDataView({ 'Series': true, 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBe(true);
            var dataView = createCategoricalDataView({ 'Series': true, 'F === ma': true, 'Category': true });
            expect(powerbi.visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, 'Series', 'Category')).toBe(true);
        });
        it('getPivotedCategories default', function () {
            var dataView = createCategoricalDataView({});
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            // Note: Since the result includes a function property we can't perform a toEqual directly on the result, so check each part individually.
            expect(categoryInfo.categories).toEqual(['a', 'b']);
            expect(categoryInfo.categoryIdentities).toEqual([dataView.categories[0].identity[0], dataView.categories[0].identity[1]]);
        });
        it('getPivotedCategories empty categories', function () {
            var dataView = createCategoricalDataView({});
            // Empty the categories array
            dataView.categories = [];
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            validateEmptyCategoryInfo(categoryInfo);
        });
        it('getPivotedCategories empty category values', function () {
            var dataView = createCategoricalDataView({});
            // Empty the category values array
            dataView.categories[0].values = [];
            var categoryInfo = powerbi.visuals.converterHelper.getPivotedCategories(dataView, formatStringProp());
            expect(categoryInfo.categories).toEqual([]);
            expect(categoryInfo.categoryIdentities).toBeUndefined();
        });
        function validateEmptyCategoryInfo(categoryInfo) {
            // Note: Since the result includes a function property we can't perform a toEqual directly on the result, so check each part individually.
            expect(categoryInfo.categories).toEqual([null]);
            expect(categoryInfo.categoryIdentities).toBeUndefined();
        }
        function createCategoricalDataView(roles) {
            var metadata = {
                columns: [
                    { displayName: 'col1', roles: roles },
                    { displayName: 'col2', isMeasure: true, roles: { 'Y': true } },
                ]
            };
            return {
                categories: [{
                        source: metadata.columns[0],
                        values: ['a', 'b'],
                        identity: [
                            powerbitests.mocks.dataViewScopeIdentity('a'),
                            powerbitests.mocks.dataViewScopeIdentity('b'),
                        ]
                    }],
                values: powerbi.data.DataViewTransform.createValueColumns([
                    {
                        source: metadata.columns[1],
                        values: [100, 200]
                    }])
            };
        }
        function formatStringProp() {
            return { objectName: 'general', propertyName: 'formatString' };
        }
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var DataLabelUtils = powerbi.visuals.dataLabelUtils;
    var DefaultWaitForRender = 100;
    powerbitests.mocks.setLocale();
    describe("dataLabelUtils Line Chart Collision Detection", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    queryName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    queryName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    queryName: 'col3',
                    isMeasure: false,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),
                    format: 'd'
                }],
            objects: { labels: { show: true } },
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('500', '145');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('lineChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 490000, 480000, 500000],
                                    subtotal: 2465000
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                // Only the top two label should be hidden
                expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(3);
                expect($('.lineChart .axisGraphicsContext .labels .data-labels').first().text()).toContain("495");
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            var metadata = powerbi.Prototype.inherit(dataViewMetadata);
            //label format will be overriden by label settings
            metadata.objects = { labels: { show: true, labelPrecision: 3 } };
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 495050, 480000, 500000],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                // Two label should be hidden because it collides
                expect($('.lineChart .axisGraphicsContext .labels .data-labels').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels DOM validation', function (done) {
            var metadata = powerbi.Prototype.inherit(dataViewMetadata);
            //label format will be overriden by label settings
            metadata.objects = { labels: { show: true, labelPrecision: 3 } };
            element = powerbitests.helpers.testDom('10', '10');
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
            v.onDataChanged({
                dataViews: [{
                        metadata: metadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['a', 'b', 'c', 'd', 'e']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [500000, 495000, 495050, 480000, 500000],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                // All labels should be hidden and no 'labels' class should be created
                expect($('.lineChart .axisGraphicsContext .labels').length).toBe(0);
                done();
            }, DefaultWaitForRender);
        });
        it('undefined labelSettings validation', function () {
            var labelSettings;
            var instance = DataLabelUtils.enumerateDataLabels(labelSettings, false);
            expect(instance).toEqual([]);
        });
    });
    describe("dataLabelUtils Scatter Chart Collision Detection", function () {
        var v, element;
        var dataViewMetadata = {
            columns: [
                {
                    displayName: 'col1',
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: 'col2',
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    format: '0.000'
                },
                {
                    displayName: 'col3',
                    isMeasure: false,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),
                    format: 'd'
                }],
            objects: { categoryLabels: { show: true } },
        };
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            element = powerbitests.helpers.testDom('250', '200');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('scatterChart').create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Show labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['First', 'Second', 'Third', 'Fourth']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [110, 120, 130, 140],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                // No label should be hidden
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(4);
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').first().text()).toBe('First');
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            v.onDataChanged({
                dataViews: [{
                        metadata: dataViewMetadata,
                        categorical: {
                            categories: [{
                                    source: dataViewMetadata.columns[0],
                                    values: ['First', 'Second', 'Third', 'Fourth', 'Fifth']
                                }],
                            values: DataViewTransform.createValueColumns([{
                                    source: dataViewMetadata.columns[1],
                                    values: [110, 120, 130, 140, 150],
                                }])
                        }
                    }]
            });
            setTimeout(function () {
                // Two labels should be hidden because they collides
                expect($('.scatterChart .axisGraphicsContext .mainGraphicsContext .data-labels').length).toBe(3);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("dataLabelUtils Map Collision Detection", function () {
        var mockDatalabelSettings = {
            show: true,
            displayUnits: 2,
            position: 0 /* Above */,
            precision: 2,
            labelColor: "#000000",
            formatterOptions: {},
        };
        var mockViewPort = {
            height: 150,
            width: 300
        };
        afterEach(function () {
            // Clear labels
            $('.data-labels').remove();
        });
        it('Show bubble labels validation', function () {
            var mockBubbleData = [
                {
                    x: 0,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                },
                {
                    x: 50,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapBubbles1", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapBubbles1 text').length).toBe(2);
        });
        it('Hide bubble labels validation', function () {
            var mockBubbleData = [
                {
                    x: 45,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                },
                {
                    x: 50,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockBubbleGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapBubbles2", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockBubbleData, mockBubbleGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapBubbles2 text').length).toBe(1);
        });
        it('Show slice labels validation', function () {
            var mockSliceData = [
                {
                    x: 0,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                    value: 20,
                },
                {
                    x: 50,
                    y: 55,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                    value: 20,
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockSliceGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapSlice1", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockSliceGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapSlice1 text').length).toBe(2);
        });
        it('Hide slice labels validation', function () {
            var mockSliceData = [
                {
                    x: 45,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 1",
                    value: 20,
                },
                {
                    x: 50,
                    y: 60,
                    radius: 10,
                    fill: "#000000",
                    stroke: "2",
                    strokeWidth: 2,
                    selected: true,
                    identity: null,
                    labeltext: "Label 2",
                    value: 20,
                }];
            var mockLayout = DataLabelUtils.getMapLabelLayout(mockDatalabelSettings);
            var mockSliceGraphicsContext = d3.select('body')
                .append('svg')
                .style("position", "absolute")
                .append("g")
                .classed("mapSlice2", true);
            var result = DataLabelUtils.drawDefaultLabelsForDataPointChart(mockSliceData, mockSliceGraphicsContext, mockLayout, mockViewPort);
            expect(result).toBeDefined();
            expect($('.mapSlice2 text').length).toBe(1);
        });
    });
    function columnChartDataLabelsShowValidation(chartType, collide) {
        var v, element;
        var dataViewMetadataThreeColumn = [
            {
                displayName: 'col1',
                queryName: 'col1',
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
            },
            {
                displayName: 'col2',
                queryName: 'col2',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            },
            {
                displayName: 'col3',
                queryName: 'col3',
                isMeasure: true,
                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
            }
        ];
        function metadata(columns) {
            var metadata = {
                columns: columns,
            };
            metadata.objects = {
                labels: { show: true, labelPrecision: 0, color: { solid: { color: '#FF0000' } } }
            };
            return metadata;
        }
        var hostServices = powerbitests.mocks.createVisualHostServices();
        beforeEach(function () {
            if (collide)
                element = powerbitests.helpers.testDom('100', '100');
            else
                element = powerbitests.helpers.testDom('500', '500');
            v = powerbi.visuals.visualPluginFactory.create().getPlugin(chartType).create();
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true },
            });
        });
        it('Data Label Visibility Validation', function (done) {
            var categoryIdentities = [
                powerbitests.mocks.dataViewScopeIdentity("John Domo"),
                powerbitests.mocks.dataViewScopeIdentity("Delta Force"),
                powerbitests.mocks.dataViewScopeIdentity("Mr Bing"),
            ];
            var dataView = {
                metadata: metadata(dataViewMetadataThreeColumn),
                categorical: {
                    categories: [{
                            source: dataViewMetadataThreeColumn[0],
                            values: ['John Domo', 'Delta Force', 'Mr Bing'],
                            identity: categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadataThreeColumn[1],
                            values: [20, 20, 100],
                            subtotal: 140
                        }])
                }
            };
            v.onDataChanged({ dataViews: [dataView] });
            var labels = $('.data-labels');
            setTimeout(function () {
                if (collide)
                    switch (chartType) {
                        case 'columnChart':
                        case 'clusteredColumnChart':
                            expect(labels.length).toBe(2);
                            break;
                        case 'barChart':
                        case 'clusteredBarChart':
                            expect(labels.length).toBe(3);
                            break;
                        //Formatting support localization, 100.00% will be displayed as 100% so the label will be displayed.
                        case 'hundredPercentStackedColumnChart':
                            expect(labels.length).toBe(0);
                            break;
                        case 'hundredPercentStackedBarChart':
                            expect(labels.length).toBe(3);
                            break;
                    }
                else
                    switch (chartType) {
                        case 'columnChart':
                        case 'barChart':
                        case 'clusteredColumnChart':
                        case 'clusteredBarChart':
                            expect(labels.length).toBe(3);
                            break;
                        case 'hundredPercentStackedColumnChart':
                        case 'hundredPercentStackedBarChart':
                            expect(labels.length).toBe(3);
                            break;
                    }
                done();
            }, DefaultWaitForRender);
        });
    }
    describe("Stacked Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('barChart', false); });
    describe("Clustered Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('clusteredBarChart', false); });
    describe("Hundred Percent Stacked Bar Chart show labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedBarChart', false); });
    describe("Stacked Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('columnChart', false); });
    describe("Clustered Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('clusteredColumnChart', false); });
    describe("Hundred Percent Stacked Column Chart show labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedColumnChart', false); });
    describe("Stacked Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('barChart', true); });
    describe("Clustered Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('clusteredBarChart', true); });
    describe("Hundred Percent Stacked Bar Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedBarChart', true); });
    describe("Stacked Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('columnChart', true); });
    describe("Clustered Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('clusteredColumnChart', true); });
    describe("Hundred Percent Stacked Column Chart hide labels validation", function () { return columnChartDataLabelsShowValidation('hundredPercentStackedColumnChart', true); });
    describe("dataLabelUtils Waterfall Chart Collision Detection", function () {
        var v, element;
        ;
        var DataViewTransform = powerbi.data.DataViewTransform;
        //only 2 values should be visible due to collision detection
        var values = [100, 50, 100];
        var categories = [2010, 2011, 2012];
        var categoryIdentities = [
            powerbitests.mocks.dataViewScopeIdentity(2010),
            powerbitests.mocks.dataViewScopeIdentity(2011),
            powerbitests.mocks.dataViewScopeIdentity(2012),
        ];
        var categoryColumn = { displayName: 'year', queryName: 'selectYear', type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text) };
        var measureColumn = { displayName: 'sales', queryName: 'selectSales', isMeasure: true, type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Integer), objects: { general: { formatString: '$0' } } };
        var dataView = {
            categories: [{
                    source: categoryColumn,
                    values: categories,
                    identity: categoryIdentities
                }],
            values: DataViewTransform.createValueColumns([{
                    source: measureColumn,
                    values: values,
                }]),
        };
        var metadata = {
            columns: [categoryColumn, measureColumn],
        };
        var data = {
            categorical: dataView,
            metadata: metadata,
        };
        beforeEach(function () {
            v = powerbi.visuals.visualPluginFactory.create().getPlugin('waterfallChart').create();
        });
        it('Show labels validation', function (done) {
            element = powerbitests.helpers.testDom('500', '500');
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            data.metadata.objects = {
                labels: {
                    show: true,
                }
            };
            var dataChangedOptions = {
                dataViews: [data]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.labels text').length).toBe(4);
                done();
            }, DefaultWaitForRender);
        });
        it('Hide labels validation', function (done) {
            element = powerbitests.helpers.testDom('120', '100');
            v.init({
                element: element,
                host: powerbitests.mocks.createVisualHostServices(),
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                animation: { transitionImmediate: true }
            });
            data.metadata.objects = {
                labels: {
                    show: true,
                }
            };
            var dataChangedOptions = {
                dataViews: [data]
            };
            v.onDataChanged(dataChangedOptions);
            setTimeout(function () {
                expect($('.labels text').length).toBe(2);
                done();
            }, DefaultWaitForRender);
        });
    });
    describe("dataLabelUtils tests", function () {
        it('display units formatting values : Auto', function () {
            var value = 20000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 0;
            labelSettings.precision = 0;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter = formattersCache.getOrCreate(null, labelSettings);
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("20,000");
        });
        it('display units formatting values : K', function () {
            var value = 20000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 10000;
            labelSettings.precision = 0;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter = formattersCache.getOrCreate(null, labelSettings);
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("20K");
        });
        it('display units formatting values : M', function () {
            var value = 200000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000;
            labelSettings.precision = 1;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter = formattersCache.getOrCreate(null, labelSettings);
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("0.2M");
        });
        it('display units formatting values : B', function () {
            var value = 200000000000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000000;
            labelSettings.precision = 0;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter = formattersCache.getOrCreate(null, labelSettings);
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("200bn");
        });
        it('display units formatting values : T', function () {
            var value = 200000000000;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = 1000000000000;
            labelSettings.precision = 1;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter = formattersCache.getOrCreate(null, labelSettings);
            var formattedValue = formatter.format(value);
            expect(formattedValue).toBe("0.2T");
        });
        it('label formatting - multiple formats', function () {
            var formatCol1 = '#,0.0';
            var formatCol2 = '$#,0.0';
            var value = 1545;
            var labelSettings = DataLabelUtils.getDefaultLabelSettings();
            labelSettings.displayUnits = null;
            labelSettings.precision = 1;
            var formattersCache = DataLabelUtils.createColumnFormatterCacheManager();
            var formatter1 = formattersCache.getOrCreate(formatCol1, labelSettings);
            var formattedValue = formatter1.format(value);
            expect(formattedValue).toBe("1,545.0");
            var formatter2 = formattersCache.getOrCreate(formatCol2, labelSettings);
            var formattedValue = formatter2.format(value);
            expect(formattedValue).toBe("$1,545.0");
        });
    });
    describe("dataLabelUtils Test enumerateCategoryLabels", function () {
        it('test default values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, true);
            var objectsNoColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, false);
            expect(objectsWithColor[0].properties['show']).toBe(false);
            expect(objectsNoColor[0].properties['show']).toBe(false);
            expect(objectsWithColor[0].properties['color']).toBe(labelSettings.labelColor);
            expect(objectsNoColor[0].properties['color']).toBeUndefined();
        });
        it('test custom values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            labelSettings.show = true;
            labelSettings.labelColor = '#FF0000';
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, true);
            expect(objectsWithColor[0].properties['show']).toBe(true);
            expect(objectsWithColor[0].properties['color']).toBe('#FF0000');
        });
        it('test category labels objetcs for donut chart', function () {
            var labelSettings = DataLabelUtils.getDefaultDonutLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(labelSettings, false, true);
            expect(objectsWithColor[0].properties['show']).toBe(labelSettings.showCategory);
        });
        it('test null values', function () {
            var labelSettings = DataLabelUtils.getDefaultPointLabelSettings();
            var donutLabelSettings = DataLabelUtils.getDefaultDonutLabelSettings();
            var objectsWithColor = DataLabelUtils.enumerateCategoryLabels(null, true);
            var donutObjectsWithColor = DataLabelUtils.enumerateCategoryLabels(null, false, true);
            expect(objectsWithColor[0].properties['show']).toBe(labelSettings.show);
            expect(objectsWithColor[0].properties['color']).toBe(labelSettings.labelColor);
            expect(donutObjectsWithColor[0].properties['show']).toBe(donutLabelSettings.showCategory);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataRoleHelper = powerbi.visuals.DataRoleHelper;
    var DataViewTransform = powerbi.data.DataViewTransform;
    describe("dataRoleHelper tests", function () {
        it('getMeasureIndexOfRole with roles validation', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                    { displayName: 'col3', isMeasure: true, roles: { "X": true } },
                    { displayName: 'col4', isMeasure: true, roles: { "Y": true } }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [1, 2, 3],
                            subtotal: 6
                        }, {
                            source: dataViewMetadata.columns[3],
                            values: [4, 5, 6],
                            subtotal: 15
                        }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(0);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
            expect(result).toBe(2);
        });
        it('getMeasureIndexOfRole without roles validation', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                    { displayName: 'col3', isMeasure: true },
                    { displayName: 'col4', isMeasure: true }
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }, {
                            source: dataViewMetadata.columns[2],
                            values: [1, 2, 3],
                            subtotal: 6
                        }, {
                            source: dataViewMetadata.columns[3],
                            values: [4, 5, 6],
                            subtotal: 15
                        }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = DataRoleHelper.getMeasureIndexOfRole(grouped, "InvalidRoleName");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
            expect(result).toBe(-1);
            result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
            expect(result).toBe(-1);
        });
        it('getMeasureIndexOfRole without roles validation with default too few measures', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1' },
                    { displayName: 'col2', isMeasure: true },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata,
                categorical: {
                    categories: [{
                            source: dataViewMetadata.columns[0],
                            values: ['Montana', 'California', 'Arizona']
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: dataViewMetadata.columns[1],
                            values: [-100, 200, 700],
                            subtotal: 800
                        }])
                }
            };
            var grouped = dataView.categorical.values.grouped();
            var result = powerbi.visuals.DataRoleHelper.getMeasureIndexOfRole(grouped, "2nd measure");
            expect(result).toBe(-1);
        });
        it('hasRoleInDataView', function () {
            var dataViewMetadata = {
                columns: [
                    { displayName: 'col1', roles: { 'Series': true } },
                    { displayName: 'col2', isMeasure: true, roles: { "Size": true } },
                ]
            };
            var dataView = {
                metadata: dataViewMetadata
            };
            expect(DataRoleHelper.hasRoleInDataView(dataView, 'Series')).toBe(true);
            expect(DataRoleHelper.hasRoleInDataView(dataView, 'Category')).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    describe("GradientUtils", function () {
        it("getFillRuleRole with fillRule", function () {
            var desc = {
                test: {
                    displayName: "displayName",
                    properties: {
                        fillRule: {
                            displayName: "fillRule",
                            type: { fillRule: {} },
                            rule: {
                                inputRole: "inputRoleValue"
                            }
                        }
                    }
                }
            };
            expect(powerbi.visuals.GradientUtils.getFillRuleRole(desc)).toBe("inputRoleValue");
        });
        it("getFillRuleRole without fillRule", function () {
            var desc = {
                test: {
                    displayName: "displayName",
                    properties: {
                        fill: {
                            displayName: "fill",
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            };
            expect(powerbi.visuals.GradientUtils.getFillRuleRole(desc)).toBeUndefined();
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    var DataViewTransform = powerbi.data.DataViewTransform;
    describe("InvalidDataValuesCheckerTests", function () {
        var dataViewBuilder;
        var categoryValues = ["a", "b", "c", "d", "e"];
        var dataViewMetadata = {
            columns: [
                {
                    displayName: "stringColumn",
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: "numberColumn",
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double),
                    format: "0.000"
                },
                {
                    displayName: "dateTimeColumn",
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime)
                }
            ]
        };
        beforeEach(function () {
            dataViewBuilder = new DataViewBuilder();
            dataViewBuilder.metadata = dataViewMetadata;
            dataViewBuilder.categoryValues = categoryValues;
        });
        it("empty values does not display a warning all supported.", function () {
            dataViewBuilder.values = [];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it("empty values does not display a warning none supported.", function () {
            dataViewBuilder.values = [];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it("single value does not display a warning all supported.", function () {
            dataViewBuilder.values = [300];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it("single value does not display a warning none supported.", function () {
            dataViewBuilder.values = [300];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it("NaN value does not display a warning when supported.", function () {
            dataViewBuilder.values = [NaN];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it("NaN value does not display a warning when others not supported.", function () {
            dataViewBuilder.values = [NaN];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, false, false);
            expect(warnings.length).toBe(0);
        });
        it("NaN value displays a warning when not supported.", function () {
            dataViewBuilder.values = [NaN];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("NaNNotSupported");
        });
        it("NaN value displays a warning when not supported but others are supported.", function () {
            dataViewBuilder.values = [[NaN]];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("NaNNotSupported");
        });
        it("Negative infinity value does not display a warning when supported.", function () {
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it("Negative infinity value does not display a warning when others not supported.", function () {
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, false);
            expect(warnings.length).toBe(0);
        });
        it("Negative infinity value displays a warning when not supported.", function () {
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            var i = 0;
            expect(warnings[i++].code).toBe("InfinityValuesNotSupported");
        });
        it("Negative infinity value displays a warning when not supported but others are supported.", function () {
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, false, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("InfinityValuesNotSupported");
        });
        it("Positive infinity value does not display a warning when supported.", function () {
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(0);
        });
        it("Positive infinity value does not display a warning when others not supported.", function () {
            dataViewBuilder.values = [Number.POSITIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, true);
            expect(warnings.length).toBe(0);
        });
        it("Postive infinity value displays a warning when not supported.", function () {
            dataViewBuilder.values = [Number.POSITIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("InfinityValuesNotSupported");
        });
        it("Positive infinity value displays a warning when not supported but others are supported.", function () {
            dataViewBuilder.values = [Number.POSITIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("InfinityValuesNotSupported");
        });
        it("Out of range value displays a warning when others are supported.", function () {
            dataViewBuilder.values = [1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("ValuesOutOfRange");
        });
        it("Negative out of range value displays a warning when others are supported.", function () {
            dataViewBuilder.values = [-27e300];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], true, true, true);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("ValuesOutOfRange");
        });
        it("Out of range value displays a warning when others are not supported.", function () {
            dataViewBuilder.values = [1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("ValuesOutOfRange");
        });
        it("Negative out of range value displays a warning when others are not supported.", function () {
            dataViewBuilder.values = [1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(1);
            expect(warnings[0].code).toBe("ValuesOutOfRange");
        });
        it("NaN and infinity sends warning for both when all not supported", function () {
            dataViewBuilder.values = [NaN, Number.POSITIVE_INFINITY];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(2);
            var i = 0;
            expect(warnings[i++].code).toBe("NaNNotSupported");
            expect(warnings[i++].code).toBe("InfinityValuesNotSupported");
        });
        it("NaN and infinity and out of range sends warning for all when all not supported", function () {
            dataViewBuilder.values = [NaN, Number.POSITIVE_INFINITY, 1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var i = 0;
            expect(warnings[i++].code).toBe("NaNNotSupported");
            expect(warnings[i++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[i++].code).toBe("ValuesOutOfRange");
        });
        it("NaN and infinity and out of range sends warning for all when all not supported has no duplications", function () {
            dataViewBuilder.values = [NaN, Number.POSITIVE_INFINITY, 1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("NaN and infinity and out of range sends warning for all when Infinity supported has no infinity warning", function () {
            dataViewBuilder.values = [NaN, Number.POSITIVE_INFINITY, NaN, 1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, true, true);
            expect(warnings.length).toBe(2);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("NaN and infinity and out of range sends warning for all with good values at the beginning", function () {
            dataViewBuilder.values = [100, 200, 300, 400, NaN, Number.POSITIVE_INFINITY, NaN, 1e301];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("NaN and infinity and out of range sends warning for all with good values throughout", function () {
            dataViewBuilder.values = [100, 200, NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500];
            var dataView = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("Multiple dataViews both good does not show a warning", function () {
            dataViewBuilder.values = [100, 200, 500];
            var dataView = dataViewBuilder.build();
            dataViewBuilder.values = [200, 300, 400];
            var dataView2 = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(0);
        });
        it("Multiple dataviews first has invalid shows warnings", function () {
            dataViewBuilder.values = [100, 200, NaN, undefined];
            var dataView = dataViewBuilder.build();
            dataViewBuilder.values = [100, 200, 300];
            var dataView2 = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(1);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
        });
        it("Multiple datasets last has invalid values shows warnings", function () {
            dataViewBuilder.values = [100, 200, 300, 400];
            var dataView = dataViewBuilder.build();
            dataViewBuilder.values = [100, 200, NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500];
            var dataView2 = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("Multiple dataViews both have invalid values shows correct warning", function () {
            dataViewBuilder.values = [100, 200, Number.NaN, 300, Number.POSITIVE_INFINITY, NaN, 400, 1e301, 500];
            var dataView = dataViewBuilder.build();
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY, Number.NaN, 300, 1e301];
            var dataView2 = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
        it("Multiple dataViews both have invalid values not overlapping shows correct warning", function () {
            dataViewBuilder.values = [100, 200, 300, Number.POSITIVE_INFINITY, 400, 1e301, 500];
            var dataView = dataViewBuilder.build();
            dataViewBuilder.values = [Number.NEGATIVE_INFINITY, Number.NaN, 300];
            var dataView2 = dataViewBuilder.build();
            var warnings = powerbi.visuals.getInvalidValueWarnings([dataView, dataView2], false, false, false);
            expect(warnings.length).toBe(3);
            var index = 0;
            expect(warnings[index++].code).toBe("NaNNotSupported");
            expect(warnings[index++].code).toBe("InfinityValuesNotSupported");
            expect(warnings[index++].code).toBe("ValuesOutOfRange");
        });
    });
    var DataViewBuilder = (function () {
        function DataViewBuilder() {
        }
        DataViewBuilder.prototype.buildCategoryIdentities = function () {
            if (this.categoryValues) {
                this.categoryIdentities =
                    this.categoryValues.map(function (item) { return powerbitests.mocks.dataViewScopeIdentity(item); });
            }
        };
        DataViewBuilder.prototype.build = function () {
            this.buildCategoryIdentities();
            return {
                metadata: this.metadata,
                categorical: {
                    categories: [{
                            source: this.metadata.columns[0],
                            values: this.categoryValues,
                            identity: this.categoryIdentities
                        }],
                    values: DataViewTransform.createValueColumns([{
                            source: this.metadata.columns[1],
                            values: this.values
                        }])
                }
            };
        };
        return DataViewBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var ListViewFactory = powerbi.visuals.ListViewFactory;
    describe("List view tests", function () {
        var listViewBuilder;
        var data = [
            { first: "Mickey", second: "Mouse" },
            { first: "Mini", second: "Mouse" },
            { first: "Daffy", second: "Duck" },
            { first: "Captain", second: "Planet" },
            { first: "Russell", second: "Wilson" },
            { first: "Jack", second: "Sparrow" },
            { first: "James", second: "Bond" },
            { first: "Sea", second: "Hawks" },
            { first: "Sachin", second: "Patney" }
        ];
        beforeEach(function () {
            listViewBuilder = new ListViewBuilder();
            listViewBuilder.data = data;
        });
        it("Create HTML List View Correctly", function (done) {
            listViewBuilder.buildHtmlListView();
            setTimeout(function () {
                var itemCount = listViewBuilder.element.find(".item").length;
                expect(itemCount).toBeGreaterThan(0);
                expect(itemCount).toBeLessThan(9); // Some should be virtualized, so shouldn"t show all 9 items
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Create SVG List View Correctly", function (done) {
            listViewBuilder.buildSvgListView();
            setTimeout(function () {
                var itemCount = listViewBuilder.element.find(".item").length;
                expect(itemCount).toBeGreaterThan(0);
                expect(itemCount).toBeLessThan(9); // Some should be virtualized, so shouldn"t show all 9 items
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Scroll to last to check if items come in view HTML", function (done) {
            listViewBuilder.isSpy = true;
            listViewBuilder.buildHtmlListView();
            var lastElem = listViewBuilder.element.find(".item").last().text();
            expect(lastElem).not.toEqual("-->Sachin-->Patney");
            listViewBuilder.element.scrollTop(1000);
            setTimeout(function () {
                var lastElem2 = listViewBuilder.element.find(".item").last().text();
                expect(lastElem2).toEqual("-->Sachin-->Patney");
                expect(listViewBuilder.spy).toHaveBeenCalled();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Scroll to last to check if items come in view SVG", function (done) {
            listViewBuilder.isSpy = true;
            listViewBuilder.buildSvgListView();
            var lastElem = listViewBuilder.element.find(".item").last().text();
            expect(lastElem).not.toEqual("-->Sachin-->Patney");
            listViewBuilder.element.scrollTop(1000);
            setTimeout(function () {
                var lastElem2 = listViewBuilder.element.find(".item").last().text();
                expect(lastElem2).toEqual("-->Sachin-->Patney");
                expect(listViewBuilder.spy).toHaveBeenCalled();
                done();
            }, powerbitests.DefaultWaitForRender);
        });
        it("Reset scrollbar position when ResetScrollbar flag is set", function (done) {
            listViewBuilder.data = [
                { first: "Mickey", second: "Mouse" },
                { first: "Mini", second: "Mouse" },
                { first: "Daffy", second: "Duck" },
                { first: "Captain", second: "Planet" },
                { first: "Russell", second: "Wilson" },
                { first: "Jack", second: "Sparrow" },
                { first: "James", second: "Bond" },
                { first: "Sea", second: "Hawks" }
            ];
            listViewBuilder.buildHtmlListView();
            listViewBuilder.element.scrollTop(1000);
            setTimeout(function () {
                expect(listViewBuilder.element.find(".scrollRegion").first().parent().scrollTop()).toBe(40);
                listViewBuilder.render(true, false);
                expect(listViewBuilder.element.find(".scrollRegion").first().parent().scrollTop()).toBe(40);
                listViewBuilder.render(true, true);
                expect(listViewBuilder.element.find(".scrollRegion").first().parent().scrollTop()).toBe(0);
                done();
            }, powerbitests.DefaultWaitForRender);
        });
    });
    var ListViewBuilder = (function () {
        function ListViewBuilder(width, height) {
            if (width === void 0) { width = 200; }
            if (height === void 0) { height = 200; }
            this.isSpy = false;
            this.setSize(width, height);
        }
        ListViewBuilder.prototype.rowExit = function (rowSelection) {
            rowSelection.remove();
        };
        Object.defineProperty(ListViewBuilder.prototype, "spy", {
            get: function () {
                return this._spy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListViewBuilder.prototype, "listView", {
            get: function () {
                return this._listView;
            },
            enumerable: true,
            configurable: true
        });
        ListViewBuilder.prototype.setSize = function (width, height) {
            this.width = width;
            this.height = height;
            this.init();
        };
        ListViewBuilder.prototype.init = function () {
            this.element = powerbitests.helpers.testDom(this.height.toString(), this.width.toString());
        };
        ListViewBuilder.prototype.buildHtmlListViewOptions = function () {
            var rowEnter = function (rowSelection) {
                rowSelection
                    .append("div")
                    .style("height", "30px")
                    .classed("item", true)
                    .selectAll("span")
                    .data(function (d) {
                    return d.children;
                })
                    .enter()
                    .append("span");
            };
            var rowUpdate = function (rowSelection) {
                rowSelection
                    .selectAll(".item")
                    .selectAll("span")
                    .text(function (d) {
                    return "-->" + d.name;
                });
            };
            this.createOptions(rowEnter, rowUpdate);
        };
        ListViewBuilder.prototype.buildSvgListViewOptions = function () {
            var rowEnterSVG = function (rowSelection) {
                rowSelection
                    .append("g")
                    .style("height", "30px")
                    .classed("item", true)
                    .selectAll("g")
                    .data(function (d) {
                    return d.children;
                })
                    .enter()
                    .append("span")
                    .classed("column", true);
            };
            var rowUpdateSVG = function (rowSelection) {
                rowSelection
                    .selectAll(".item")
                    .selectAll(".column")
                    .text(function (d) {
                    return "-->" + d.name;
                });
            };
            this.createOptions(rowEnterSVG, rowUpdateSVG);
        };
        ListViewBuilder.prototype.createOptions = function (rowEnter, rowUpdate) {
            this.options = {
                enter: rowEnter,
                exit: this.rowExit,
                update: rowUpdate,
                loadMoreData: function () { },
                baseContainer: d3.select(this.element.get(0)),
                rowHeight: 30,
                viewport: { height: this.height, width: this.width }
            };
        };
        ListViewBuilder.prototype.generateNestedData = function (tuples) {
            var testData = [];
            for (var i = 0; i < this.data.length; i++) {
                testData.push({
                    id: i,
                    children: [
                        { name: this.data[i].first },
                        { name: this.data[i].second }
                    ]
                });
            }
            return testData;
        };
        ListViewBuilder.prototype.buildCreateNestedData = function () {
            this.nestedData = this.generateNestedData(this.data);
        };
        ListViewBuilder.prototype.createListView = function () {
            this._listView = ListViewFactory.createHTMLListView(this.options);
        };
        ListViewBuilder.prototype.setSpy = function () {
            if (this.isSpy) {
                this._spy = spyOn(this.options, "loadMoreData");
            }
        };
        ListViewBuilder.prototype.build = function () {
            this.buildCreateNestedData();
            this.setSpy();
            this.createListView();
            this.render();
        };
        ListViewBuilder.prototype.render = function (sizeChanged, resetScrollPosition) {
            if (sizeChanged === void 0) { sizeChanged = true; }
            this._listView.data(this.nestedData, function (d) { return d.id; }).render(sizeChanged, resetScrollPosition);
        };
        ListViewBuilder.prototype.buildHtmlListView = function () {
            this.buildHtmlListViewOptions();
            this.build();
        };
        ListViewBuilder.prototype.buildSvgListView = function () {
            this.buildSvgListViewOptions();
            this.build();
        };
        return ListViewBuilder;
    })();
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var DataViewTransform = powerbi.data.DataViewTransform;
    var ValueType = powerbi.ValueType;
    var PrimitiveType = powerbi.PrimitiveType;
    powerbitests.mocks.setLocale();
    describe("VisualFactory", function () {
        var dataViewMetadataTwoColumn = {
            columns: [
                {
                    displayName: "col1",
                    queryName: "col1",
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)
                },
                {
                    displayName: "col2",
                    queryName: "col2",
                    isMeasure: true,
                    type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Double)
                }
            ],
        };
        var categoryColumnRef = powerbi.data.SQExprBuilder.fieldDef({ schema: "s", entity: "e", column: "col1" });
        function initVisual(v) {
            var hostServices = powerbitests.mocks.createVisualHostServices();
            var element = powerbitests.helpers.testDom("500", "500");
            v.init({
                element: element,
                host: hostServices,
                style: powerbi.visuals.visualStyles.create(),
                viewport: {
                    height: element.height(),
                    width: element.width()
                },
                settings: undefined,
                interactivity: undefined,
                animation: undefined
            });
        }
        function setData(v, objectDescs) {
            // full
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ["abc", "def"],
                                identity: [powerbitests.mocks.dataViewScopeIdentity("abc"), powerbitests.mocks.dataViewScopeIdentity("def")],
                                identityFields: [categoryColumnRef]
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataTwoColumn.columns[1],
                                min: 123,
                                max: 234,
                                subtotal: 357,
                                values: [123, 234]
                            }
                        ])
                    }
                }]);
            // empty
            changeData(v, objectDescs, []);
            // no categorical
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: undefined
                }]);
            // no metadata
            changeData(v, objectDescs, [{
                    metadata: undefined,
                    categorical: {
                        categories: [],
                        values: undefined
                    }
                }]);
            // no categorical.values
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ["abc", "def"],
                                identity: [powerbitests.mocks.dataViewScopeIdentity("abc"), powerbitests.mocks.dataViewScopeIdentity("def")],
                                identityFields: [categoryColumnRef]
                            }],
                        values: undefined
                    }
                }]);
            // no categories
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: undefined,
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataTwoColumn.columns[1],
                                min: 123,
                                max: 123,
                                subtotal: 123,
                                values: [123]
                            }
                        ])
                    }
                }]);
            // no values.values
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: ["abc", "def"],
                                identity: [powerbitests.mocks.dataViewScopeIdentity("abc"), powerbitests.mocks.dataViewScopeIdentity("def")],
                                identityFields: [categoryColumnRef]
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataTwoColumn.columns[1],
                                values: []
                            }
                        ])
                    }
                }]);
            // no categories.values
            changeData(v, objectDescs, [{
                    metadata: dataViewMetadataTwoColumn,
                    categorical: {
                        categories: [{
                                source: dataViewMetadataTwoColumn.columns[0],
                                values: [],
                                identityFields: [categoryColumnRef],
                            }],
                        values: DataViewTransform.createValueColumns([
                            {
                                source: dataViewMetadataTwoColumn.columns[1],
                                values: []
                            }
                        ])
                    }
                }]);
        }
        function changeData(visual, objectDescs, dataViews) {
            visual.onDataChanged({ dataViews: dataViews });
            if (visual.enumerateObjectInstances && objectDescs) {
                for (var objectName in objectDescs)
                    visual.enumerateObjectInstances({ objectName: objectName });
            }
        }
        it("VisualFactory.getVisuals - categorical - various dataViews", function () {
            var allVisuals = powerbi.visuals.visualPluginFactory.create().getVisuals();
            for (var i = 0; i < allVisuals.length; i++) {
                var exception = null, visualPlugin = allVisuals[i];
                if (visualPlugin.name !== "categoricalFilter" &&
                    visualPlugin.capabilities &&
                    visualPlugin.capabilities.dataViewMappings &&
                    visualPlugin.capabilities.dataViewMappings.length > 0 &&
                    visualPlugin.capabilities.dataViewMappings[0].categorical) {
                    var visual = visualPlugin.create();
                    try {
                        initVisual(visual);
                        setData(visual, visualPlugin.capabilities.objects);
                    }
                    catch (e) {
                        exception = e;
                        debug.assertFail(visualPlugin.name + " : " + e.message);
                    }
                    finally {
                        expect(exception).toBeNull();
                    }
                }
            }
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var SelectionId = powerbi.visuals.SelectionId;
    var Selector = powerbi.data.Selector;
    describe("SelectionId tests", function () {
        var categoryA = powerbitests.mocks.dataViewScopeIdentity("A");
        var categoryB = powerbitests.mocks.dataViewScopeIdentity("B");
        var seriesa = powerbitests.mocks.dataViewScopeIdentity("a");
        var seriesb = powerbitests.mocks.dataViewScopeIdentity("b");
        var measure1 = "measure1";
        var measure2 = "measure2";
        var idA = SelectionId.createWithId(categoryA);
        var idB = SelectionId.createWithId(categoryB);
        var ida = SelectionId.createWithId(seriesa);
        var idb = SelectionId.createWithId(seriesb);
        var id1 = SelectionId.createWithMeasure(measure1);
        var id2 = SelectionId.createWithMeasure(measure2);
        var idAa = SelectionId.createWithIds(categoryA, seriesa);
        var idAb = SelectionId.createWithIds(categoryA, seriesb);
        var idBa = SelectionId.createWithIds(categoryB, seriesa);
        var idA1 = SelectionId.createWithIdAndMeasure(categoryA, measure1);
        var idA2 = SelectionId.createWithIdAndMeasure(categoryA, measure2);
        var idB1 = SelectionId.createWithIdAndMeasure(categoryB, measure1);
        it("SelectionId equals single identifier", function () {
            expect(idA.equals(SelectionId.createWithId(categoryA))).toBe(true);
            expect(idA.equals(idB)).toBe(false);
            expect(ida.equals(SelectionId.createWithId(seriesa))).toBe(true);
            expect(ida.equals(idb)).toBe(false);
            expect(id1.equals(SelectionId.createWithMeasure(measure1))).toBe(true);
            expect(id1.equals(id2)).toBe(false);
        });
        it("SelectionId equals two identifiers", function () {
            expect(idAa.equals(SelectionId.createWithIds(categoryA, seriesa))).toBe(true);
            expect(idAa.equals(idAb)).toBe(false);
            expect(idAa.equals(idBa)).toBe(false);
            expect(idAa.equals(idA1)).toBe(false);
            expect(idA1.equals(SelectionId.createWithIdAndMeasure(categoryA, measure1))).toBe(true);
            expect(idA1.equals(idA2)).toBe(false);
            expect(idA1.equals(idB1)).toBe(false);
            expect(idA1.equals(idAa)).toBe(false);
        });
        it("SelectionId equals different identifiers", function () {
            expect(idA.equals(ida)).toBe(false);
            expect(idA.equals(idAa)).toBe(false);
            expect(idA.equals(idA1)).toBe(false);
            expect(idb.equals(id1)).toBe(false);
            expect(idb.equals(idAb)).toBe(false);
            expect(id1.equals(idA)).toBe(false);
            expect(id1.equals(idA1)).toBe(false);
        });
        it("SelectionId includes with category", function () {
            expect(idA.includes(idA)).toBe(true);
            expect(idA.includes(idAb)).toBe(true);
            expect(idA.includes(idA1)).toBe(true);
            expect(idA.includes(idB)).toBe(false);
            expect(idA.includes(ida)).toBe(false);
            expect(idA.includes(id1)).toBe(false);
        });
        it("SelectionId includes with series", function () {
            expect(ida.includes(ida)).toBe(true);
            expect(ida.includes(idAa)).toBe(true);
            expect(ida.includes(idA)).toBe(false);
            expect(ida.includes(idb)).toBe(false);
            expect(ida.includes(id1)).toBe(false);
        });
        it("SelectionId includes with measure", function () {
            expect(id1.includes(id1)).toBe(true);
            expect(id1.includes(idA1)).toBe(true);
            expect(id1.includes(idA)).toBe(false);
            expect(id1.includes(ida)).toBe(false);
            expect(id1.includes(id2)).toBe(false);
        });
        it("SelectionId includes with two identifiers", function () {
            expect(idAa.includes(idAa)).toBe(true);
            expect(idAa.includes(idA1)).toBe(false);
            expect(idAa.includes(idA)).toBe(false);
            expect(idA1.includes(idA1)).toBe(true);
            expect(idA1.includes(idA)).toBe(true);
            expect(idAa.includes(idBa)).toBe(false);
            expect(idA1.includes(idB1)).toBe(false);
        });
        it("SelectionId createNull", function () {
            var selectionId = SelectionId.createNull();
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: null, highlight: false }));
        });
        it("SelectionId createWithId", function () {
            var selectionId = SelectionId.createWithId(categoryA);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA] }), highlight: false }));
        });
        it("SelectionId createWithMeasure", function () {
            var selectionId = SelectionId.createWithMeasure(measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ metadata: measure1 }), highlight: false }));
        });
        it("SelectionId createWithIdAndMeasure", function () {
            var selectionId = SelectionId.createWithIdAndMeasure(categoryA, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
        });
        it("SelectionId createWithIds", function () {
            var selectionId = SelectionId.createWithIds(categoryA, seriesa);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa] }), highlight: false }));
        });
        it("SelectionId createWithIds: with duplicates", function () {
            var selectionId = SelectionId.createWithIds(categoryA, categoryA);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA] }), highlight: false }));
        });
        it("SelectionId createWithIdsAndMeasure", function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(undefined, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [seriesa], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(categoryA, undefined, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
            selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, undefined);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa] }), highlight: false }));
        });
        it("SelectionId createWithIdsAndMeasure: with duplicates", function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, categoryA, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA], metadata: measure1 }), highlight: false }));
        });
        it("SelectionId createWithHighlight", function () {
            var selectionId = SelectionId.createWithIdsAndMeasure(categoryA, seriesa, measure1);
            expect(selectionId.getKey()).toEqual(JSON.stringify({ selector: Selector.getKey({ data: [categoryA, seriesa], metadata: measure1 }), highlight: false }));
            var selectionIdWithHighlight = SelectionId.createWithHighlight(selectionId);
            expect(selectionIdWithHighlight.getSelector()).toBe(selectionId.getSelector());
            expect(selectionIdWithHighlight.getKey()).not.toBe(selectionId.getKey());
        });
        it("SelectionId creates using undefined", function () {
            var nullKey = SelectionId.createNull().getKey();
            var ids = SelectionId.createWithIdAndMeasure(undefined, undefined);
            expect(ids.getKey()).toEqual(nullKey);
            var idAndMeasure = SelectionId.createWithIdAndMeasure(undefined, undefined);
            expect(idAndMeasure.getKey()).toEqual(nullKey);
            var idsAndMeasure = SelectionId.createWithIdsAndMeasure(undefined, undefined, undefined);
            expect(idsAndMeasure.getKey()).toEqual(nullKey);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var Shapes = powerbi.visuals.shapes;
    var Point = powerbi.visuals.shapes.Point;
    var Size = powerbi.visuals.shapes.Size;
    var Rect = powerbi.visuals.shapes.Rect;
    var Thickness = powerbi.visuals.shapes.Thickness;
    var Vector = powerbi.visuals.shapes.Vector;
    describe("Point tests", function () {
        var pointA;
        it("offset with positive value", function () {
            var pointA = { x: 10, y: 10 };
            var offset = Point.offset(pointA, 20, 25);
            expect(offset.x).toBe(30);
            expect(offset.y).toBe(35);
        });
        it("offset with negative value", function () {
            var pointA = { x: 100, y: 100 };
            var offset = Point.offset(pointA, -20, -25);
            expect(offset.x).toBe(80);
            expect(offset.y).toBe(75);
        });
        it("Check equals - return true", function () {
            var pointA = { x: 100, y: 100 };
            var pointB = { x: 100, y: 100 };
            var offset = Point.equals(pointA, pointB);
            expect(offset).toBe(true);
        });
        it("Check equals - return false", function () {
            var pointA = { x: 100, y: 100 };
            var pointB = { x: 50, y: 100 };
            var offset = Point.equals(pointA, pointB);
            expect(offset).toBe(false);
        });
        it("Check clone", function () {
            var point = { x: 100, y: 100 };
            var clonePoint = Point.clone(point);
            expect(clonePoint.x).toBe(point.x);
            expect(clonePoint.y).toBe(point.y);
        });
        it("Point - To String", function () {
            var point = { x: 100, y: 100 };
            var pointToString = Point.toString(point);
            expect(pointToString).toBe("{x:100, y:100}");
        });
        it("Check Serialize", function () {
            var point = { x: 200, y: 200 };
            var pointSerialize = Point.serialize(point);
            expect(pointSerialize).toBe("200,200");
        });
        it("Check Distance ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 250, y: 300 };
            var distance = Point.getDistance(pointA, pointB);
            var calculatedDistance = Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + (Math.pow(pointB.y - pointA.y, 2)));
            expect(distance).toBe(calculatedDistance);
        });
        it("Check Distance (null values)", function () {
            pointA = null;
            var pointB = { x: 150, y: 200 };
            var distance = Point.getDistance(pointA, pointB);
            expect(distance).toBe(null);
        });
        it("Check zero Distance ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 200, y: 200 };
            var distance = Point.getDistance(pointA, pointB);
            expect(distance).toBe(0);
        });
        it("Equals (static) - return true ", function () {
            var pointA = { x: 200, y: 200 };
            var pointB = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(pointA, pointB);
            expect(arePointsEqual).toBe(true);
        });
        it("Equals (static) - point A is null ", function () {
            var pointB = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(null, pointB);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals (static) - point B is null ", function () {
            var pointA = { x: 200, y: 200 };
            var arePointsEqual = Point.equals(pointA, null);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals (static) - points are null ", function () {
            var arePointsEqual = Point.equals(null, null);
            expect(arePointsEqual).toBe(false);
        });
        it("Equals with Precision - return true ", function () {
            var pointA = { x: 200.23, y: 200.32 };
            var pointB = { x: 200.23, y: 200.32 };
            var arePointsEqual = Shapes.Point.equalWithPrecision(pointA, pointB);
            expect(arePointsEqual).toBe(true);
        });
        it("Parse Point (from string no default value)", function () {
            var pointStr = "200,215";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA.x).toBe(200);
            expect(pointA.y).toBe(215);
        });
        it("Parse Point (from string,2 points)", function () {
            var pointStr = "190,220";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (from string,2 points (default value ignored)", function () {
            var pointStr = "190,220";
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(pointStr, defaultValue);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (from empty string)", function () {
            var pointStr = "";
            var pointA = Point.parsePoint(pointStr);
            expect(pointA).toBe(null);
        });
        it("Parse Point - from empty string (default value taken)", function () {
            var pointStr = "";
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(pointStr, defaultValue);
            expect(pointA.x).toBe(defaultValue.x);
            expect(pointA.y).toBe(defaultValue.y);
        });
        it("Parse Point (from int array)", function () {
            var intArray = [190, 220];
            var pointA = Point.parsePoint(intArray);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point - from int array (default value ignored)", function () {
            var intArray = [190, 220];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(190);
            expect(pointA.y).toBe(220);
        });
        it("Parse Point (int with more than 2 elements)", function () {
            var intArray = [190, 220, 200, 210];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point (int with more than 2 elements (default value taken)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { x: 110, y: 100 };
            pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point (int with one element)", function () {
            var intArray = [190];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point - int with one element (default value taken)", function () {
            var intArray = [190];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(defaultValue.x);
            expect(pointA.y).toBe(defaultValue.y);
        });
        it("Parse Point (int with empty array)", function () {
            var intArray = [];
            var pointA = Point.parsePoint(intArray);
            expect(pointA).toBe(null);
        });
        it("Parse Point (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(intArray, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point  - not string and not array)", function () {
            var num = true;
            var pointA = Point.parsePoint(num);
            expect(pointA).toBe(null);
        });
        it("Parse Point - not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(num, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
        it("Parse Point - getting null", function () {
            var pointA = Point.parsePoint(null);
            expect(pointA).toBe(null);
        });
        it("Parse Point - getting null (default value taken)", function () {
            var defaultValue = { x: 110, y: 100 };
            var pointA = Point.parsePoint(null, defaultValue);
            expect(pointA.x).toBe(110);
            expect(pointA.y).toBe(100);
        });
    });
    describe("Size Tests", function () {
        it("Is Empty - true", function () {
            var size = { width: 0, height: 0 };
            var isEmpty = Size.isEmpty(size);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty - false", function () {
            var size = { width: 50, height: 50 };
            var isEmpty = Size.isEmpty(size);
            expect(isEmpty).toBe(false);
        });
        it("Check equals - return true", function () {
            var sizeA = { width: 120, height: 100 };
            var sizeB = { width: 120, height: 100 };
            var sizeEquals = Size.equals(sizeA, sizeB);
            expect(sizeEquals).toBe(true);
        });
        it("Check equals - return false", function () {
            var sizeA = { width: 120, height: 100 };
            var sizeB = { width: 120, height: 150 };
            var sizeEquals = Size.equals(sizeA, sizeB);
            expect(sizeEquals).toBe(false);
        });
        it("Check equals - null", function () {
            var size = { width: 120, height: 100 };
            var sizeEquals = Size.equals(size, null);
            expect(sizeEquals).toBe(false);
        });
        it("clone", function () {
            var size = { width: 120, height: 100 };
            var sizeCloned = Size.clone(size);
            expect(sizeCloned.width).toBe(size.width);
            expect(sizeCloned.height).toBe(size.height);
        });
        it("clone - null", function () {
            var size = null;
            var sizeCloned = Size.clone(size);
            expect(sizeCloned).toBe(null);
        });
        it("inflate - Positive values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 5, top: 10, right: 5, bottom: 10 };
            var sizeInflated = Size.inflate(size, padding);
            expect(sizeInflated.width).toBe(130);
            expect(sizeInflated.height).toBe(120);
        });
        it("inflate - Zero values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 0, top: 0, right: 0, bottom: 0 };
            var sizeInflated = Size.inflate(size, padding);
            expect(sizeInflated.width).toBe(size.width);
            expect(sizeInflated.height).toBe(size.height);
        });
        it("deflate - Positive values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 5, top: 10, right: 5, bottom: 10 };
            var sizeDeflated = Size.deflate(size, padding);
            expect(sizeDeflated.width).toBe(110);
            expect(sizeDeflated.height).toBe(80);
        });
        it("deflate - Zero values", function () {
            var size = { width: 120, height: 100 };
            var padding = { left: 0, top: 0, right: 0, bottom: 0 };
            var sizeDeflated = Size.deflate(size, padding);
            expect(sizeDeflated.width).toBe(size.width);
            expect(sizeDeflated.height).toBe(size.height);
        });
        it("Combine 2 sizes", function () {
            var sizeA = { width: 70, height: 110 };
            var sizeB = { width: 30, height: 120 };
            Size.combine(sizeA, sizeB);
            var newSize = { width: 70, height: 120 };
            expect(newSize.width).toBe(70);
            expect(newSize.height).toBe(120);
        });
        it("Combine 2 sizes (A contains B)", function () {
            var sizeA = { width: 150, height: 120 };
            var sizeB = { width: 80, height: 110 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeA.width);
            expect(newSize.height).toBe(sizeA.height);
        });
        it("Combine 2 sizes (B contains A)", function () {
            var sizeA = { width: 150, height: 120 };
            var sizeB = { width: 180, height: 170 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeB.width);
            expect(newSize.height).toBe(sizeB.height);
        });
        it("Combine 2 sizes (one empty)", function () {
            var sizeA = { width: 110, height: 120 };
            var sizeB = { width: 0, height: 0 };
            var newSize = Size.combine(sizeA, sizeB);
            expect(newSize.width).toBe(sizeA.width);
            expect(newSize.height).toBe(sizeA.height);
        });
        it("To Rect", function () {
            var size = { width: 120, height: 100 };
            var sizeToRect = Size.toRect(size);
            expect(sizeToRect.left).toBe(0);
            expect(sizeToRect.top).toBe(0);
            expect(sizeToRect.width).toBe(120);
            expect(sizeToRect.height).toBe(100);
        });
        it("To string", function () {
            var size = { width: 150, height: 30 };
            var sizeToString = Size.toString(size);
            expect(sizeToString).toBe("{width:150, height:30}");
        });
        it("Equals (static) - return true ", function () {
            var SizeA = { width: 200, height: 200 };
            var SizeB = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(SizeA, SizeB);
            expect(areSizesEqual).toBe(true);
        });
        it("Equals (static) - size A is null ", function () {
            var SizeB = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(null, SizeB);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals (static) - size B is null ", function () {
            var SizeA = { width: 200, height: 200 };
            var areSizesEqual = Size.equals(SizeA, null);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals (static) - sizes are null ", function () {
            var areSizesEqual = Size.equals(null, null);
            expect(areSizesEqual).toBe(false);
        });
        it("Equals with Precision - return true ", function () {
            var SizeA = { width: 200.23, height: 200.32 };
            var SizeB = { width: 200.23, height: 200.32 };
            var areSizesEqual = Shapes.Size.equalWithPrecision(SizeA, SizeB);
            expect(areSizesEqual).toBe(true);
        });
        it("Parse Size (from string no default value)", function () {
            var sizeStr = "200,215";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA.width).toBe(200);
            expect(sizeA.height).toBe(215);
        });
        it("Parse Size (from string,2 points)", function () {
            var sizeStr = "190,220";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size - from string,2 points (default value ignored)", function () {
            var sizeStr = "190,220";
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(sizeStr, defaultValue);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size (from empty string)", function () {
            var sizeStr = "";
            var sizeA = Size.parseSize(sizeStr);
            expect(sizeA).toBe(null);
        });
        it("Parse Size - from empty string (default value taken)", function () {
            var sizeStr = "";
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(sizeStr, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size (from int array)", function () {
            var intArray = [190, 220];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size - from int array (default value ignored)", function () {
            var intArray = [190, 220];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(190);
            expect(sizeA.height).toBe(220);
        });
        it("Parse Size (int with more than 2 elements)", function () {
            var intArray = [190, 220, 200, 210];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with more than 2 elements (default value taken)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(defaultValue.width);
            expect(sizeA.height).toBe(defaultValue.height);
        });
        it("Parse Size (int with one element)", function () {
            var intArray = [190];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with one element (default value taken)", function () {
            var intArray = [190];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(defaultValue.width);
            expect(sizeA.height).toBe(defaultValue.height);
        });
        it("Parse Size (int with empty array)", function () {
            var intArray = [];
            var sizeA = Size.parseSize(intArray);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(intArray, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size (not string and not array)", function () {
            var num = true;
            var sizeA = Size.parseSize(num);
            expect(sizeA).toBe(null);
        });
        it("Parse Size (not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(num, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
        it("Parse Size - getting null", function () {
            var sizeA = Size.parseSize(null);
            expect(sizeA).toBe(null);
        });
        it("Parse Size - getting null (default value taken)", function () {
            var defaultValue = { width: 110, height: 100 };
            var sizeA = Size.parseSize(null, defaultValue);
            expect(sizeA.width).toBe(110);
            expect(sizeA.height).toBe(100);
        });
    });
    describe("Rect tests", function () {
        var rectA;
        var rectB;
        var isEmpty;
        var isIntersecting;
        var defaultRect = { left: 110, top: 100, width: 150, height: 117 };
        function AreRectsEqual(rectA, rectB) {
            return (rectB.left === rectA.left && rectB.top === rectA.top && rectB.width === rectA.width && rectB.height === rectA.height);
        }
        it("Is Empty - true", function () {
            rectA = { left: 0, top: 0, width: 0, height: 0 };
            var isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty - false", function () {
            rectA = { left: 0, top: 0, width: 50, height: 20 };
            var isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(false);
        });
        it("Is Empty - null", function () {
            rectA = null;
            isEmpty = Rect.isEmpty(rectA);
            expect(isEmpty).toBe(true);
        });
        it("Is Intersecting - true", function () {
            rectA = { left: 0, top: 0, width: 200, height: 300 };
            rectB = { left: 170, top: 30, width: 300, height: 400 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(true);
        });
        it("Is Intersecting - false", function () {
            rectA = { left: 0, top: 0, width: 10, height: 10 };
            rectB = { left: 100, top: 200, width: 500, height: 400 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - first rect is null", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = null;
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - second rect is null", function () {
            rectA = null;
            rectB = { left: 0, top: 0, width: 200, height: 200 };
            isIntersecting = Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Get offset", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = Rect.getOffset(rectA);
            expect(rectB.x).toBe(0);
            expect(rectB.y).toBe(0);
        });
        it("Get size", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            rectB = Rect.getSize(rectA);
            expect(rectB.width).toBe(200);
            expect(rectB.height).toBe(200);
        });
        it("Set size", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            var newSize = { width: 150, height: 170 };
            Rect.setSize(rectA, newSize);
            expect(rectA.width).toBe(150);
            expect(rectA.height).toBe(170);
        });
        it("Get Right (Property)", function () {
            rectA = { left: 120, top: 50, width: 200, height: 200 };
            var right = Rect.right(rectA);
            expect(right).toBe(320);
        });
        it("Get Bottom (Property)", function () {
            rectA = { left: 70, top: 130, width: 200, height: 200 };
            var bottom = Rect.bottom(rectA);
            expect(bottom).toBe(330);
        });
        it("Get TopLeft (Property)", function () {
            rectA = { left: 0, top: 0, width: 200, height: 200 };
            var topLeft = Rect.topLeft(rectA);
            expect(topLeft.x).toBe(0);
            expect(topLeft.y).toBe(0);
        });
        it("Get TopRight (Property)", function () {
            rectA = { left: 80, top: 170, width: 150, height: 220 };
            var topRight = Rect.topRight(rectA);
            expect(topRight.x).toBe(230);
            expect(topRight.y).toBe(170);
        });
        it("Get BottomLeft (Property)", function () {
            rectA = { left: 0, top: 10, width: 30, height: 220 };
            var bottomLeft = Rect.bottomLeft(rectA);
            expect(bottomLeft.x).toBe(rectA.left);
            expect(bottomLeft.y).toEqual(rectA.top + rectA.height);
        });
        it("Get BottomRight (Property)", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            var bottomRight = Rect.bottomRight(rectA);
            expect(bottomRight.x).toBe(250);
            expect(bottomRight.y).toBe(360);
        });
        it("Check equals - return true", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            rectB = { left: 50, top: 90, width: 200, height: 270 };
            var rectEquals = Rect.equals(rectA, rectB);
            expect(rectEquals).toBe(true);
        });
        it("Check equals - return false", function () {
            rectA = { left: 50, top: 90, width: 200, height: 270 };
            rectB = { left: 50, top: 90, width: 250, height: 270 };
            var rectEquals = Rect.equals(rectA, rectB);
            expect(rectEquals).toBe(false);
        });
        it("Check equals - null", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectEquals = Rect.equals(rectA, null);
            expect(rectEquals).toBe(false);
        });
        it("Clone", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.clone(rectA);
            expect(AreRectsEqual(rectA, rectB)).toBe(true);
        });
        it("Rect ToString", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectToString = "{left:70, top:90, width:130, height:270}";
            expect(Rect.toString(rectA)).toBe(rectToString);
        });
        it("Rect offset - Positive Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectB = Rect.offset(rectA, 30, 30);
            expect(rectB.left).toBe(rectA.left + 30);
            expect(rectB.top).toBe(rectA.top + 30);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect offset - Zero Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            var rectB = Rect.offset(rectA, 0, 0);
            expect(rectB.left).toBe(rectA.left);
        });
        it("Rect offset - Negative Values", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.offset(rectA, -30, -60);
            expect(rectB.left).toBe(rectA.left - 30);
            expect(rectB.top).toBe(rectA.top - 60);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect offset - Negative Offset Bigger than Top Left", function () {
            rectA = { left: 70, top: 90, width: 130, height: 270 };
            rectB = Rect.offset(rectA, -100, -130);
            expect(rectB.left).toBe(0);
            expect(rectB.top).toBe(0);
            expect(rectB.width).toBe(rectA.width);
            expect(rectB.height).toBe(rectA.height);
        });
        it("Rect inflate", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 30, top: 20, right: 50, bottom: 40 };
            rectB = Rect.inflate(rectA, thickness);
            expect(rectB.left).toBe(40);
            expect(rectB.top).toBe(90);
            expect(rectB.width).toBe(210);
            expect(rectB.height).toBe(330);
        });
        it("Rect inflate - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 0, top: 0, right: 0, bottom: 0 };
            rectB = Rect.inflate(rectA, thickness);
            expect(rectB.left).toBe(70);
            expect(rectB.top).toBe(110);
            expect(rectB.width).toBe(130);
            expect(rectB.height).toBe(270);
        });
        it("Rect deflate", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 30, top: 20, right: 50, bottom: 40 };
            rectB = Rect.deflate(rectA, thickness);
            expect(rectB.left).toBe(100);
            expect(rectB.top).toBe(130);
            expect(rectB.width).toBe(50);
            expect(rectB.height).toBe(210);
        });
        it("Rect deflate - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var thickness = { left: 0, top: 0, right: 0, bottom: 0 };
            rectB = Rect.deflate(rectA, thickness);
            expect(rectB.left).toBe(70);
            expect(rectB.top).toBe(110);
            expect(rectB.width).toBe(130);
            expect(rectB.height).toBe(270);
        });
        it("Rect inflateBy", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.inflateBy(rectA, 20);
            expect(rectA.left).toBe(50);
            expect(rectA.top).toBe(90);
            expect(rectA.width).toBe(170);
            expect(rectA.height).toBe(310);
        });
        it("Rect inflateBy - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.inflateBy(rectA, 0);
            expect(rectA.left).toBe(70);
            expect(rectA.top).toBe(110);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(270);
        });
        it("Rect deflateBy", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.deflateBy(rectA, 30);
            expect(rectA.left).toBe(100);
            expect(rectA.top).toBe(140);
            expect(rectA.width).toBe(70);
            expect(rectA.height).toBe(210);
        });
        it("Rect deflateBy - Zero Values", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectA = Rect.deflateBy(rectA, 0);
            expect(rectA.left).toBe(70);
            expect(rectA.top).toBe(110);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(270);
        });
        it("Contains Point - Return true", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var newPoint = { x: 100, y: 140 };
            var isContains = Shapes.Rect.containsPoint(rectA, newPoint);
            expect(isContains).toBe(true);
        });
        it("Contains Point - Return false", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var newPoint = { x: 220, y: 170 };
            var isContains = Shapes.Rect.containsPoint(rectA, newPoint);
            expect(isContains).toBe(false);
        });
        it("Contains Point - null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            var isContains = Shapes.Rect.containsPoint(rectA, null);
            expect(isContains).toBe(false);
        });
        it("Is Intersecting - Return true", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 70, top: 150, width: 130, height: 320 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(true);
        });
        it("Is Intersecting - Return false", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 30, top: 20, width: 20, height: 20 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - first null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = null;
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Is Intersecting - second null", function () {
            rectA = null;
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            var isIntersecting = Shapes.Rect.isIntersecting(rectA, rectB);
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A Contains B", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 90, top: 140, width: 20, height: 20 };
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect B Contains A", function () {
            rectA = { left: 110, top: 150, width: 30, height: 25 };
            rectB = { left: 90, top: 140, width: 100, height: 120 };
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A Intersect B", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = { left: 90, top: 130, width: 80, height: 70 };
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A don't Intersect B", function () {
            rectA = { left: 0, top: 0, width: 20, height: 30 };
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect A is null", function () {
            rectA = null;
            rectB = { left: 70, top: 110, width: 130, height: 270 };
            expect(isIntersecting).toBe(false);
        });
        it("Intersect - Rect B is null", function () {
            rectA = { left: 70, top: 110, width: 130, height: 270 };
            rectB = null;
            expect(isIntersecting).toBe(false);
        });
        it("Combine 2 rects", function () {
            rectA = { left: 50, top: 50, width: 50, height: 50 };
            rectB = { left: 60, top: 60, width: 60, height: 60 };
            var newRect = Rect.combine(rectA, rectB);
            var newRectCalculated = { left: 50, top: 50, width: 70, height: 70 };
            expect(AreRectsEqual(newRectCalculated, newRect)).toBe(true);
        });
        it("Combine 2 rects (A contains B)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 160, top: 160, width: 10, height: 10 };
            var newRect = Rect.combine(rectA, rectB);
            expect(AreRectsEqual(rectA, newRect)).toBe(true);
        });
        it("Combine 2 rects (B contains A)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 130, top: 130, width: 50, height: 50 };
            var newRect = Rect.combine(rectA, rectB);
            expect(AreRectsEqual(newRect, rectB)).toBe(true);
        });
        it("Combine 2 rects (one empty)", function () {
            rectA = { left: 150, top: 150, width: 20, height: 20 };
            rectB = { left: 0, top: 0, width: 0, height: 0 };
            var newRect = rectA;
            Rect.combine(rectA, rectB);
            expect(AreRectsEqual(rectA, newRect)).toBe(true);
        });
        it("Parse Rect (from string no default value)", function () {
            var rectStr = "200,215,200,180";
            rectA = Rect.parseRect(rectStr);
            expect(rectA.left).toBe(200);
            expect(rectA.top).toBe(215);
            expect(rectA.width).toBe(200);
            expect(rectA.height).toBe(180);
        });
        it("Parse Rect - from string,(default value ignored)", function () {
            var rectStr = "190,220,150,170";
            rectA = Rect.parseRect(rectStr, defaultRect);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(150);
            expect(rectA.height).toBe(170);
        });
        it("Parse Rect (from empty string)", function () {
            var rectStr = "";
            rectA = Rect.parseRect(rectStr);
            expect(rectA).toBe(null);
        });
        it("Parse Rect - from empty string (default value taken)", function () {
            var rectStr = "";
            rectA = Rect.parseRect(rectStr, defaultRect);
            expect(rectA.left).toBe(defaultRect.left);
            expect(rectA.top).toBe(defaultRect.top);
            expect(rectA.width).toBe(defaultRect.width);
            expect(rectA.height).toBe(defaultRect.height);
        });
        it("Parse Rect (from int array)", function () {
            var intArray = [190, 220, 100, 150];
            rectA = Rect.parseRect(intArray);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(100);
            expect(rectA.height).toBe(150);
        });
        it("Parse Rect - from int array (default value ignored)", function () {
            var intArray = [190, 220, 130, 115];
            rectA = Rect.parseRect(intArray, defaultRect);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(130);
            expect(rectA.height).toBe(115);
        });
        it("Parse Rect (int with more than 4 elements)", function () {
            var intArray = [190, 220, 200, 210, 118];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with more than 4 elements (default value ignored)", function () {
            var intArray = [190, 220, 200, 210];
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(intArray, defaultValue);
            expect(rectA.left).toBe(190);
            expect(rectA.top).toBe(220);
            expect(rectA.width).toBe(200);
            expect(rectA.height).toBe(210);
        });
        it("Parse Rect (int with one element)", function () {
            var intArray = [190];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with one element (default value taken)", function () {
            var intArray = [190];
            rectA = Rect.parseRect(intArray, defaultRect);
            expect(rectA.left).toBe(defaultRect.left);
            expect(rectA.top).toBe(defaultRect.top);
            expect(rectA.width).toBe(defaultRect.width);
            expect(rectA.height).toBe(defaultRect.height);
        });
        it("Parse Rect (int with empty array)", function () {
            var intArray = [];
            rectA = Rect.parseRect(intArray);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (int with empty array (default value taken)", function () {
            var intArray = [];
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(intArray, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
        it("Parse Rect (not string and not array)", function () {
            var num = true;
            rectA = Rect.parseRect(num);
            expect(rectA).toBe(null);
        });
        it("Parse Rect (not string and not array (default value taken)", function () {
            var num = true;
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(num, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
        it("Parse Rect - getting null", function () {
            rectA = Rect.parseRect(null);
            expect(rectA).toBe(null);
        });
        it("Parse Rect - getting null (default value taken)", function () {
            var defaultValue = { left: 110, top: 100, width: 115, height: 170 };
            rectA = Rect.parseRect(null, defaultValue);
            expect(rectA.left).toBe(defaultValue.left);
            expect(rectA.top).toBe(defaultValue.top);
            expect(rectA.width).toBe(defaultValue.width);
            expect(rectA.height).toBe(defaultValue.height);
        });
    });
    describe("Thickness tests", function () {
        var thicknessA;
        var thicknessB;
        var defaultThickness = { left: 105, top: 100, right: 122, bottom: 122 };
        it("Inflate", function () {
            thicknessA = { left: 120, top: 100, right: 150, bottom: 170 };
            thicknessB = { left: 20, top: 20, right: 20, bottom: 20 };
            var newThickness = Thickness.inflate(thicknessA, thicknessB);
            expect(newThickness.left).toBe(140);
            expect(newThickness.top).toBe(120);
            expect(newThickness.right).toBe(170);
            expect(newThickness.bottom).toBe(190);
        });
        it("Get Width", function () {
            thicknessA = { left: 115, top: 134, right: 212, bottom: 270 };
            var thicknessWidth = Thickness.getWidth(thicknessA);
            expect(thicknessWidth).toBe(327);
        });
        it("Get Width - Zero Thickness", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var thicknessWidth = Thickness.getWidth(thicknessA);
            expect(thicknessWidth).toBe(0);
        });
        it("Get Height", function () {
            thicknessA = { left: 80, top: 215, right: 212, bottom: 15 };
            var thicknessHeight = Thickness.getHeight(thicknessA);
            expect(thicknessHeight).toBe(230);
        });
        it("Get Height", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var thicknessHeight = Thickness.getHeight(thicknessA);
            expect(thicknessHeight).toBe(0);
        });
        it("Clone", function () {
            thicknessA = { left: 158, top: 150, right: 215, bottom: 412 };
            thicknessB = Thickness.clone(thicknessA);
            expect(thicknessB.left).toBe(thicknessA.left);
            expect(thicknessB.top).toBe(thicknessA.top);
            expect(thicknessB.right).toBe(thicknessA.right);
            expect(thicknessB.bottom).toBe(thicknessA.bottom);
        });
        it("Clone - null value", function () {
            thicknessA = null;
            thicknessB = Thickness.clone(thicknessA);
            expect(thicknessB).toBe(null);
        });
        it("Equals - return true", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(true);
        });
        it("Equals - return false", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 100, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Equals - first value is null", function () {
            thicknessA = null;
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Equals - second value is null", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = null;
            var isEquals = Thickness.equals(thicknessA, thicknessB);
            expect(isEquals).toBe(false);
        });
        it("Flip Horizontal", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            Thickness.flipHorizontal(thicknessA);
            expect(thicknessA.left).toBe(180);
            expect(thicknessA.right).toBe(87);
            expect(thicknessA.top).toBe(156);
            expect(thicknessA.bottom).toBe(95);
        });
        it("Flip Vertical", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            Thickness.flipVertical(thicknessA);
            expect(thicknessA.left).toBe(87);
            expect(thicknessA.right).toBe(180);
            expect(thicknessA.top).toBe(95);
            expect(thicknessA.bottom).toBe(156);
        });
        it("To string", function () {
            thicknessA = { left: 158, top: 150, right: 215, bottom: 412 };
            var thicknessString = Thickness.toString(thicknessA);
            expect(thicknessString).toBe("{top:150, left:158, right:215, bottom:412}");
        });
        it("To Css String", function () {
            thicknessA = { left: 95, top: 140, right: 217, bottom: 107 };
            var thicknessString = Thickness.toCssString(thicknessA);
            expect(thicknessString).toBe("140px 217px 107px 95px");
        });
        it("Is Empty true", function () {
            thicknessA = { left: 0, top: 0, right: 0, bottom: 0 };
            var isEmpty = Thickness.isEmpty(thicknessA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty false", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            var isEmpty = Thickness.isEmpty(thicknessA);
            expect(isEmpty).toBe(false);
        });
        it("Equals (static) - return true ", function () {
            thicknessA = { left: 87, top: 156, right: 180, bottom: 95 };
            thicknessB = { left: 87, top: 156, right: 180, bottom: 95 };
            var areThicknessesEqual = Thickness.equals(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(true);
        });
        it("Equals (static) - return false ", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            thicknessB = { left: 125, top: 130, right: 110, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thickness A is null ", function () {
            var thicknessB = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(null, thicknessB);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thickness B is null ", function () {
            var thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Thickness.equals(thicknessA, null);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals (static) - Thicknesses are null ", function () {
            var areThicknessesEqual = Thickness.equals(null, null);
            expect(areThicknessesEqual).toBe(false);
        });
        it("Equals with Precision (static) - return true ", function () {
            thicknessA = { left: 125, top: 130, right: 114, bottom: 47 };
            thicknessB = { left: 125, top: 130, right: 114, bottom: 47 };
            var areThicknessesEqual = Shapes.Thickness.equalWithPrecision(thicknessA, thicknessB);
            expect(areThicknessesEqual).toBe(true);
        });
        it("Parse Thickness (from string no default value)", function () {
            var thicknessStr = "200,215,200,180";
            thicknessA = Thickness.parseThickness(thicknessStr);
            expect(thicknessA.left).toBe(200);
            expect(thicknessA.top).toBe(215);
            expect(thicknessA.right).toBe(200);
            expect(thicknessA.bottom).toBe(180);
        });
        it("Parse Thickness - from string,(default value ignored)", function () {
            var thicknessStr = "190,220,150,170";
            thicknessA = Thickness.parseThickness(thicknessStr, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(150);
            expect(thicknessA.bottom).toBe(170);
        });
        it("Parse Thickness (from empty string)", function () {
            var thicknessStr = "";
            thicknessA = Thickness.parseThickness(thicknessStr);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness - from empty string (default value taken)", function () {
            var thicknessStr = "";
            thicknessA = Thickness.parseThickness(thicknessStr, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (from int array)", function () {
            var intArray = [190, 220, 100, 150];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(100);
            expect(thicknessA.bottom).toBe(150);
        });
        it("Parse Thickness - from int array (default value ignored)", function () {
            var intArray = [190, 220, 130, 115];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(130);
            expect(thicknessA.bottom).toBe(115);
        });
        it("Parse Thickness (int with more than 4 elements)", function () {
            var intArray = [190, 220, 200, 210, 118];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with more than 4 elements (default value ignored)", function () {
            var intArray = [190, 220, 200, 210];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(190);
            expect(thicknessA.top).toBe(220);
            expect(thicknessA.right).toBe(200);
            expect(thicknessA.bottom).toBe(210);
        });
        it("Parse Thickness (int with one element)", function () {
            var intArray = [190];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with one element (default value taken)", function () {
            var intArray = [190];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (int with empty array)", function () {
            var intArray = [];
            thicknessA = Thickness.parseThickness(intArray);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (int with empty array (default value taken)", function () {
            var intArray = [];
            thicknessA = Thickness.parseThickness(intArray, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness (not string and not array)", function () {
            var num = true;
            thicknessA = Thickness.parseThickness(num);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness (not string and not array (default value taken)", function () {
            var num = true;
            thicknessA = Thickness.parseThickness(num, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
        it("Parse Thickness - getting null", function () {
            thicknessA = Thickness.parseThickness(null);
            expect(thicknessA).toBe(null);
        });
        it("Parse Thickness - getting null (default value taken)", function () {
            thicknessA = Thickness.parseThickness(null, defaultThickness);
            expect(thicknessA.left).toBe(defaultThickness.left);
            expect(thicknessA.top).toBe(defaultThickness.top);
            expect(thicknessA.right).toBe(defaultThickness.right);
            expect(thicknessA.bottom).toBe(defaultThickness.bottom);
        });
    });
    describe("Vector tests", function () {
        var vectorA;
        var vectorB;
        it("Is Empty true", function () {
            vectorA = { x: 0, y: 0 };
            var isEmpty = Vector.isEmpty(vectorA);
            expect(isEmpty).toBe(true);
        });
        it("Is Empty false", function () {
            vectorA = { x: 125, y: 130 };
            var isEmpty = Vector.isEmpty(vectorA);
            expect(isEmpty).toBe(false);
        });
        it("Equals - return true", function () {
            vectorA = { x: 180, y: 95 };
            vectorB = { x: 180, y: 95 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(true);
        });
        it("Equals - return false", function () {
            vectorA = { x: 180, y: 95 };
            vectorB = { x: 100, y: 180 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Equals - first value is null", function () {
            vectorA = null;
            vectorB = { x: 150, y: 117 };
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Equals - second value is null", function () {
            vectorA = { x: 156, y: 95 };
            vectorB = null;
            var isEquals = Vector.equals(vectorA, vectorB);
            expect(isEquals).toBe(false);
        });
        it("Clone", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.clone(vectorA);
            expect(vectorB.left).toBe(vectorA.left);
            expect(vectorB.top).toBe(vectorA.top);
        });
        it("Clone - null value", function () {
            vectorA = null;
            vectorB = Vector.clone(vectorA);
            expect(vectorB).toBe(null);
        });
        it("To string", function () {
            vectorA = { x: 215, y: 412 };
            var vectorString = Vector.toString(vectorA);
            expect(vectorString).toBe("{x:215, y:412}");
        });
        it("Get Length", function () {
            vectorA = { x: 215, y: 412 };
            var vectorLength = Vector.getLength(vectorA);
            var vectorLengthCalculated = Math.sqrt(215 * 215 + 412 * 412);
            expect(vectorLength).toBe(vectorLengthCalculated);
        });
        it("Get Length - Zero", function () {
            vectorA = { x: 0, y: 0 };
            var vectorLength = Vector.getLength(vectorA);
            expect(vectorLength).toBe(0);
        });
        it("Get Length Sqr", function () {
            vectorA = { x: 215, y: 412 };
            var vectorLength = Vector.getLengthSqr(vectorA);
            var vectorLengthCalculated = 215 * 215 + 412 * 412;
            expect(vectorLength).toBe(vectorLengthCalculated);
        });
        it("Get Length Sqr - Zero", function () {
            vectorA = { x: 0, y: 0 };
            var vectorLength = Vector.getLengthSqr(vectorA);
            expect(vectorLength).toBe(0);
        });
        it("Scale - Greater than 1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 15);
            expect(vectorB.x).toBe(vectorA.x * 15);
            expect(vectorB.y).toBe(vectorA.y * 15);
        });
        it("Scale -  1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 1);
            expect(vectorB.x).toBe(vectorA.x);
            expect(vectorB.y).toBe(vectorA.y);
        });
        it("Scale -  between 0 and 1", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, 0.4);
            expect(vectorB.x).toBe(vectorA.x * 0.4);
            expect(vectorB.y).toBe(vectorA.y * 0.4);
        });
        it("Scale -  0", function () {
            vectorA = { x: 215, y: 412 };
            ;
            vectorB = Vector.scale(vectorA, 0);
            expect(vectorB.x).toBe(0);
            expect(vectorB.y).toBe(0);
        });
        it("Scale -  Negative", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.scale(vectorA, -4);
            expect(vectorB.x).toBe(vectorA.x * -4);
            expect(vectorB.y).toBe(vectorA.y * -4);
        });
        it("Normalize", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.normalize(vectorA);
            var vectorALength = Vector.getLength(vectorA);
            var newVector = { x: vectorA.x / vectorALength, y: vectorA.y / vectorALength };
            expect(newVector.x).toBe(vectorB.x);
            expect(newVector.y).toBe(vectorB.y);
        });
        it("Normalize - empty vector", function () {
            vectorA = { x: 0, y: 0 };
            vectorB = Vector.normalize(vectorA);
            expect(vectorB.x).toBe(0);
            expect(vectorB.y).toBe(0);
        });
        it("Rotate Vector 90 degrees CW", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate90DegCW(vectorA);
            expect(vectorB.x).toBe(vectorA.y);
            expect(vectorB.y).toBe(-vectorA.x);
        });
        it("Rotate Vector 90 degrees CCW", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate90DegCCW(vectorA);
            expect(vectorB.x).toBe(-vectorA.y);
            expect(vectorB.y).toBe(vectorA.x);
        });
        /*Using the Vector rotate formula newX=(X*cosA)-(y*sinA) */
        it("Rotate - between 0 to 360 degrees", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate(vectorA, 47);
            var newVector = { x: vectorA.x * Math.cos(47) - vectorA.y * Math.sin(47), y: vectorA.x * Math.sin(47) + vectorA.y * Math.cos(47) };
            expect(vectorB.x).toBe(newVector.x);
            expect(vectorB.y).toBe(newVector.y);
        });
        it("Rotate - 0 degrees", function () {
            vectorA = { x: 215, y: 412 };
            vectorB = Vector.rotate(vectorA, 0);
            expect(vectorB.x).toBe(vectorA.x);
            expect(vectorB.y).toBe(vectorA.y);
        });
        it("Equals (static) - return true ", function () {
            vectorA = { x: 130, y: 47 };
            vectorB = { x: 130, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Equals (static) - return false ", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 110, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, vectorB);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vector A is null ", function () {
            vectorB = { x: 121, y: 88 };
            var areVectorsEqual = Vector.equals(null, vectorB);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vector B is null ", function () {
            vectorA = { x: 114, y: 47 };
            var areVectorsEqual = Vector.equals(vectorA, null);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals (static) - Vectors are null ", function () {
            var areVectorsEqual = Vector.equals(null, null);
            expect(areVectorsEqual).toBe(false);
        });
        it("Equals with Precision (static) - return true ", function () {
            vectorA = { x: 130, y: 114.4 };
            vectorB = { x: 130, y: 114.4 };
            var areVectorsEqual = Shapes.Thickness.equalWithPrecision(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Equals with Precision (static) - return false ", function () {
            vectorA = { x: 130.2, y: 114 };
            vectorB = { x: 130, y: 114 };
            var areVectorsEqual = Shapes.Thickness.equalWithPrecision(vectorA, vectorB);
            expect(areVectorsEqual).toBe(true);
        });
        it("Add 2 Vectors", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 117, y: 134 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x + vectorB.x);
            expect(newVector.y).toBe(vectorA.y + vectorB.y);
        });
        it("Add Vector to Empty Vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 0, y: 0 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x);
            expect(newVector.y).toBe(vectorA.y);
        });
        it("Add Vector to its Inverse vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: -114, y: -47 };
            var newVector = Vector.add(vectorA, vectorB);
            expect(newVector.x).toBe(0);
            expect(newVector.y).toBe(0);
        });
        it("Subtract 2 Vectors", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 117, y: 134 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x - vectorB.x);
            expect(newVector.y).toBe(vectorA.y - vectorB.y);
        });
        it("Subtract Vector to Empty Vector", function () {
            vectorA = { x: 114, y: 47 };
            vectorB = { x: 0, y: 0 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(vectorA.x);
            expect(newVector.y).toBe(vectorA.y);
        });
        it("Subtract Vector from the same vector", function () {
            vectorA = { x: 116, y: 49 };
            vectorB = { x: 116, y: 49 };
            var newVector = Vector.subtract(vectorA, vectorB);
            expect(newVector.x).toBe(0);
            expect(newVector.y).toBe(0);
        });
        it("dotProduct", function () {
            vectorA = { x: 116, y: 49 };
            vectorA = { x: 140, y: 154 };
            var dotProduct = Shapes.Vector.dotProduct(vectorA, vectorB);
            var dotProductCalculated = vectorA.x * vectorB.x + vectorA.y * vectorB.y;
            expect(dotProduct).toBe(dotProductCalculated);
        });
        it("Delta Vector", function () {
            var pointA = { x: 145, y: 217 };
            var pointB = { x: 140, y: 154 };
            var vectorA = Shapes.Vector.getDeltaVector(pointA, pointB);
            expect(vectorA.x).toBe(pointB.x - pointA.x);
            expect(vectorA.y).toBe(pointB.y - pointA.y);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
// tslint rule disabled because of tslint (version >= v2.2.0-beta) thinks that 'SVGUtil' is unused var. 
/* tslint:disable:no-unused-variable */
var SVGUtil = powerbi.visuals.SVGUtil;
describe("SvgUtil tests", function () {
    it('validate the pie chart transform parsing logic for Chrome', function () {
        var transform = 'translate(110.21,46.5)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.21');
        expect(parsedTransform.y).toBe('46.5');
    });
    it('validate the pie chart transform parsing logic for IE', function () {
        var transform = 'translate(110.6 34.56)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.6');
        expect(parsedTransform.y).toBe('34.56');
    });
    it('validate transform parsing logic with no y value', function () {
        var transform = 'translate(110.6)';
        var parsedTransform = SVGUtil.parseTranslateTransform(transform);
        expect(parsedTransform.x).toBe('110.6');
        expect(parsedTransform.y).toBe('0');
    });
    it('validate convertToPixelString', function () {
        var pixelString = SVGUtil.convertToPixelString(34);
        expect(pixelString).toBe('34px');
    });
});
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var UrlHelper = powerbi.visuals.UrlHelper;
    describe("UrlHelper isValidUrl", function () {
        var webUrlColumnMetadata = {
            displayName: "webUrl",
            type: new powerbi.ValueType(powerbi.ExtendedType.WebUrl, "WebUrl")
        };
        var textColumnMetadata = {
            displayName: "text",
            type: new powerbi.ValueType(powerbi.ExtendedType.Text, "Text")
        };
        it("isValidUrl null", function () {
            expect(UrlHelper.isValidUrl(null, null)).toBe(false);
        });
        it("isValidUrl http", function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, "http://www.microsoft.com")).toBe(true);
        });
        it("isValidUrl https", function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, "https://www.microsoft.com")).toBe(true);
        });
        it("isValidUrl HTTPS", function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, "HTTPS://WWW.MICROSOFT.COM")).toBe(true);
        });
        it("isValidUrl dataUri", function () {
            expect(UrlHelper.isValidUrl(webUrlColumnMetadata, "data://www.microsoft.com")).toBe(false);
        });
        it("isValidUrl not weburl", function () {
            expect(UrlHelper.isValidUrl(textColumnMetadata, "http://www.microsoft.com")).toBe(false);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var Controls = powerbi.visuals.controls;
    var InternalControls = powerbi.visuals.controls.internal;
    describe("TablixGrid", function () {
        it("onStartRenderingSession clear", function () {
            var control = createTablixControl();
            var grid = control.layoutManager.grid;
            var gridPresenter = grid._presenter;
            gridPresenter["_owner"] = grid;
            grid["_owner"] = control;
            grid.onStartRenderingIteration();
            grid.getOrCreateColumn(0);
            grid.getOrCreateColumn(1);
            grid.getOrCreateRow(0);
            grid.getOrCreateRow(1);
            grid.getOrCreateFootersRow();
            grid.onStartRenderingSession(true);
            expect(grid["_rows"]).toBe(null);
            expect(grid["_columns"]).toBe(null);
            expect(grid["_footerRow"]).toBe(null);
        });
    });
    describe("TablixLayoutManager", function () {
        it("onStartRenderingSession clear", function () {
            var layoutManager = InternalControls.CanvasTablixLayoutManager.createLayoutManager(createMockBinder());
            var grid = layoutManager.grid;
            var gridSpy = spyOn(grid, "onStartRenderingSession");
            layoutManager.rowLayoutManager["onStartRenderingSession"] = function () { };
            layoutManager.columnLayoutManager["onStartRenderingSession"] = function () { };
            layoutManager.onStartRenderingSession(null, null, true);
            expect(gridSpy).toHaveBeenCalledWith(true);
        });
        it('RowLayoutManager getRealizedItemsCount noItems', function () {
            var tableBinder = createMockBinder();
            var layoutManager = InternalControls.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
            var rowLayoutManager = layoutManager.rowLayoutManager;
            rowLayoutManager["_realizedRows"] = null;
            var count = rowLayoutManager.getRealizedItemsCount();
            expect(count).toBe(0);
        });
        it('ColumnLayoutManager getRealizedItemsCount noItems', function () {
            var tableBinder = createMockBinder();
            var layoutManager = InternalControls.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
            var columnLayoutManager = layoutManager.columnLayoutManager;
            columnLayoutManager["_realizedColumns"] = null;
            var count = columnLayoutManager.getRealizedItemsCount();
            expect(count).toBe(0);
        });
        it('DimensionLayoutManager getRealizedItemsCount', function () {
            var tableBinder = createMockBinder();
            var layoutManager = InternalControls.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
            var rowLayoutManager = layoutManager.rowLayoutManager;
            spyOn(rowLayoutManager, "_getRealizedItems").and.returnValue([1, 2, 3]);
            var count = rowLayoutManager.getRealizedItemsCount();
            expect(count).toBe(3);
        });
    });
    describe("TablixControl", function () {
        var tablixControl;
        var layoutManager;
        beforeEach(function () {
            tablixControl = createTablixControl();
            layoutManager = tablixControl.layoutManager;
        });
        it("Render clear calls clearRows once", function () {
            // Force a few rendering iterations.
            var counter = 3;
            layoutManager["onEndRenderingIteration"] = function () { return 0 === counter--; };
            var spy = spyOn(layoutManager.grid, "clearRows");
            tablixControl.refresh(true);
            expect(spy.calls.all().length).toBe(1);
        });
        it("Render clear false no clearRows call", function () {
            var counter = 1;
            layoutManager["onEndRenderingIteration"] = function () { return 0 === counter--; };
            var spy = spyOn(layoutManager.grid, "clearRows");
            tablixControl.refresh(false);
            expect(spy).not.toHaveBeenCalled();
        });
        it("DOMMouseScroll dispatches to row scrollbar", function () {
            var spy = spyOn(tablixControl.rowDimension.scrollbar, "onFireFoxMouseWheel");
            spy.and.stub();
            tablixControl.rowDimension.scrollbar["_visible"] = true;
            tablixControl.container.dispatchEvent(createMouseWheelEvent("DOMMouseScroll", -100));
            expect(spy).toHaveBeenCalled();
        });
        it("mousewheel dispatches to row scrollbar", function () {
            var spy = spyOn(tablixControl.rowDimension.scrollbar, "onMouseWheel");
            spy.and.stub();
            tablixControl.rowDimension.scrollbar["_visible"] = true;
            tablixControl.container.dispatchEvent(createMouseWheelEvent("mousewheel", -100));
            expect(spy).toHaveBeenCalled();
        });
        it("mousewheel dispatches to dimension scrollbar", function () {
            var spy = spyOn(tablixControl.columnDimension.scrollbar, "onMouseWheel");
            spy.and.stub();
            tablixControl.rowDimension.scrollbar["_visible"] = false;
            tablixControl.columnDimension.scrollbar["_visible"] = true;
            tablixControl.container.dispatchEvent(createMouseWheelEvent("mousewheel", -100));
            expect(spy).toHaveBeenCalled();
        });
    });
    describe("Scrollbar", function () {
        var scrollbar;
        beforeEach(function () {
            scrollbar = new Controls.Scrollbar(document.createElement("div"));
        });
        it("Uses mouse wheel range", function () {
            var scrollSpy = spyOn(scrollbar, "scrollBy");
            scrollSpy.and.stub();
            scrollbar.onMouseWheel(createMouseWheelEvent("mousewheel", -10));
            expect(scrollSpy).toHaveBeenCalledWith(1);
        });
        it("Detects end of scroll", function () {
            var callbackCalled = false;
            var callback = function () { callbackCalled = true; };
            scrollbar._onscroll.push(function () { return callback(); });
            scrollbar.viewMin = 2;
            scrollbar.viewSize = 8;
            scrollbar.onMouseWheel(createMouseWheelEvent("mousewheel", -240));
            expect(callbackCalled).toBeFalsy();
        });
    });
    function createTablixControl() {
        var tableBinder = createMockBinder();
        var layoutManager = InternalControls.CanvasTablixLayoutManager.createLayoutManager(tableBinder);
        var tablixOptions = {
            interactive: true,
            enableTouchSupport: false,
            layoutKind: Controls.TablixLayoutKind.Canvas
        };
        return new Controls.TablixControl(createMockNavigator(), layoutManager, tableBinder, document.createElement("div"), tablixOptions);
    }
    function createMockBinder() {
        return {
            onStartRenderingSession: function () { },
            onEndRenderingSession: function () { },
            bindRowHeader: function (item, cell) { },
            unbindRowHeader: function (item, cell) { },
            bindColumnHeader: function (item, cell) { },
            unbindColumnHeader: function (item, cell) { },
            bindBodyCell: function (item, cell) { },
            unbindBodyCell: function (item, cell) { },
            bindCornerCell: function (item, cell) { },
            unbindCornerCell: function (item, cell) { },
            bindEmptySpaceHeaderCell: function (cell) { },
            unbindEmptySpaceHeaderCell: function (cell) { },
            bindEmptySpaceFooterCell: function (cell) { },
            unbindEmptySpaceFooterCell: function (cell) { },
            getHeaderLabel: function (item) { return "label"; },
            getCellContent: function (item) { return "label"; },
            hasRowGroups: function () { return true; }
        };
    }
    function createMockNavigator() {
        return {
            getDepth: function (hierarchy) { return 1; },
            getLeafCount: function (hierarchy) { return 1; },
            getLeafAt: function (hierarchy, index) { return 1; },
            getParent: function (item) { },
            getIndex: function (item) { return 1; },
            isLeaf: function (item) { return true; },
            isRowHierarchyLeaf: function (cornerItem) { return true; },
            isColumnHierarchyLeaf: function (cornerItem) { return true; },
            isLastItem: function (item, items) { return true; },
            getChildren: function (item) { },
            getCount: function (items) { return 1; },
            getAt: function (items, index) { return 1; },
            getLevel: function (item) { return 1; },
            getIntersection: function (rowItem, columnItem) { },
            getCorner: function (rowLevel, columnLevel) { },
            headerItemEquals: function (item1, item2) { return true; },
            bodyCellItemEquals: function (item1, item2) { return true; },
            cornerCellItemEquals: function (item1, item2) { return true; }
        };
    }
    function createMouseWheelEvent(eventName, delta) {
        var evt = document.createEvent("MouseEvents");
        evt.initMouseEvent(eventName, true, true, null, 120, 0, 0, 0, 0, false, false, false, false, 0, null // EventTarget relatedTargetArg
        );
        var mouseEvt = evt;
        mouseEvt.wheelDelta = delta;
        return mouseEvt;
    }
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var visuals = powerbi.visuals;
    describe("ColorAllocatorFactory - linear gradient two colors", function () {
        var colorer;
        beforeEach(function () {
            colorer = visuals.createColorAllocatorFactory().linearGradient2({
                min: { value: 100, color: "#ff0000" },
                max: { value: 200, color: "#0000ff" }
            });
        });
        it("LinearGradient2: min value", function () {
            expect(colorer.color(100)).toBe("#ff0000");
        });
        it("LinearGradient2: max value", function () {
            expect(colorer.color(200)).toBe("#0000ff");
        });
        it("LinearGradient2: mid value", function () {
            expect(colorer.color(150)).toBe("#800080");
        });
        it("LinearGradient2: intermediate value", function () {
            expect(colorer.color(120)).toBe("#cc0033");
        });
        it("LinearGradient2 clamping - test values outside the range", function () {
            expect(colorer.color(90)).toBe("#ff0000");
            expect(colorer.color(220)).toBe("#0000ff");
        });
    });
    describe("ColorAllocatorFactory - linear gradient three colors", function () {
        var defaultColorer;
        var options;
        beforeEach(function () {
            options = {
                min: { value: 100, color: "#ff0000" },
                mid: { value: 150, color: "#ffffff" },
                max: { value: 200, color: "#0000ff" }
            };
            defaultColorer = visuals.createColorAllocatorFactory().linearGradient3(options, false);
        });
        it("LinearGradient3: min value", function () {
            expect(defaultColorer.color(100)).toBe("#ff0000");
        });
        it("LinearGradient3: max value", function () {
            expect(defaultColorer.color(200)).toBe("#0000ff");
        });
        it("LinearGradient3: mid value", function () {
            options.mid.value = 170;
            var colorer = visuals.createColorAllocatorFactory().linearGradient3(options, false);
            expect(colorer.color(170)).toBe("#ffffff");
        });
        it("LinearGradient3: intermediate value", function () {
            options.mid.value = 176;
            var colorer = visuals.createColorAllocatorFactory().linearGradient3(options, false);
            expect(colorer.color(178)).toBe("#eaeaff");
        });
        it("LinearGradient3: between min & mid", function () {
            options.mid.value = 176;
            var colorer = visuals.createColorAllocatorFactory().linearGradient3(options, false);
            expect(colorer.color(170)).toBe("#ffebeb");
        });
        it("LinearGradient3 clamping - test values outside the range", function () {
            expect(defaultColorer.color(0)).toBe("#ff0000");
            expect(defaultColorer.color(300)).toBe("#0000ff");
        });
        it("LinearGradient3: splitted scales", function () {
            var colorer = visuals.createColorAllocatorFactory().linearGradient3({
                min: { value: -50, color: "#ffff00" },
                mid: { value: 0, color: "#ffffff" },
                max: { value: 2000, color: "#0000ff" }
            }, true);
            expect(colorer.color(-50)).toBe("#ffff00");
            expect(colorer.color(-25)).toBe("#ffff80");
            expect(colorer.color(0)).toBe("#ffffff");
            expect(colorer.color(1000)).toBe("#8080ff");
            expect(colorer.color(2000)).toBe("#0000ff");
        });
    });
})(powerbitests || (powerbitests = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var GeocodeQuery = powerbi.visuals.BI.Services.GeocodingManager.GeocodeQuery;
    describe('General GeocodeCache Tests', function () {
        var cache;
        var createGeocodingCache = powerbi.visuals.BI.Services.createGeocodingCache;
        var maxCacheSize = 3000;
        var maxCacheSizeOverflow = 100;
        beforeEach(function () {
            cache = createGeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            localStorage.clear();
        });
        it('Cache Hit', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            var utahQuery = new GeocodeQuery("Utah", "State");
            var utahCoord = { latitude: 15, longitude: 15 };
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            cache.registerCoordinates(utahQuery, utahCoord);
            expect(cache.getCoordinates(washingtonQuery)).toEqual(washingtonCoord);
            expect(cache.getCoordinates(utahQuery)).toEqual(utahCoord);
        });
        it('Cache Miss', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            var utahQuery = new GeocodeQuery("Utah", "State");
            var utahCoord = { latitude: 15, longitude: 15 };
            var newYorkQuery = new GeocodeQuery("New York", "State");
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            cache.registerCoordinates(utahQuery, utahCoord);
            expect(cache.getCoordinates(newYorkQuery)).toBeFalsy();
        });
        it('Local storage hit', function () {
            var washingtonQuery = new GeocodeQuery("Washington", "State");
            var washingtonCoord = { latitude: 10, longitude: 10 };
            cache.registerCoordinates(washingtonQuery, washingtonCoord);
            var newCache = createGeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            expect(newCache.getCoordinates(washingtonQuery)).toEqual(washingtonCoord);
        });
    });
})(powerbitests || (powerbitests = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/// <reference path="../../_references.ts"/>
var powerbitests;
(function (powerbitests) {
    var SelectionId = powerbi.visuals.SelectionId;
    describe('Web interactivity service', function () {
        var interactivityService;
        var categoryA = powerbitests.mocks.dataViewScopeIdentity("A");
        var categoryB = powerbitests.mocks.dataViewScopeIdentity("B");
        describe('', function () {
            beforeEach(function () {
                var host = powerbitests.mocks.createVisualHostServices();
                interactivityService = new powerbi.visuals.WebInteractivityService(host);
            });
            it('selecting a single data point should set selected state', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                    { selected: true, identity: SelectionId.createWithId(categoryB, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], false);
                expect(dataPoints[0].selected).toBeTruthy();
                expect(dataPoints[1].selected).toBeFalsy();
            });
            it('selecting a highlighted data point should select non-highlight data point with the same id', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, true) },
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], false);
                expect(dataPoints[0].selected).toBeFalsy();
                expect(dataPoints[1].selected).toBeTruthy();
            });
            it('createPropertiesToHost: selecting a dataPoint should result in a VisualObjectInstance', function () {
                var dataPoints = [
                    { selected: false, identity: SelectionId.createWithId(categoryA, false) },
                ];
                interactivityService.selectableDataPoints = dataPoints;
                interactivityService.select(dataPoints[0], true);
                var propertyIdentifier = {
                    objectName: 'general',
                    propertyName: 'property'
                };
                var result = interactivityService.createPropertiesToHost(propertyIdentifier);
                expect(result.length).toBe(1);
                var firstResult = result[0];
                expect(firstResult.objectName).toBe('general');
                expect(firstResult.properties['property']).toBeDefined();
            });
            it('createPropertiesToHost: no selection should result in empty VisualObjectInstance', function () {
                var propertyIdentifier = {
                    objectName: 'general',
                    propertyName: 'property'
                };
                var result = interactivityService.createPropertiesToHost(propertyIdentifier);
                expect(result.length).toBe(1);
                var firstResult = result[0];
                expect(firstResult.objectName).toBe('general');
                expect(firstResult.properties['property']).toBeUndefined();
            });
        });
    });
})(powerbitests || (powerbitests = {}));
